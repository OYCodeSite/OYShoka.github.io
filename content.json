{"meta":{"title":"OY'Blog","subtitle":"","description":"","author":"OY","url":"http://blog.oy6090.top","root":"/"},"pages":[{"title":"关于我","date":"2021-01-21T18:26:29.000Z","updated":"2021-01-21T18:29:56.956Z","comments":true,"path":"about/index.html","permalink":"http://blog.oy6090.top/about/index.html","excerpt":"","text":"🏆关于我 欢迎来到我的小站呀，很高兴遇见你！🤝 👨‍🎓个人信息 标准的一名00后，目前还窝在校园里🏫🤪🥱 比起本名，我还是喜欢别人叫我 欧阳（OY） 大二 Student，坐标 🌏 湖南·常德，永远热爱，永远年轻相知 🤞 对一切新鲜的事物充满好奇 🧐 目标是成为一名出色的后端工程师 💪 对自己的要求是每天都要比昨天进步一点点 👊 ☕ 我的Github地址：https://github.com/OY6090 🍼 CSDN地址（目前正在更新中。。。） 🔑 技能学习 Java JavaWeb Spring、SpringMVC、Mybatis SpringBoot Vue 待掌握技能 Spring Cloud(正在学习中) ... 🔷最后 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;感谢你花时间阅读我的博客，欢迎与我沟通交流。祝好！&nbsp;"},{"title":"所有分类","date":"2021-01-21T16:31:51.323Z","updated":"2021-01-21T16:31:51.323Z","comments":true,"path":"categories/index.html","permalink":"http://blog.oy6090.top/categories/index.html","excerpt":"","text":""},{"title":"留言板","date":"2021-01-21T15:47:30.000Z","updated":"2021-01-21T18:21:52.731Z","comments":true,"path":"guestbook/index.html","permalink":"http://blog.oy6090.top/guestbook/index.html","excerpt":"","text":""},{"title":"哔哔","date":"2021-01-22T04:12:15.483Z","updated":"2021-01-22T04:12:15.483Z","comments":true,"path":"bb/index.html","permalink":"http://blog.oy6090.top/bb/index.html","excerpt":"","text":"👉🏼此说说通过📱手机微信发出，主要记录OY碎片化思考和动态。📑"},{"title":"我的朋友们","date":"2021-01-22T03:25:56.492Z","updated":"2021-01-22T03:25:56.492Z","comments":true,"path":"links/index.html","permalink":"http://blog.oy6090.top/links/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2021-01-21T16:32:27.410Z","updated":"2021-01-21T16:32:27.410Z","comments":true,"path":"tags/index.html","permalink":"http://blog.oy6090.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Vue 核心基础（2.X）","slug":"Vue 核心(2.X)","date":"2020-12-27T16:00:00.000Z","updated":"2021-01-22T03:46:37.788Z","comments":true,"path":"posts/41875.html","link":"","permalink":"http://blog.oy6090.top/posts/41875.html","excerpt":"","text":"一、Vue 的基本认识 官网： 英文官网: https://vuejs.org/ 中文官网: https://cn.vuejs.org/ 1、Vue 的特点 遵循MVVM 模式 编码简洁，体积小，运行效率高，适合移动/ PC 端开发 它本身只关注 UI， 可以轻松的引入 vue 插件或其他的第三库开发项目 二、Vue 的基本使用 永远的 HelloWord 编码： 1234567891011121314&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;username&quot; /&gt; &lt;p&gt;Hello, &#123;&#123;username&#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; new Vue(&#123; // 配置对象： 属性名是一些特定的名称 el: &quot;#app&quot;, // 值是选择器 element 用来查找跟元素 data: &#123; username: &quot;OY_test&quot;, // 包含多个可变数据的对象，相当于state,为模板页面提供数据 &#125;, &#125;);&lt;/script&gt; 效果示例： Vue 的 MVVM 三、模板语法 模板的理解 动态的 html 页面 包含了一些 JS 语法代码 双大括号表达式 （&#123;&#123;&#125;&#125;`） - 指令（以 v-开头的自定义标签属性） ### 1、双大括号表达式 - **语法：** `&#123;&#123;exp&#125;&#125; 功能： 向页面输出数据 可以调用对象的方法 2、指令一： 强制数据绑定 语法 指定变化的属性值 完整写法：v-bin:xxx = ‘yyy’ (yyy 会作为表达式解析执行) 简介写法： :xxx = ‘yyy’ 3、指令二：绑定事件监听 功能：绑定指定事件名的回调函数 完整写法： 1v-on:keyup&#x3D;&#39;xxx&#39; v-on:keyup&#x3D;&#39;xxx&#39;(参数) v-on:keyup.enter&#x3D;&#39;xxx&#39; 简介写法： 1@keyup&#x3D;&#39;xxx&#39; @keyup.enter&#x3D;&#39;xxx&#39; 4、编码示例12345678910111213141516171819202122232425262728293031&lt;div id&#x3D;&quot;app&quot;&gt; &lt;h2&gt;1. 双大括号表达式&lt;&#x2F;h2&gt; &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;&#x2F;p&gt; &lt;p&gt;&#123;&#123;msg.toUpperCase()&#125;&#125;&lt;&#x2F;p&gt; &lt;h2&gt;2. 指令一: 强制数据绑定&lt;&#x2F;h2&gt; &lt;a href&#x3D;&quot;url&quot;&gt;访问指定站点&lt;&#x2F;a&gt;&lt;br&#x2F;&gt;&lt;!--不能使用--&gt; &lt;a v-bind:href&#x3D;&quot;url&quot;&gt;访问指定站点2&lt;&#x2F;a&gt;&lt;br&#x2F;&gt; &lt;a :href&#x3D;&quot;url&quot;&gt;访问指定站点3&lt;&#x2F;a&gt; &lt;h2&gt;3. 指令二: 绑定事件监听&lt;&#x2F;h2&gt; &lt;button v-on:click&#x3D;&quot;handleClick&quot;&gt;点我&lt;&#x2F;button&gt; &lt;button @click&#x3D;&quot;handleClick&quot;&gt;点我2&lt;&#x2F;button&gt;&lt;&#x2F;div&gt;&lt;script src&#x3D;&quot;..&#x2F;js&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;new Vue(&#123; el: &quot;#app&quot;, data: &#123; msg: &quot;NBA I Like This Game!&quot;, url: &quot;http:&#x2F;&#x2F;www.baidu.com&quot;, &#125;, methods: &#123; handleClick() &#123; alert(&quot;处理点击&quot;); &#125;, &#125;,&#125;);&lt;&#x2F;script&gt; 效果示例： 四、计算属性和监视1、计算属性 在 computed 属性对象中定义计算属性的方法 在页面中使用 &#123;&#123;方法名&#125;&#125; 来显示计算的结果 2、监视属性 通过 vm 对象的 $watch() 或 watch 配置来监视指定的属性 当属性变化时，回调函数自动调用，在函数内部进行计算 3、编码示例123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;div id&#x3D;&quot;demo&quot;&gt; 姓: &lt;input type&#x3D;&quot;text&quot; placeholder&#x3D;&quot;First Name&quot; v-model&#x3D;&quot;firstName&quot;&gt;&lt;br&gt; 名: &lt;input type&#x3D;&quot;text&quot; placeholder&#x3D;&quot;Last Name&quot; v-model&#x3D;&quot;lastName&quot;&gt;&lt;br&gt; 姓名1(单向): &lt;input type&#x3D;&quot;text&quot; placeholder&#x3D;&quot;Full Name1&quot; v-model&#x3D;&quot;fullName1&quot;&gt;&lt;br&gt; 姓名2(单向): &lt;input type&#x3D;&quot;text&quot; placeholder&#x3D;&quot;Full Name2&quot; v-model&#x3D;&quot;fullName2&quot;&gt;&lt;br&gt; 姓名3(双向): &lt;input type&#x3D;&quot;text&quot; placeholder&#x3D;&quot;Full Name3&quot; v-model&#x3D;&quot;fullName3&quot;&gt;&lt;br&gt;&lt;&#x2F;div&gt;&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;..&#x2F;js&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;var vm &#x3D; new Vue(&#123; el: &quot;#demo&quot;, data: &#123; firstName: &quot;Kobe&quot;, lastName: &quot;bryant&quot;, fullName2: &quot;Kobe bryant&quot;, &#125;, computed: &#123; fullName1: function () &#123; return this.firstName + &quot; &quot; + this.lastName; &#125;, fullName3: &#123; get: function () &#123; return this.firstName + &quot; &quot; + this.lastName; &#125;, set: function (value) &#123; var names &#x3D; value.split(&quot; &quot;); this.firstName &#x3D; names[0]; this.lastName &#x3D; names[1]; &#125;, &#125;, &#125;, watch: &#123; lastName: function (newVal, oldVal) &#123; this.fullName2 &#x3D; this.firstName + &quot; &quot; + newVal; &#125;, &#125;,&#125;);vm.$watch(&quot;fistName&quot;, function (val) &#123; this.fullName2 &#x3D; val + &quot; &quot; + this.lastName;&#125;);&lt;&#x2F;script&gt; 效果示例： 五、Class 与 Style 绑定1、class 绑定 :class = ‘xxx’ 表达式是字符串： ‘classA’ 表达式是对象：{classA: isA, classB: isB} 表达式是数组：[‘classA’,’classB’] 2、style 绑定 :style=”{color: activeColor, fontSize: fontSize + ‘px’}” 其中 activeColor/fontSize 是 data 属性 3、编码示例1234567891011121314151617181920212223242526272829303132333435&lt;div id&#x3D;&quot;demo&quot;&gt; &lt;h2&gt;1. class绑定: :class&#x3D;&#39;xxx&#39;&lt;&#x2F;h2&gt; &lt;p class&#x3D;&quot;classC&quot; :class&#x3D;&quot;Myclass&quot;&gt;xxxx&lt;&#x2F;p&gt; &lt;p :class&#x3D;&quot;&#123;classA: hasA, classB: hasB&#125;&quot;&gt;yyyy&lt;&#x2F;p&gt; &lt;p :class&#x3D;&quot;[&#39;classA&#39;,&#39;classB&#39;]&quot;&gt;zzz&lt;&#x2F;p&gt; &lt;h2&gt;2. style绑定&lt;&#x2F;h2&gt; &lt;p :style&#x3D;&quot;&#123;color: Mycolor, fontSize: mySize + &#39;px&#39;&#125;&quot;&gt;xxxxxxx&lt;&#x2F;p&gt; &lt;button @click&#x3D;&quot;update&quot;&gt;更新&lt;&#x2F;button&gt;&lt;&#x2F;div&gt;&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;..&#x2F;js&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;new Vue(&#123; el: &quot;#demo&quot;, data: &#123; Myclass: &quot;classA&quot;, hasA: true, hasB: false, Mycolor: &quot;red&quot;, mySize: 20, &#125;, methods: &#123; update() &#123; console.log(this); (this.Myclass &#x3D; &quot;classB&quot;), (this.hasA &#x3D; !this.hasA), (this.hasB &#x3D; !this.hasB), (this.Mycolor &#x3D; &quot;#ff0000&quot;), (this.mySize &#x3D; 30); &#125;, &#125;,&#125;);&lt;&#x2F;script&gt; 效果示例： 六、条件渲染1、条件渲染指令 v-if 与 v-else v-show 2、比较 v-if 与 v-show 如果需要频繁切换 v-show 较好 当条件不成立时，v-if 的所有子节点不会解析(项目中使用) 3、编码1234567891011121314151617181920212223242526&lt;div id&#x3D;&quot;demo&quot;&gt; &lt;p v-if&#x3D;&quot;ok&quot;&gt;表白成功&lt;&#x2F;p&gt; &lt;p v-else&gt;表白失败&lt;&#x2F;p&gt; &lt;p v-show&#x3D;&quot;ok&quot;&gt;求婚成功&lt;&#x2F;p&gt; &lt;p v-show&#x3D;&quot;!ok&quot;&gt;求婚失败&lt;&#x2F;p&gt; &lt;button @Click&#x3D;&quot;toggle&quot;&gt;切换&lt;&#x2F;button&gt;&lt;&#x2F;div&gt;&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;..&#x2F;js&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;new Vue(&#123; el: &quot;#demo&quot;, data() &#123; return &#123; ok: true, &#125;; &#125;, methods: &#123; toggle() &#123; this.ok &#x3D; !this.ok; &#125;, &#125;,&#125;);&lt;&#x2F;script&gt; 效果示例： 七、列表渲染1、列表显示指令 数组: v-for / index 对象: v-for / key 2、列表的更新显示 删除 Item 替换 Item 3、列表的高级处理 列表过滤 VUE 数据绑定如何实现？ Vue 会监视 data 中所有的层次的属性 对象中的属性数据通过添加 set 方法来实现监视 数组中的元素对应也实现了监视；重写数组一系列更新元素的方法 调用原生的对应的方法对元素进行处理 去更新界面 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;div id&#x3D;&quot;demo&quot;&gt; &lt;h2&gt;测试: v-for 遍历数组&lt;&#x2F;h2&gt; &lt;ul&gt; &lt;li v-for&#x3D;&quot;(p, index) in persons&quot; :key&#x3D;&quot;p.id&quot;&gt; &#123;&#123;p.id&#125;&#125; -- &#123;&#123;p.name&#125;&#125; -- &#123;&#123;p.age&#125;&#125; -- &lt;button @click&#x3D;&quot;deleteP(index)&quot;&gt;删除&lt;&#x2F;button&gt; -- &lt;button @click&#x3D;&quot;updateP(index,&#123;id: Date.now(), name: &#39;Jarry&#39;,age: 19&#125;)&quot;&gt;更新&lt;&#x2F;button&gt; &lt;&#x2F;li&gt; &lt;&#x2F;ul&gt; &lt;h2&gt;测试: v-for 遍历对象&lt;&#x2F;h2&gt; &lt;ul&gt; &lt;li v-for&#x3D;&quot;(value, key) in persons[0]&quot; :key&#x3D;&quot;key&quot;&gt; &#123;&#123;key&#125;&#125; &#x3D; &#123;&#123;value&#125;&#125; &lt;&#x2F;li&gt; &lt;&#x2F;ul&gt;&lt;&#x2F;div&gt;&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;..&#x2F;js&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;new Vue(&#123; el: &quot;#demo&quot;, data: &#123; persons: [ &#123; id: 1, name: &quot;Tom&quot;, age: 15 &#125;, &#123; id: 2, name: &quot;Jack&quot;, age: 12 &#125;, &#123; id: 4, name: &quot;Bob&quot;, age: 17 &#125;, &#123; id: 6, name: &quot;Rose&quot;, age: 16 &#125;, &#123; id: 8, name: &quot;Else&quot;, age: 13 &#125;, ], &#125;, methods: &#123; deleteP(index) &#123; this.persons.splice(index, 1); &#125;, updateP(index, newP) &#123; &#x2F;&#x2F; 第一种方式 &#x2F;&#x2F; this.persons[index].id &#x3D; newP.id; &#x2F;&#x2F; this.Persons[index].name &#x3D; newP.name; &#x2F;&#x2F; this.Persons[index].age &#x3D; newP.age; &#x2F;&#x2F; this.persons[index] &#x3D; newP &#x2F;&#x2F; 不会更新界面 this.persons.splice(index, 1, newP); &#x2F;&#x2F; VUE重写后的splice方法 &#125;, &#125;,&#125;);&lt;&#x2F;script&gt; 效果示例： 列表排序 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;div id&#x3D;&quot;app&quot;&gt; &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;searchName&quot;&gt; &lt;ul&gt; &lt;li v-for&#x3D;&quot;(p, index) in filterPersons&quot; :key&#x3D;&quot;p.id&quot;&gt; &#123;&#123;p.id&#125;&#125; -- &#123;&#123;p.name&#125;&#125; -- &#123;&#123;p.age&#125;&#125; &lt;&#x2F;li&gt; &lt;&#x2F;ul&gt; &lt;button @click&#x3D;&quot;sortType&#x3D;2&quot;&gt;按年龄升序&lt;&#x2F;button&gt; &lt;button @click&#x3D;&quot;sortType&#x3D;3&quot;&gt;按年龄降序&lt;&#x2F;button&gt; &lt;button @click&#x3D;&quot;sortType&#x3D;1&quot;&gt;原本顺序&lt;&#x2F;button&gt; &lt;&#x2F;div&gt;&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;..&#x2F;js&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;new Vue(&#123; el: &quot;#app&quot;, data: &#123; searchName: &quot;&quot;, sortType: 1, &#x2F;&#x2F; 排序的类型, 1:不排序, 2:升序, 3: 降序 persons: [ &#123; id: 1, name: &quot;Tom&quot;, age: 15 &#125;, &#123; id: 2, name: &quot;Jack&quot;, age: 12 &#125;, &#123; id: 4, name: &quot;Bob&quot;, age: 17 &#125;, &#123; id: 6, name: &quot;Rose&quot;, age: 16 &#125;, &#123; id: 8, name: &quot;Else&quot;, age: 13 &#125;, ], &#125;, computed: &#123; filterPersons() &#123; &#x2F;&#x2F; 1.得到依赖数据 const &#123; sortType, searchName, persons &#125; &#x3D; this; &#x2F;&#x2F; 2. 进行计算处理，产生结果数据并返回 &#x2F;&#x2F; 过滤 const arr &#x3D; persons.filter((p) &#x3D;&gt; p.name.indexOf(searchName) &gt;&#x3D; 0); &#x2F;&#x2F; 进行排序 if (sortType !&#x3D;&#x3D; 1) &#123; arr.sort((p1, p2) &#x3D;&gt; &#123; if (sortType &#x3D;&#x3D;&#x3D; 2) &#123; &#x2F;&#x2F; 升序 return p1.age - p2.age; &#125; else &#123; &#x2F;&#x2F; 降序 return p2.age - p1.age; &#125; &#125;); &#125; return arr; &#125;, &#125;,&#125;);&lt;&#x2F;script&gt; 效果示例： 八、事件处理1、绑定监听 v-on:xxx=”fun” @xxx=”fun” @xxx=”fun(参数)” 默认事件形参: event 隐含属性对象: $event 2、事件修饰符 .prevent： 阻止事件的默认行为 event.preventDefault() .stop: 停止对事件冒泡 event.stopPropagation() 3、按键修饰符 .keycode： 操作的是某个 keycode 值的键 .keyName: 操作的某个按键名的键（少部分） 4、编码示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;div id&#x3D;&quot;example&quot;&gt; &lt;h2&gt;1. 绑定监听&lt;&#x2F;h2&gt; &lt;button @click&#x3D;&quot;test1&quot;&gt;test1&lt;&#x2F;button&gt; &lt;button @click&#x3D;&quot;test2(&#39;abc&#39;)&quot;&gt;test2&lt;&#x2F;button&gt; &lt;button @click&#x3D;&quot;test3(&#39;abc&#39;,$event)&quot;&gt;test3&lt;&#x2F;button&gt; &lt;h2&gt;2. 事件修饰符&lt;&#x2F;h2&gt; &lt;!-- 阻止(prevent)事件的默认行为 停止(stop)事件冒泡 --&gt; &lt;a href&#x3D;&quot;http:&#x2F;&#x2F;oy6090.top&quot; @click.prevent&#x3D;&quot;test4&quot;&gt;去学习&lt;&#x2F;a&gt; &lt;div style&#x3D;&quot;width:200px; height: 200px; background: red;&quot; @click&#x3D;&quot;test5&quot;&gt; &lt;div style&#x3D;&quot;width: 100px; height: 100px; background: blue;&quot; @click.stop&#x3D;&quot;test6&quot;&gt;&lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;p @clik.once&#x3D;&quot;test6&quot;&gt;xxxxx&lt;&#x2F;p&gt; &lt;h2&gt;3. 按键修饰符&lt;&#x2F;h2&gt; &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;msg&quot; @Keyup.13&#x3D;&quot;test7&quot;&gt; &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;msg&quot; @Keyup.enter&#x3D;&quot;test7&quot;&gt;&lt;&#x2F;div&gt;&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;..&#x2F;js&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt; new Vue(&#123; el: &#39;#example&#39;, data: &#123; msg: &#39;&#39; &#125;, methods: &#123; test1(e)&#123; alert(e.target.innerText); &#125;, test2(value)&#123; alert(value); &#125;, test3(value,event)&#123; alert(value+&quot;---&quot; + event.target.innerText); &#125;, test4(event)&#123; &#x2F;&#x2F;event.preventDefault(); alert(&#39;点击了&#39;); &#125;, test5()&#123; alert(&#39;out&#39;); &#125;, test6()&#123; alert(&#39;inner&#39;); &#125;, test7()&#123; alert(this.msg) &#125; &#125; &#125;)&lt;&#x2F;script&gt; 效果示例： 九、表单输入绑定1、使用 v-model 对表单数据自动收集 text/textarea checkbox radio select 2、编码示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;div id&#x3D;&quot;demo&quot;&gt; &lt;form action&#x3D;&quot;&#x2F;xxx&quot; @submit.prevent&#x3D;&quot;register&quot;&gt; &lt;span&gt;用户名: &lt;&#x2F;span&gt; &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;user.username&quot;&gt;&lt;br&gt; &lt;span&gt;密码: &lt;&#x2F;span&gt; &lt;input type&#x3D;&quot;password&quot; v-model&#x3D;&quot;user.pwd&quot;&gt;&lt;br&gt; &lt;span&gt;性别: &lt;&#x2F;span&gt; &lt;input type&#x3D;&quot;radio&quot; id&#x3D;&quot;female&quot; v-model&#x3D;&quot;user.sex&quot; value&#x3D;&quot;女&quot;&gt; &lt;label for&#x3D;&quot;female&quot;&gt;女&lt;&#x2F;label&gt; &lt;input type&#x3D;&quot;radio&quot; id&#x3D;&quot;male&quot; v-model&#x3D;&quot;user.sex&quot; value&#x3D;&quot;男&quot;&gt; &lt;label for&#x3D;&quot;male&quot;&gt;男&lt;&#x2F;label&gt;&lt;br&gt; &lt;span&gt;爱好: &lt;&#x2F;span&gt; &lt;input type&#x3D;&quot;checkbox&quot; id&#x3D;&quot;basket&quot; v-model&#x3D;&quot;user.likes&quot; value&#x3D;&quot;basket&quot;&gt; &lt;label for&#x3D;&quot;basket&quot;&gt;篮球&lt;&#x2F;label&gt; &lt;input type&#x3D;&quot;checkbox&quot; id&#x3D;&quot;foot&quot; v-model&#x3D;&quot;user.likes&quot; value&#x3D;&quot;foot&quot;&gt; &lt;label for&#x3D;&quot;foot&quot;&gt;足球&lt;&#x2F;label&gt; &lt;input type&#x3D;&quot;checkbox&quot; id&#x3D;&quot;pingpang&quot; v-model&#x3D;&quot;user.likes&quot; value&#x3D;&quot;pingpang&quot;&gt; &lt;label for&#x3D;&quot;pingpang&quot;&gt;乒乓&lt;&#x2F;label&gt;&lt;br&gt; &lt;span&gt;城市: &lt;&#x2F;span&gt; &lt;select v-model&#x3D;&quot;user.cityID&quot;&gt; &lt;option value&#x3D;&quot;&quot;&gt;未选择&lt;&#x2F;option&gt; &lt;option :value&#x3D;&quot;city.id&quot; v-for&#x3D;&quot;(city, index) in allcitys&quot; :key&#x3D;&quot;city.id&quot;&gt;&#123;&#123;city.name&#125;&#125;&lt;&#x2F;option&gt; &lt;&#x2F;select&gt;&lt;br&gt; &lt;span&gt;介绍: &lt;&#x2F;span&gt; &lt;textarea rows&#x3D;&quot;10&quot; v-model&#x3D;&quot;user.info&quot;&gt;&lt;&#x2F;textarea&gt;&lt;br&gt;&lt;br&gt; &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;注册&quot;&gt; &lt;&#x2F;form&gt;&lt;&#x2F;div&gt;&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;..&#x2F;js&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;new Vue(&#123; el: &quot;#demo&quot;, data: &#123; user: &#123; username: &quot;&quot;, pwd: &quot;&quot;, sex: &quot;女&quot;, likes: [&quot;foot&quot;], cityID: &quot;1&quot;, info: &quot;&quot;, &#125;, allcitys: [ &#123; id: 1, name: &quot;HN&quot; &#125;, &#123; id: 2, name: &quot;SZ&quot; &#125;, &#123; id: 3, name: &quot;HB&quot; &#125;, ], &#125;, methods: &#123; register() &#123; alert(&quot;发送注册的ajax请求：&quot; + JSON.stringify(this.user)); &#125;, &#125;,&#125;);&lt;&#x2F;script&gt; 示例效果： 十、Vue 实例生命周期1、生命周期流程图 2、Vue 生命周期分析 初始化显示 beforeCreate() created() beforeMount() mounted() 更新状态： this.xxx = value beforeUpdate() updated() 销毁 vue 实例：vm.$destory() beforeDestory() destoryed() 3、常用的生命周期方法 created()/mounted() : 发送 ajax 请求，启动定时器等异步任务。 beforeDestory(): 做收尾工作， 如： 清除定时器。 4、编码示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;div id&#x3D;&quot;test&quot;&gt; &lt;button @click&#x3D;&quot;destoryVM&quot;&gt;destory vue&lt;&#x2F;button&gt; &lt;p v-show&#x3D;&quot;isShow&quot; ref&#x3D;&quot;content&quot;&gt;Vue 生命周期 &#123;&#123;isShow ? &#39;show...&#39; : &#39;hide...&#39;&#125;&#125;&lt;&#x2F;p&gt;&lt;&#x2F;div&gt;&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;..&#x2F;js&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;new Vue(&#123; el: &quot;#test&quot;, data() &#123; return &#123; isShow: true, &#125;; &#125;, beforeCreate() &#123; console.log(&quot;beforeCreate()&quot;, this.isShow); &#125;, &#x2F;&#x2F; 实现数据代码： 后面可以通过vm 读取data 中的数据 created() &#123; console.log(&quot;created()&quot;); &#125;, &#x2F;&#x2F; 在第一次显示之后在显示 mounted() &#123; console.log(&quot;mounted()&quot;); this.intervalId &#x3D; setInterval(() &#x3D;&gt; &#123; console.log(&quot;-----&quot;); this.isShow &#x3D; !this.isShow; &#125;, 1000); &#125;, beforeUpdate() &#123; &#x2F;&#x2F; 读取是老的界面 console.log(&quot;beforeUpdate()&quot;, this.isShow, this.$refs.content.innerHTML); &#125;, updated() &#123; console.log(&quot;updated()&quot;, this.isShow, this.$refs.content.innerHTML); &#125;, &#x2F;&#x2F; 销毁之前执行一次 beforeDestroy() &#123; console.log(&quot;beforeDestroy()&quot;); clearInterval(this.intervalId); &#125;, destroyed() &#123; console.log(&quot;destroyed()&quot;); &#125;, methods: &#123; destoryVM() &#123; this.$destroy(); &#125;, &#125;,&#125;);&lt;&#x2F;script&gt; 实例效果： 十一、过渡&amp;动画1、vue 动画的理解 操作 css 的 trasition 或 animation vue 会给目标元素添加/移除特定的 class 过渡的相关类名 xxx-enter-active: 指定显示的 transition xxx-leave-active: 指定隐藏的 transition xxx-enter/xxx-leave-to: 指定隐藏时的样式 2、基本过渡动画的编码 在目标元素外包裹 &lt;transition name=”xxx”&gt; 定义 class 样式 指定过渡样式：transition 指定隐藏时的样式： opacity/其他 3、编码示例 示例一： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;style type&#x3D;&quot;text&#x2F;css&quot;&gt;&#x2F;*过渡样式*&#x2F;.move-enter-active,.move-leave-active &#123; transition: opacity 5s;&#125;&#x2F;*隐藏时的样式*&#x2F;.move-enter,.move-leave-to &#123; opacity: 0;&#125;&#x2F;*显示的过渡样式*&#x2F;.move2-enter-active &#123; transition: all 1s;&#125;&#x2F;*隐藏的过渡样式*&#x2F;.move2-leave-active &#123; transition: all 5s;&#125;&#x2F;*隐藏时的样式*&#x2F;.move2-enter,.move2-leave-to &#123; opacity: 0; transform: translateX(20px);&#125;&lt;&#x2F;style&gt;&lt;div id&#x3D;&quot;demo&quot;&gt; &lt;button v-on:click&#x3D;&quot;show&#x3D;!show&quot;&gt; Toggle &lt;&#x2F;button&gt; &lt;transition name&#x3D;&quot;move&quot;&gt; &lt;p v-show&#x3D;&quot;show&quot;&gt;Hello&lt;&#x2F;p&gt; &lt;&#x2F;transition&gt;&lt;&#x2F;div&gt;&lt;div id&#x3D;&quot;demo2&quot;&gt; &lt;button v-on:click&#x3D;&quot;show&#x3D;!show&quot;&gt; Toggle2 &lt;&#x2F;button&gt; &lt;transition name&#x3D;&quot;move2&quot;&gt; &lt;p v-show&#x3D;&quot;show&quot;&gt;Hello2&lt;&#x2F;p&gt; &lt;&#x2F;transition&gt;&lt;&#x2F;div&gt;&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;..&#x2F;js&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;new Vue(&#123; el: &quot;#demo&quot;, data: &#123; show: true, &#125;,&#125;);new Vue(&#123; el: &quot;#demo2&quot;, data: &#123; show: true, &#125;,&#125;);&lt;&#x2F;script&gt; 效果示例： 示例二： 12345678910111213141516171819202122232425262728293031323334353637&lt;style&gt;&#x2F;*显示动画样式*&#x2F;.bounce-enter-active &#123; animation: bounce-in 0.5s;&#125;.bounce-leave-active &#123; animation: bounce-in 0.5s reverse;&#125;@keyframes bounce-in &#123; 0% &#123; transform: scale(0); &#125; 50% &#123; transform: scale(1.5); &#125; 100% &#123; transform: scale(1); &#125;&#125;&lt;&#x2F;style&gt;&lt;div id&#x3D;&quot;example-2&quot;&gt; &lt;button @click&#x3D;&quot;show &#x3D; !show&quot;&gt;Toggle show&lt;&#x2F;button&gt;&lt;br&gt; &lt;transition name&#x3D;&quot;bounce&quot;&gt; &lt;p v-if&#x3D;&quot;show&quot; style&#x3D;&quot;display: inline-block;&quot;&gt;Lorem&lt;&#x2F;p&gt; &lt;&#x2F;transition&gt;&lt;&#x2F;div&gt;&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;..&#x2F;js&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script&gt;new Vue(&#123; el: &quot;#example-2&quot;, data: &#123; show: true, &#125;,&#125;);&lt;&#x2F;script&gt; 效果示例： 十二、过滤器 功能： 对要显示的数据进行特定格式化在显示 注意：并没有改变原有的数据，是产生新的对应的数据 1、定义和使用过滤器 定义过滤器 12Vue.filter(filterName,function(value[arg1,arg2,...]))&#123; &#x2F;&#x2F; 进行一定的数据处理return newValue; &#125; 使用过滤器 12&lt;div&gt;&#123;&#123;myData | filterName&#125;&#125;&lt;&#x2F;div&gt;&lt;div&gt;&#123;&#123;myData | filterName(arg)&#125;&#125;&lt;&#x2F;div&gt; 2、编码示例123456789101112131415161718192021222324&lt;div id&#x3D;&quot;test&quot;&gt; &lt;h2&gt;显示格式化的日期时间&lt;&#x2F;h2&gt; &lt;p&gt;&#123;&#123;startTime&#125;&#125;&lt;&#x2F;p&gt; &lt;p&gt;&#123;&#123;startTime | dateFormate&#125;&#125;&lt;&#x2F;p&gt; &lt;p&gt;&#123;&#123;startTime | dateFormate(&#39;YYYY-MM-DD&#39;)&#125;&#125;&lt;&#x2F;p&gt; &lt;p&gt;&#123;&#123;startTime | dateFormate(&#39;HH:mm:ss&#39;)&#125;&#125;&lt;&#x2F;p&gt;&lt;&#x2F;div&gt;&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcdn.net&#x2F;ajax&#x2F;libs&#x2F;moment.js&#x2F;2.29.1&#x2F;moment.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;..&#x2F;js&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;&#x2F;&#x2F; 自定义过滤器Vue.filter(&quot;dateFormate&quot;, function (value, formatStr &#x3D; &quot;YYYY-MM-DD HH:mm:ss&quot;) &#123; &#x2F;&#x2F;return moment(value).format(formatStr || &#39;YYYY-MM-DD HH:mm:ss&#39;) return moment(value).format(formatStr);&#125;);new Vue(&#123; el: &quot;#test&quot;, data() &#123; return &#123; startTime: Date.now() - 10000, &#125;; &#125;,&#125;);&lt;&#x2F;script&gt; 效果示例： 十三、内置指令与自定义指令1、常用内置指令 指令 描述 v-text 更新元素的 textContent v-html 更新元素的 innerHTML v-if 如果为 true, 当前标签才会输出到页面 v-else 如果为 false, 当前标签才会输出到页面 v-show 通过控制 display 样式来控制显示/隐藏 v-for 遍历数组/对象 v-on 绑定事件监听, 一般简写为@ v-bind 强制绑定解析表达式, 可以省略 v-bind v-model 双向数据绑定 ref 指定唯一标识, vue 对象通过$els 属性访问这个元素对象 v-cloak 防止闪现, 与 css 配合: [v-cloak] { display: none } 2、自定义指令 注册全局指令 12Vue.directive(&#39;my-directive&#39;, function(el, binding)&#123; el.innerHTML &#x3D;binding.value.toupperCase() &#125;) 注册局部指令 12directives : &#123; &#39;my-directive&#39; : &#123; bind (el, binding) &#123; el.innerHTML &#x3D;binding.value.toupperCase() &#125; &#125; &#125; 使用指令 1v-my-directive &#x3D; &#39;xxx&#39; 3、编码示例 内置指令 12345678910111213141516&lt;div id&#x3D;&quot;example&quot;&gt; &lt;p v-text&#x3D;&quot;msg&quot;&gt;&lt;&#x2F;p&gt; &lt;p v-html&#x3D;&quot;msg&quot;&gt;&lt;&#x2F;p&gt;&lt;&#x2F;div&gt;&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;..&#x2F;js&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;new Vue(&#123; el: &quot;#example&quot;, data() &#123; return &#123; msg: &#39;&lt;a href&#x3D;&quot;http:&#x2F;&#x2F;oy6090.top&quot;&gt;去浏览博客&lt;&#x2F;a&gt;&#39;, &#125;; &#125;,&#125;);&lt;&#x2F;script&gt; 效果示例： 自定义指令 12345678910111213141516171819202122232425262728293031&lt;!--需求: 自定义2个指令 1. 功能类型于v-text, 但转换为全大写 2. 功能类型于v-text, 但转换为全小写--&gt;&lt;div id&#x3D;&quot;test&quot;&gt; &lt;p v-upper-text&#x3D;&quot;msg&quot;&gt;&lt;&#x2F;p&gt; &lt;p v-lower-text&#x3D;&quot;msg&quot;&gt;&lt;&#x2F;p&gt;&lt;&#x2F;div&gt;&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;..&#x2F;js&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;&#x2F;&#x2F; 自定义全局指令Vue.directive(&quot;upper-text&quot;, (el, binding) &#x3D;&gt; &#123; console.log(&quot;upper-text&quot;, binding); el.innerText &#x3D; binding.value.toUpperCase();&#125;);new Vue(&#123; el: &quot;#test&quot;, data: &#123; msg: &quot;I will Back!&quot;, &#125;, &#x2F;&#x2F; 定义局部指令（只对当前vm的模板有效） directives: &#123; &quot;lower-text&quot;(el, binding) &#123; el.innerText &#x3D; binding.value.toLowerCase(); &#125;, &#125;,&#125;);&lt;&#x2F;script&gt; 效果示例： 十四、自定义插件 说明： Vue 插件是一个包含 install 方法的对象 通过 install 方法给 Vue 或 Vue 实例添加方法，定义全局指令 编码示例： 插件 JS （vue-myPlugin.js） 1234567891011121314151617181920212223/* 自定义插件*/(function () &#123; const MyPlugin = &#123;&#125;; MyPlugin.install = function (Vue, options) &#123; // 1.添加全局方法或属性 Vue.myGlobalMethod = function () &#123; alert(&quot;Vue 函数对象方法执行&quot;); &#125;; // 2.添加全局资源 Vue.directive(&quot;my-directive&quot;, function (el, binding) &#123; el.innerHTML = &quot;MyPlugin my-directive &quot; + binding.value; &#125;); // 3.添加实例方法 Vue.prototype.$myMethod = function () &#123; alert(&quot;vue 实例对象方法执行&quot;); &#125;; &#125;; window.MyPlugin = MyPlugin;&#125;)(); 页面使用插件 12345678910111213141516171819202122&lt;div id&#x3D;&quot;demo&quot;&gt; &lt;!-- 使用自定义指令 --&gt; &lt;p v-my-directive&#x3D;&quot;msg&quot;&gt;&lt;&#x2F;p&gt;&lt;&#x2F;div&gt;&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;..&#x2F;js&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script src&#x3D;&quot;vue-myPlugin.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;&#x2F;&#x2F; 使用自定义插件Vue.use(MyPlugin);var vm &#x3D; new Vue(&#123; el: &quot;#demo&quot;, data: &#123; msg: &quot;OY_Test&quot;, &#125;,&#125;);&#x2F;&#x2F; 调用自定义的静态方法Vue.myGlobalMethod();&#x2F;&#x2F; 调用自定义的对象方法vm.$myMethod();&lt;&#x2F;script&gt; 效果示例：","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://blog.oy6090.top/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://blog.oy6090.top/tags/Vue/"}]},{"title":"MySQL 主从复制","slug":"MySQL 主从复制","date":"2020-12-23T16:00:00.000Z","updated":"2021-01-20T14:48:14.259Z","comments":true,"path":"posts/6b30c31b.html","link":"","permalink":"http://blog.oy6090.top/posts/6b30c31b.html","excerpt":"","text":"MySQL 主从复制 环境准备： win10 MySQL 5.5 (主机) Linux CentOS7 MySQL 5.7 (从机) ==主从复制原理图：== MySQL 复制过程分成三步： master 将改变记录到二进制日志（binary log）。这些记录过程叫做二进制日志事件，binary log events； slave 将 master 的 binary log events 拷贝到它的中继日志（relay log）； slave 重做中继日志中的事件，将改变应用到自己的数据库中。 MySQL 复制是异步的且串行化的 复制的基本原则 每个 slave 只有一个 master 每个 slave 只能有一个唯一的服务器 ID 每个 master 可以有多个 salve ==注意：==复制的最大问题 延迟。 一主一从常见配置在开始之前需要注意一下几点： MySQL 版本一致且后台正常服务运行（博客开头以提及） 主从配置在[mysql]结点下，都是小写 主机修改 my.ini 配置文件（win10）​ my.ini 配置文件在 MySQL 的安装目录下，一般默认在 C:\\Program Files\\MySQL目录下。在修改之前最好先备份一下配置文件，如果在配置中发生错误，可以用配置文件恢复一下。 主服务器唯一 ID 1server-id=1 启用二进制日志 log-bin=自己本地的路径/data/mysqlbin 1log-bin=D:/devSoft/MySQLServer5.5/data/mysqlbin 设置不要复制的数据库 1binlog-ignore-db=mysql 设置需要复制的数据库 binlog-do-db=需要复制的主数据库名字 (根据自己情况而设置，博客我设置的复制的数据库是mysql_01,配置时这个数据库必须还不存在，不能用以前存在的库) 1binlog-do-db=mysql_01 设置 logbin 格式 1binlog_format=STATEMENT（默认） ==参考示例图：== mysql 主从复制起始时，从机不继承主机数据 从机修改 my.cnf 配置文件（CentOS 7）​ my.cnf 配置文件之前，建议您还是备份一份。 进入 my.cnf 文件目录 1[root@localhost /]# cd /etc 配置 12server-id &#x3D; 2relay-log&#x3D;mysql-relay 因修改过配置文件，请主机+从机都重启后台 mysql 服务win10: Linux CentOS7： 1systemctl restart mysqld 主机从机都关闭防火墙windows 手动关闭: 关闭 linux 防火墙: 1systemctl stop firewalld 在 Windows 主机上建立帐户并授权 slave格式：GRANT REPLICATION SLAVE ON *.* TO &#39;用户名&#39;@&#39;从机器数据库IP&#39; IDENTIFIED BY &#39;123456&#39;; 示例： 1GRANT REPLICATION SLAVE ON *.* TO &#x27;oy&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;123456&#x27;; 查询 master 的状态 1show master status; ==注意：==记录下 File 和 Position 的值。（后面会需要用到）执行完此步骤后不要再操作主服务器 MySQL，防止主服务器状态值变化。 在 Windows 主机上建立帐户并授权 slave格式： CHANGE MASTER TO MASTER_HOST=’主机 IP’, MASTER_USER=’zhangsan’, MASTER_PASSWORD=’123456’, MASTER_LOG_FILE=’File 名字’, MASTER_LOG_POS=Position 数字; 示例： 启动从服务器复制功能 1start slave; 检查服务 1show slave status\\G; 上面两个参数都是 Yes，则说明主从配置成功！ 测试主机新建库、新建表、insert 记录，从机复制windowns: 12345678910create database mydb_01;use mydb_01;create table mytb1( id int , name varchar(20) );insert into mytb1 values(1,&#x27;zhangsan&#x27;);insert into mytb1 values(2,&#x27;oy&#x27;); linux: 停止从服务复制功能1stop slave; 重新配置主从12stop slave;reset master;","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://blog.oy6090.top/categories/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://blog.oy6090.top/tags/MySQL/"}]},{"title":"CentOS 7 安装 MySQL 5.7","slug":"CentOS 7 安装 MySQL 5.7","date":"2020-12-09T16:00:00.000Z","updated":"2021-01-22T03:48:05.427Z","comments":true,"path":"posts/1c9cc24c.html","link":"","permalink":"http://blog.oy6090.top/posts/1c9cc24c.html","excerpt":"","text":"CentOS 7 安装 MySQL 5.7一、下载地址官网下载地址：http://dev.mysql.com/downloads/mysql/ 二、拷贝&amp;解压缩注意： 我自己本人使用版本是 mysql 5.7.16 但是目前官网上的 GA 版 mysql 是 5.7.32 版，两个版本安装都一样，版本选择根据自己来决定。这里以5.7.16版为演示。 三、检查工作1、检查当前系统是否安装过 mysql1rpm -qa|grep mariadb ==如果存在如下：== 请执行以下卸载命令： 1rpm -e --nodeps mariadb-libs 2、检查当前 mysql 依赖环境==执行安装命令前，先执行查询命令== 1rpm -qa|grep libaio 如果存在 libaio 包如下： ==在执行命令：== 1rpm -qa|grep net-tools 如果存在 net-tools 包如下： 如果不存在需要到 centos 安装盘里进行 rpm 安装 三、安装1、通过 Xftp 工具把在下载好文件发送到 Linux 的 opt 目录下 2、在 mysql 的安装目录下执行:==(必须按照顺序执行)==1234rpm -ivh mysql-community-common-5.7.16-1.el7.x86_64.rpmrpm -ivh mysql-community-libs-5.7.16-1.el7.x86_64.rpmrpm -ivh mysql-community-client-5.7.16-1.el7.x86_64.rpmrpm -ivh mysql-community-server-5.7.16-1.el7.x86_64.rpm ==注意：==如在检查工作时，没有检查 mysql 依赖环境在安装 mysql-community-server 会报错 四、查看 MySQL 安装版本执行以下命令： 1mysqladmin --version 五、MySQL 服务的初始化 为了保证数据库目录为与文件的所有者为 mysql 登陆用户，如果你是以 root 身份运行 mysql 服务，需要执行下面的命令初始化 1mysqld --initialize --user=mysql 注意：另外 –initialize 选项默认以“安全”模式来初始化，则会为 root 用户生成一个密码并将该密码标记为过期，登陆后你需要设置一个新的密码。 查看密码： 1cat /var/log/mysqld.log ==root@localhost: 后面就是初始化的密码== 六、MySQL 服务的启与停启动：systemctl start mysqld.service 关闭：systemctl stop mysqld.service 七、首次登陆 首次登陆通过 mysql -uroot -p进行登录，在 Enter password：录入初始化密码 因为初始化密码默认是过期的，所以查看数据库会报错 修改密码： 1ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;new_password&#x27;; 设置完密码就可以用新密码登陆，正常使用数据库了 ！！！ 八、自启动 mysql 服务 查看 mysql 是否自启动（默认自启动） 1systemctl list-unit-files|grep mysqld.service ==注意：==如不是 enabled 可以运行如下命令设置自启动 1systemctl enable mysqld.sercice 九、修改字符集问题 问题：mysql5.7 直接插入中文数据报错。 可以使用以下方法解决问题 修改配置文件 1vim /etc/my.cnf 在最后加上中文字符集配置: character_set_server=utf8 重新启动 mysql 1systemctl restart mysqld ==扩展：==已生成的库表字符集如何变更 修改数据库的字符集 1mysql&gt; alter database mydb character set &#x27;utf8&#x27;; 修改数据表的字符集 1mysql&gt; alter table mytbl convert to character set &#x27;utf8&#x27;; 到此，Linux 上的 MySQL 数据库就安装完成了 十、远程工具连接 MySQL 数据库 授予权限 先使用 mysql -uroot -p 进入数据库： 1grant all privileges on *.* to root@&#x27;%&#x27; identified by &#x27;password&#x27;; 授予通过网络方式登录的的 root 用户 ，对所有库所有表的全部权限，密码设为 6090. 远程连接 先 ping 一下数据库服务器的 ip 地址确认网络畅通。 关闭数据库服务的防火墙 补充：==(根据自己情况来选择)== 1234567891011// 查看当前防火墙状态如果防火墙处于开启状态，firewalld.service前面的点是高亮的，Active：active（开启））systemctl status firewalld.service//关闭当前的防火墙（仅对本次开机有效，重启后防火墙会再次启用）systemctl stop firewalld.service//永久关闭防火墙（重启后防火墙依然关闭）systemctl disable firewalld.service// 启动防火墙 systemctl start firewalld 演示使用命令： 1systemctl stop firewalld.service 使用 Navicat 连接 连接成功： ​ 如果使用的是云服务(阿里云、腾讯云等)记得去安全组里面配置规则，开放 3306 端口。 ==如果对你有帮助的话，请给我点个赞，写作不易，谢谢！！！！==","categories":[{"name":"CentOS","slug":"CentOS","permalink":"http://blog.oy6090.top/categories/CentOS/"}],"tags":[{"name":"CentOS 7","slug":"CentOS-7","permalink":"http://blog.oy6090.top/tags/CentOS-7/"}]},{"title":"Docker 基本操作总结","slug":"Docker 基本操作总结","date":"2020-11-24T16:00:00.000Z","updated":"2021-01-22T03:48:44.193Z","comments":true,"path":"posts/43758.html","link":"","permalink":"http://blog.oy6090.top/posts/43758.html","excerpt":"","text":"Docker 基本操作总结一、Docker 的基本组成① 镜像（image）​ Docker 镜像（Image）就是一个只读的模板。镜像可以用来创建 Docker 容器，一个镜像可以创建很多容器。 ② 容器（container） Docker 利用容器（Container）独立运行的一个或一组应用。==容器是用镜像创建的运行实例。== 它可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全的平台。 ==可以把容器看做是一个简易版的 Linux 环境==（包括 root 用户权限、进程空间、用户空间和网络空间等）和运行在其中的应用程序。 容器的定义和镜像几乎一模一样，也是一堆层的统一视角，唯一区别在于容器的最上面那一层是可读可写的。 ③ 仓库（repository） 仓库（Repository）是集中存放镜像文件的场所。 仓库(Repository)和仓库注册服务器（Registry）是有区别的。仓库注册服务器上往往存放着多个仓库，每个仓库中又包含了多个镜像，每个镜像有不同的标签（tag）。 仓库分为公开仓库（Public）和私有仓库（Private）两种形式。 最大的公开仓库是 Docker Hub(https://hub.docker.com/)，存放了数量庞大的镜像供用户下载。国内的公开仓库包括阿里云 、网易云 等 ④ Docker 的架构图 二、安装步骤请参考：https://docs.docker.com/engine/install/centos/ ① CentOS7 安装 Docker​ 官网中文安装参考手册：https://docs.docker-cn.com/engine/installation/linux/docker-ce/centos/#prerequisites 确定 CentOS7 版本 1cat /etc/redhat-release yum 安装 gcc 相关 1yum -y install gcc 1yum -y install gcc-c++ 卸载旧版本(根据自己的情况选择) 1yum -y remove docker docker-common docker-selinux docker-engine 安装需要的软件包 1yum install -y yum-utils device-mapper-persistent-data lvm2yum install -y yum-utils device-mapper-persistent-data lvm2 设置 stable 镜像仓库 1yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo 更新 yum 软件包索引 1yum makecache fast 安装 DOCKER CE 1yum -y install docker-ce 启动 docker 1systemctl start docker 9.测试 1docker version 1docker run hello-world 卸载 1systemctl stop docker 1yum -y remove docker-ce 1rm -rf /var/lib/docker ② 修改镜像加速源本篇博客采用的是 阿里云镜像源加速 可以先参考了解一下：https://dev.aliyun.com/search.html 注册一个属于自己的阿里云账户(可复用淘宝账号) 获得加速器地址连接 登陆阿里云开发者平台 获取加速器地址 ③ 配置本机 Docker 运行镜像加速器配置镜像加速CentOS7版本 mkdir -p /etc/docker vim /etc/docker/daemon.json 1234 #阿里云&#123; &quot;registry-mirrors&quot;: [&quot;https://｛自已的编码｝.mirror.aliyuncs.com&quot;]&#125; systemctl daemon-reload systemctl restart docker ④ 底层原理 Docker 工作机制 Docker 是一个 Client-Server 结构的系统，Docker 守护进程运行在主机上， 然后通过 Socket 连接从客户端访问，守护进程从客户端接受命令并管理运行在主机上的容器。 容器，是一个运行时环境，就是我们前面说到的集装箱。 三、Docker 常用命令① 帮助命令 docker version docker info docker info ② 镜像命令1、docker images 查看本地镜像仓库镜像源 各个选项说明: 选项 说明 REPOSITORY 表示镜像的仓库源 TAG 镜像的标签 IMAGE ID 镜像 ID CREATED 镜像创建时间 SIZE 镜像大小 ​ 同一仓库源可以有多个 TAG，代表这个仓库源的不同个版本，我们使用 REPOSITORY:TAG 来定义不同的镜像。如果你不指定一个镜像的版本标签，例如你只使用 ubuntu，docker 将默认使用 ubuntu:latest 镜像。 OPTIONS 说明： 参数 说明 -a 列出本地所有的镜像（含中间映像层） -q 只显示镜像 ID。 –digests 显示镜像的摘要信息 –no-trunc 显示完整的镜像信息 2、docker search 查询镜像源 docker search [OPTIONS] 镜像名字 OPTIONS 说明： 参数 说明 –no-trunc 显示完整的镜像描述 -s 列出收藏数不小于指定值的镜像。 –automated 只列出 automated build 类型的镜像 3、docker pull 拉取镜像源 docker pull 镜像名字[:TAG] 4、docker rmi 删除镜像源 删除单个 1docker rmi -f 镜像ID 删除多个 1docker rmi -f 镜像名1:TAG 镜像名2:TAG 删除全部 1docker rmi -f $(docker images -qa) ③ 容器命令 有镜像才能创建容器，这是根本前提(下载一个 CentOS 镜像演示) 1docker pull centos 新建并启动容器 docker run [OPTIONS] IMAGE [COMMAND] [ARG…] OPTIONS 说明 参数 说明 -d 后台运行容器，并返回容器 ID，也即启动守护式容器 -i 以交互模式运行容器，通常与 -t 同时使用 -t 为容器重新分配一个伪输入终端，通常与 -i 同时使用 -P 随机端口映射 -p 指定端口映射，有以下四种格式：ip:hostPort:containerPortip::containerPorthostPort:containerPortcontainerPort 列出当前所有正在运行的容器 docker ps [OPTIONS] OPTIONS 说明 参数 说明 -a 列出当前所有正在运行的容器+历史上运行过的 -l 显示最近创建的容器。 -n 显示最近 n 个创建的容器。 docker ps -n 3 -q 静默模式，只显示容器编号 –no-trunc 不截断输出 退出容器 exit: 容器停止退出 ctrl+P+Q: 容器不停止退出 启动容器 1docker start 容器ID或者容器名 重启容器 1docker restart 容器ID或者容器名 停止容器 1docker stop 容器ID或者容器名 强制停止容器 1docker kill 容器ID或者容器名 删除已停止的容器 1docker rm 容器ID 一次性删除多个容器 docker rm -f $(docker ps -a -q) docker ps -a -q | xargs docker rm ④ 核心命令1、启动守护式容器 启动守护式容器 1docker run -d 容器名 示例：使用镜像 centos:latest 以后台模式启动一个容器 1docker run -d centos 问题：然后 docker ps -a 进行查看, 会发现容器已经退出,很重要的要说明的一点: ==Docker 容器后台运行,就必须有一个前台进程.容器运行的命令如果不是那些一直挂起的命令（比如运行 top，tail）==，就是会自动退出的。 这个是 docker 的机制问题,比如你的 web 容器,我们以 nginx 为例，正常情况下,我们配置启动服务只需要启动响应的 service 即可。例如 service nginx start 但是,这样做,nginx 为后台进程模式运行,就导致 docker 前台没有运行的应用,这样的容器后台启动后,会立即自杀因为他觉得他没事可做了所以，最佳的解决方案是,将你要运行的程序以前台进程的形式运行。 从 Hub 上下载 tomcat 镜像到本地并成功运行 1docker run -it -p 8080:8080 tomcat 参数 说明 -p 主机端口:docker 容器端口 -P 随机分配端口 i 交互 t 终端 查看容器日志 1docker logs -f -t --tail 容器ID 1docker run -d centos &#x2F;bin&#x2F;sh -c &quot;while true;do echo hello zzyy;sleep 2;done&quot; 参数 说明 -t 是加入时间戳 -f 跟随最新的日志打印 –tail 数字 显示最后多少条 查看容器内运行的进程 1docker top 容器ID 进入正在运行的容器并以命令行交互 1docker exec -it 容器ID bashShell 其他： 1docker exec -it 容器ID ls -l /tmp 重新进入 docker attach 容器 ID ==上述两个区别== attach 直接进入容器启动命令的终端，不会启动新的进程 exec 是在容器中打开新的终端，并且可以启动新的进程 四、小总结常用命令： Docker 命令总结： 指令 英文 说明 attach Attach to a running container 当前 shell 下 attach 连接指定运行镜像 build Build an image from a Dockerfile 通过 Dockerfile 定制镜像 commit Create a new image from a container changes 提交当前容器为新的镜像 cp Copy files/folders from the containers filesystem to the host path 从容器中拷贝指定文件或者目录到宿主机中 create Create a new container 创建一个新的容器，同 run，但不启动容器 diff Inspect changes on a container’s filesystem 查看 docker 容器变化 events Get real time events from the server 从 docker 服务获取容器实时事件 exec Run a command in an existing container 在已存在的容器上运行命令 export Stream the contents of a container as a tar archive 导出容器的内容流作为一个 tar 归档文件[对应 import ] history Show the history of an image 展示一个镜像形成历史 images List images 列出系统当前镜像 import Create a new filesystem image from the contents of a tarball 从 tar 包中的内容创建一个新的文件系统映像[对应 export] info Display system-wide information 显示系统相关信息 inspect Return low-level information on a container 查看容器详细信息 kill Kill a running container kill 指定 docker 容器 load Load an image from a tar archive 从一个 tar 包中加载一个镜像[对应 save] login Register or Login to the docker registry server 注册或者登陆一个 docker 源服务器 logout Log out from a Docker registry server 从当前 Docker registry 退出 logs Fetch the logs of a container 输出当前容器日志信息 port Lookup the public-facing port which is NAT-ed to PRIVATE_PORT 查看映射端口对应的容器内部源端口 pause Pause all processes within a container 暂停容器 ps List containers 列出容器列表 pull Pull an image or a repository from the docker registry server 从 docker 镜像源服务器拉取指定镜像或者库镜像 push Push an image or a repository to the docker registry server 推送指定镜像或者库镜像至 docker 源服务器 restart Restart a running container 重启运行的容器 rm Remove one or more containers 移除一个或者多个容器 rmi Remove one or more images 移除一个或多个镜像[无容器使用该镜像才可删除，否则需删除相关容器才可继续或 -f 强制删除] run Run a command in a new container 创建一个新的容器并运行一个命令 save Save an image to a tar archive 保存一个镜像为一个 tar 包[对应 load] search Search for an image on the Docker Hub 在 docker hub 中搜索镜像 start Start a stopped containers 启动容器 stop Stop a running containers 停止容器 tag Tag an image into a repository 给源中镜像打标签 top Lookup the running processes of a container 查看容器中运行的进程信息 unpause Unpause a paused container 取消暂停容器 version Show the docker version information 查看 docker 版本号 wait Block until a container stops, then print its exit code 截取容器停止时的退出状态值 更详细请参考：springboot 之 docker 博客","categories":[{"name":"JavaEE框架","slug":"JavaEE框架","permalink":"http://blog.oy6090.top/categories/JavaEE%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"java","slug":"java","permalink":"http://blog.oy6090.top/tags/java/"},{"name":"Docker","slug":"Docker","permalink":"http://blog.oy6090.top/tags/Docker/"}]},{"title":"SpringCloud Alibaba Seata处理分布式事务","slug":"SpringCloud Alibaba Seata处理分布式事务","date":"2020-11-16T16:00:00.000Z","updated":"2021-01-20T14:49:15.216Z","comments":true,"path":"posts/a8da4fb0.html","link":"","permalink":"http://blog.oy6090.top/posts/a8da4fb0.html","excerpt":"","text":"SpringCloud Alibaba Seata 处理分布式事务一、分布式事务问题① 分布式前​ 单机单库没这个问题 从 1： 1 -&gt; 1:N -&gt; N: N ② 分布式之后​ 单体应用被拆分成微服务应用， 原来的三个模块被拆分成三个独立的应用，分别使用三个独立的数据源。 ​ 业务操作需要调用三个服务来完成。 此时每个服务内部的数据一致性由本地事务来保证， 但是全局的数据一致性问题没法保证。 ③ 一句话​ 一次业务操作需要跨多个数据源或需要跨多个系统进行远程调用， 就会产生分布式事务问题 。 二、Seata 简介① 是什么​ Seata 是一款开源的分布式事务解决方案， 致力于在微服务架构下提供高性能和简单易用的分布式事务服务 ​ 官网地址 http://seata.io/zh-cn/ ② 能干嘛​ 一个典型的分布式事务过程 分布式事务处理过程的-ID+三组件模型 Transaction ID XID 全局唯一的事务 ID 3 组件概念 ==Transaction Coordinator(TC)==事务协调器， 维护全局事务的运行状态， 负责协调并驱动全局事务的提交或回滚; ==Transaction Manager(TM)==控制全局事务的边界， 负责开启一个全局事务， 并最终发起全局提交或全局回滚的决议; ==Resource Manager(RM)==控制分支事务， 负责分支注册， 状态汇报， 并接收事务协调器的指令， 驱动分支（本地） 事务的提交和回滚； 处理过程 去哪下 发布说明: https://github.com/seata/seata/releases 怎么玩 Spring 本地@Transactional 全局@GlobalTransactional 三、Seata-Server 安装① 官网地址1http:&#x2F;&#x2F;seata.io&#x2F;zh-cn&#x2F; ② 下载版本 ③ 修改配置文件 seata-server-0.9.0.zip 解压到指定目录并修改 conf 目 录下的 file.conf 配置文件 先备份原始 file.conf 文件 、 主要修改： 自定义事务组名称+事务日志存储模式为 db+数据库连接信息 file.conf service 模块 1vgroup_mapping.fsp_tx_group &#x3D; &quot;default&quot; store 模块 1234mode &#x3D; &quot;db&quot;url &#x3D; &quot;jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;seata&quot;user &#x3D; &quot;root&quot;password &#x3D; &quot;你自己的密码&quot; ④ mysql5.7 数据库新建库 seata1create database seata; ⑤ 在 seata 库里建表建 表 db_store.sql 在 \\seata-server-0.9.0\\seata\\conf 目 录 里 面 db_store.sq 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152-- the table to store GlobalSession datadrop table if exists `global_table`;create table `global_table` ( `xid` varchar(128) not null, `transaction_id` bigint, `status` tinyint not null, `application_id` varchar(32), `transaction_service_group` varchar(32), `transaction_name` varchar(128), `timeout` int, `begin_time` bigint, `application_data` varchar(2000), `gmt_create` datetime, `gmt_modified` datetime, primary key (`xid`), key `idx_gmt_modified_status` (`gmt_modified`, `status`), key `idx_transaction_id` (`transaction_id`));-- the table to store BranchSession datadrop table if exists `branch_table`;create table `branch_table` ( `branch_id` bigint not null, `xid` varchar(128) not null, `transaction_id` bigint , `resource_group_id` varchar(32), `resource_id` varchar(256) , `lock_key` varchar(128) , `branch_type` varchar(8) , `status` tinyint, `client_id` varchar(64), `application_data` varchar(2000), `gmt_create` datetime, `gmt_modified` datetime, primary key (`branch_id`), key `idx_xid` (`xid`));-- the table to store lock datadrop table if exists `lock_table`;create table `lock_table` ( `row_key` varchar(128) not null, `xid` varchar(96), `transaction_id` long , `branch_id` long, `resource_id` varchar(256) , `table_name` varchar(32) , `pk` varchar(36) , `gmt_create` datetime , `gmt_modified` datetime, primary key(`row_key`)); ⑥ 修 改 seata-server-0.9.0\\seata\\conf 目 录 下 的 registry.conf 配置文件 、123456789registry &#123; # file 、nacos 、eureka、redis、zk、consul、etcd3、sofa type = &quot;nacos&quot; nacos &#123; serverAddr = &quot;localhost:8848&quot; namespace = &quot;&quot; cluster = &quot;default&quot; &#125; ==目的是==： 指明注册中心为 nacos， 及修改 nacos 连接信息 ⑦ 先启动 Nacos 端口号 8848⑧ 再启动 seata-server seata-server.bat 四、订单/库存/账户业务数据库准备① 以下演示都需要先启动 Nacos 后启动 Seata， 保证两个都 OK ② 分布式事务业务说明==业务说明== 下订单–&gt;扣库存–&gt;减账户（ 余额） ③ 创建业务数据库 seata_order: 存储订单的数据库 seata_storage:存储库存的数据库 seata_account: 存储账户信息的数据库 建表 SQL 123CREATE DATABASE seata_order；CREATE DATABASE seata_storage；CREATE DATABASE seata_account; ④ 按照上述 3 库分别建对应业务表 seata_order 库下建 t_order 表 12345678910CREATE TABLE t_order( `id` BIGINT(11) NOT NULL AUTO_INCREMENT PRIMARY KEY, `user_id` BIGINT(11) DEFAULT NULL COMMENT &#x27;用户 id&#x27;, `product_id` BIGINT(11) DEFAULT NULL COMMENT &#x27;产品 id&#x27;, `count` INT(11) DEFAULT NULL COMMENT &#x27;数量&#x27;, `money` DECIMAL(11,0) DEFAULT NULL COMMENT &#x27;金额&#x27;, `status` INT(1) DEFAULT NULL COMMENT &#x27;订单状态： 0： 创建中; 1： 已完结&#x27;) ENGINE=INNODB AUTO_INCREMENT=7 DEFAULT CHARSET=utf8;SELECT * FROM t_order; seata_storage 库下建 t_storage 表 12345678910CREATE TABLE t_storage( `id` BIGINT(11) NOT NULL AUTO_INCREMENT PRIMARY KEY, `product_id` BIGINT(11) DEFAULT NULL COMMENT &#x27;产品 id&#x27;, `total` INT(11) DEFAULT NULL COMMENT &#x27;总库存&#x27;, `used` INT(11) DEFAULT NULL COMMENT &#x27;已用库存&#x27;, `residue` INT(11) DEFAULT NULL COMMENT &#x27;剩余库存&#x27;) ENGINE=INNODB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;INSERT INTO t_storage(`id`,`product_id`,`total`,`used`,`residue`)VALUES(&#x27;1&#x27;,&#x27;1&#x27;,&#x27;100&#x27;,&#x27;0&#x27;,&#x27;100&#x27;);SELECT * FROM t_storage; seata_account 库下建 t_account 表 12345678910CREATE TABLE t_account( `id` BIGINT(11) NOT NULL AUTO_INCREMENT PRIMARY KEY COMMENT &#x27;id&#x27;, `user_id` BIGINT(11) DEFAULT NULL COMMENT &#x27;用户 id&#x27;, `total` DECIMAL(10,0) DEFAULT NULL COMMENT &#x27;总额度&#x27;, `used` DECIMAL(10,0) DEFAULT NULL COMMENT &#x27;已用余额&#x27;, `residue` DECIMAL(10,0) DEFAULT &#x27;0&#x27; COMMENT &#x27;剩余可用额度&#x27;) ENGINE=INNODB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;INSERT INTO seata_account.t_account(`id`,`user_id`,`total`,`used`,`residue`)VALUES(&#x27;1&#x27;,&#x27;1&#x27;,&#x27;1000&#x27;,&#x27;0&#x27;,&#x27;1000&#x27;)SELECT * FROM t_account; ⑤ 按照上述 3 库分别建对应的回滚日志表 订单-库存-账户 3 个库下都需要建各自的回滚日志表 \\seata-server-0.9.0\\seata\\conf 目录下的 db_undo_log.sql 建表 SQL 1234567891011121314drop table `undo_log`;CREATE TABLE `undo_log` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `branch_id` bigint(20) NOT NULL, `xid` varchar(100) NOT NULL, `context` varchar(128) NOT NULL, `rollback_info` longblob NOT NULL, `log_status` int(11) NOT NULL, `log_created` datetime NOT NULL, `log_modified` datetime NOT NULL, `ext` varchar(100) DEFAULT NULL, PRIMARY KEY (`id`), UNIQUE KEY `ux_undo_log` (`xid`,`branch_id`)) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8; ⑥ 最终效果 五、订单/库存/账户业务微服务准备1. 业务需求 下订单-&gt;减库存-&gt;扣余额-&gt;改（订单） 状态 2. 新建订单 Order-Module 建 Module : seata-order-service2001 POM 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;dependencies&gt; &lt;!--nacos--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--seata--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-seata&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;seata-all&lt;/artifactId&gt; &lt;groupId&gt;io.seata&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.seata&lt;/groupId&gt; &lt;artifactId&gt;seata-all&lt;/artifactId&gt; &lt;version&gt;0.9.0&lt;/version&gt; &lt;/dependency&gt; &lt;!--feign--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--web-actuator--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--mysql-druid--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.37&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.10&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.0.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; YML 1234567891011121314151617181920212223242526272829303132server: port: 2001spring: application: name: seata-order-service cloud: alibaba: seata: # 自定义事务组名称需要与seata-server中的对应 tx-service-group: fsp_tx_group nacos: discovery: server-addr: localhost:8848 datasource: # 当前数据源操作类型 type: com.alibaba.druid.pool.DruidDataSource # mysql驱动类 driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://localhost:3306/seata_order username: root password: 6090feign: hystrix: enabled: falselogging: level: io: seata: infomybatis: mapper-locations: classpath:mapper/*.xml file.conf ​ 拷贝 seata-server/conf 目录下的 file.conf 到项目 resources 里面 registry.conf ​ 拷贝 seata-server/conf 目录下的 registry.conf 到项目 resources 里面 domain CommonResult 123456789101112@Data@AllArgsConstructor@NoArgsConstructorpublic class CommonResult&lt;T&gt;&#123; private Integer code; private String message; private T date; public CommonResult(Integer code, String message)&#123; this(code, message,null); &#125;&#125; Order 12345678910111213141516@Data@AllArgsConstructor@NoArgsConstructorpublic class Order &#123; private Long userId; private Long productId; private Integer count; private BigDecimal money; private Integer status; //订单状态： 0 创建中； 1:已完结&#125; Dao 接口及实现 OrderDao 123456789@Mapperpublic interface OrderDao &#123; // 新建订单 void create(Order order); // 修改订单状态，从零开始 void update(@Param(&quot;userId&quot;)Long userId, @Param(&quot;status&quot;) Integer status);&#125; resources 文 件 夹 下 新 建 mapper 文 件 夹 后 添 加 OrderMapper.xml 123456789101112131415161718192021222324252627&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.oy.springcloud.dao.OrderDao&quot;&gt; &lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.oy.springcloud.domain.Order&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot; jdbcType=&quot;BIGINT&quot;&gt;&lt;/id&gt; &lt;result column=&quot;user_id&quot; property=&quot;userId&quot; jdbcType=&quot;BIGINT&quot;/&gt; &lt;result column=&quot;product_id&quot; property=&quot;productId&quot; jdbcType=&quot;BIGINT&quot;/&gt; &lt;result column=&quot;count&quot; property=&quot;count&quot; jdbcType=&quot;INTEGER&quot;/&gt; &lt;result column=&quot;money&quot; property=&quot;money&quot; jdbcType=&quot;DECIMAL&quot;/&gt; &lt;result column=&quot;status&quot; property=&quot;status&quot; jdbcType=&quot;INTEGER&quot;/&gt; &lt;/resultMap&gt; &lt;!-- void create(Order order);--&gt; &lt;insert id=&quot;create&quot;&gt; insert into t_order(id,user_id, product_id, count, money,status) values(null,#&#123;userId&#125;,#&#123;productId&#125;,#&#123;count&#125;,#&#123;money&#125;,0); &lt;/insert&gt; &lt;!-- void update(@Param(&quot;useId&quot;)Long userId, @Param(&quot;status&quot;) Integer status);--&gt; &lt;update id=&quot;update&quot;&gt; update t_order set status = 1 where user_id=#&#123;userId&#125; and status = #&#123;status&#125;; &lt;/update&gt;&lt;/mapper&gt; Service 接口及实现 OrderService 123public interface OrderService &#123; void create(Order order);&#125; OrderServiceImpl 1234567891011121314151617181920212223242526272829303132333435@Service@Slf4jpublic class OrderServiceImpl implements OrderService &#123; @Resource private OrderDao orderDao; @Resource private StorageService storageService; @Resource private AccountService accountService; @Override @GlobalTransactional(name = &quot;fsp-create-order&quot;,rollbackFor = Exception.class) public void create(Order order) &#123; log.info(&quot;-----&gt;开始新建订单&quot;); //新建订单 orderDao.create(order); //扣减库存 log.info(&quot;-----&gt;订单微服务开始调用库存， 做扣减 Count&quot;); storageService.decrease(order.getProductId(),order.getCount()); log.info(&quot;-----&gt;订单微服务开始调用库存， 做扣减 end&quot;); //扣减账户 log.info(&quot;-----&gt;订单微服务开始调用账户， 做扣减 Money&quot;); accountService.decrease(order.getUserId(),order.getMoney()); log.info(&quot;-----&gt;订单微服务开始调用账户， 做扣减 end&quot;); //修改订单状态， 从零到 1 代表已经完成 log.info(&quot;-----&gt;修改订单状态开始&quot;); orderDao.update(order.getUserId(),0); log.info(&quot;-----&gt;修改订单状态结束&quot;); log.info(&quot;-----&gt;下订单结束了&quot;); &#125;&#125; StorageService 123456@FeignClient(value = &quot;seata-storage-service&quot;)public interface StorageService &#123; @PostMapping(value = &quot;/storage/decrease&quot;) CommonResult decrease(@RequestParam(&quot;productId&quot;) Long productId, @RequestParam(&quot;count&quot;) Integer count);&#125; AccountService 123456@FeignClient(value = &quot;seata-account-service&quot;)public interface AccountService &#123; @PostMapping(value = &quot;/account/decrease&quot;) CommonResult decrease(@RequestParam(&quot;userId&quot;) Long userId, @RequestParam(&quot;money&quot;) BigDecimal money);&#125; Controller 12345678910111213@RestControllerpublic class OrderController &#123; @Resource private OrderService orderService; @GetMapping(&quot;/order/create&quot;) public CommonResult create(Order order) &#123; orderService.create(order); return new CommonResult(200,&quot;订单创建成功&quot;); &#125;&#125; Config 配置 MyBatisConfig 12345@Configuration@MapperScan(&#123;&quot;com.oy.springcloud.dao&quot;&#125;)public class MyBatisConfig &#123;&#125; DataSourceProxyConfig 123456789101112131415161718192021222324252627282930313233343536373839404142package com.oy.springcloud.config;import com.alibaba.druid.pool.DruidDataSource;import io.seata.rm.datasource.DataSourceProxy;import org.apache.ibatis.session.SqlSessionFactory;import org.mybatis.spring.SqlSessionFactoryBean;import org.mybatis.spring.transaction.SpringManagedTransactionFactory;import org.springframework.beans.factory.annotation.Value;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.core.io.support.PathMatchingResourcePatternResolver;import javax.sql.DataSource;@Configurationpublic class DataSourceProxyConfig &#123; @Value(&quot;$&#123;mybatis.mapperLocations&#125;&quot;) private String mapperLocations; @Bean @ConfigurationProperties(prefix = &quot;spring.datasource&quot;) public DataSource druidDataSource()&#123; return new DruidDataSource(); &#125; @Bean public DataSourceProxy dataSourceProxy(DataSource dataSource) &#123; return new DataSourceProxy(dataSource); &#125; @Bean public SqlSessionFactory sqlSessionFactoryBean(DataSourceProxy dataSourceProxy) throws Exception &#123; SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean(); sqlSessionFactoryBean.setDataSource(dataSourceProxy); sqlSessionFactoryBean.setMapperLocations(new PathMatchingResourcePatternResolver().getResources(mapperLocations)); sqlSessionFactoryBean.setTransactionFactory(new SpringManagedTransactionFactory()); return sqlSessionFactoryBean.getObject(); &#125;&#125; 主启动 12345678@EnableDiscoveryClient@EnableFeignClients@SpringBootApplication(exclude = DataSourceAutoConfiguration.class) // 取消数据源自动创建的配置public class SeataOrderMainApp2001 &#123; public static void main(String[] args) &#123; SpringApplication.run(SeataOrderMainApp2001.class, args); &#125;&#125; 3.新建库存 Storage-Module **seata-order-service2002 ** POM 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;dependencies&gt; &lt;!--nacos--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--seata--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-seata&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;seata-all&lt;/artifactId&gt; &lt;groupId&gt;io.seata&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.seata&lt;/groupId&gt; &lt;artifactId&gt;seata-all&lt;/artifactId&gt; &lt;version&gt;0.9.0&lt;/version&gt; &lt;/dependency&gt; &lt;!--feign--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.0.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.37&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.10&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt;&lt;/dependencies&gt; YML 1234567891011121314151617181920212223242526server: port: 2002spring: application: name: seata-storage-service cloud: alibaba: seata: tx-service-group: fsp_tx_group nacos: discovery: server-addr: localhost:8848 datasource: driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://localhost:3306/seata_storage username: root password: 123456logging: level: io: seata: infomybatis: mapperLocations: classpath:mapper/*.xml file.conf registry.conf 拷贝 seata-server/conf 目录下的file.conf 、registry.conf 到项目 resources 里面 domain CommonResult 12345678910111213@Data@AllArgsConstructor@NoArgsConstructorpublic class CommonResult&lt;T&gt; &#123; private Integer code; private String message; private T data; public CommonResult(Integer code, String message) &#123; this(code,message,null); &#125;&#125; Storage 1234567891011121314151617@Datapublic class Storage &#123; private Long id; // 产品id private Long productId; // 总库存 private Integer total; // 已用库存 private Integer used; // 剩余库存 private Integer residue;&#125; Dao 接口及实现 StorageDao 12345678@Mapperpublic interface StorageDao &#123; /** * 扣减库存信息 */ void decrease(@Param(&quot;productId&quot;)Long productId, @Param(&quot;count&quot;) Integer count);&#125; resources 文 件 夹 下 新 建 mapper 文 件 夹 后 添 加 StorageMapper.xml 123456789101112131415161718192021&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.oy.springcloud.dao.StorageDao&quot;&gt; &lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.oy.springcloud.domain.Storage&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot; jdbcType=&quot;BIGINT&quot;/&gt; &lt;result column=&quot;product_id&quot; property=&quot;productId&quot; jdbcType=&quot;BIGINT&quot;/&gt; &lt;result column=&quot;total&quot; property=&quot;total&quot; jdbcType=&quot;INTEGER&quot;/&gt; &lt;result column=&quot;used&quot; property=&quot;used&quot; jdbcType=&quot;INTEGER&quot;/&gt; &lt;result column=&quot;residue&quot; property=&quot;residue&quot; jdbcType=&quot;INTEGER&quot;/&gt; &lt;/resultMap&gt; &lt;!--void decrease(@Param(&quot;productId&quot;)Long productId, @Param(&quot;count&quot;) Integer count);--&gt; &lt;update id=&quot;decrease&quot;&gt; UPDATE t_storage SET used = used + #&#123;count&#125;, residue = residue - #&#123;count&#125; WHERE product_id = #&#123;productId&#125; &lt;/update&gt;&lt;/mapper&gt; Service 接口及实现 StorageService 1234567public interface StorageService &#123; /** * 扣减库存 */ void decrease(Long productId, Integer count);&#125; StorageServiceImpl 12345678910111213141516171819@Service@Slf4jpublic class StorageServiceImpl implements StorageService &#123; private static final Logger LOGGER = LoggerFactory.getLogger(StorageServiceImpl.class); @Resource private StorageDao storageDao; /** * 扣减库存 */ @Override public void decrease(Long productId, Integer count) &#123; LOGGER.info(&quot;-------&gt;storage-service 中扣减库存开始&quot;); storageDao.decrease(productId, count); LOGGER.info(&quot;-------&gt;storage-service 中扣减库存结束&quot;); &#125;&#125; Controller 123456789101112131415@RestControllerpublic class StorageController &#123; @Autowired private StorageService storageService; /** * 扣减库存 */ @RequestMapping(&quot;/storage/decrease&quot;) public CommonResult decrease(Long productId, Integer count)&#123; storageService.decrease(productId, count); return new CommonResult(200,&quot;扣减库存成功！ &quot;); &#125;&#125; Config 配置 MyBatisConfig 1234@Configuration@MapperScan(&#123;&quot;com.oy.springcloud.dao&quot;&#125;)public class MyBatisConfig &#123;&#125; DataSourceProxyConfig 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.oy.springcloud.config;import com.alibaba.druid.pool.DruidDataSource;import io.seata.rm.datasource.DataSourceProxy;import org.apache.ibatis.session.SqlSessionFactory;import org.mybatis.spring.SqlSessionFactoryBean;import org.mybatis.spring.transaction.SpringManagedTransactionFactory;import org.springframework.beans.factory.annotation.Value;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.core.io.support.PathMatchingResourcePatternResolver;import javax.sql.DataSource;/** * @Author OY * @Date 2020/11/16 */@Configurationpublic class DataSourceProxyConfig &#123; @Value(&quot;$&#123;mybatis.mapperLocations&#125;&quot;) private String mapperLocations; @Bean @ConfigurationProperties(prefix = &quot;spring.datasource&quot;) public DataSource druidDataSource()&#123; return new DruidDataSource(); &#125; @Bean public DataSourceProxy dataSourceProxy(DataSource dataSource) &#123; return new DataSourceProxy(dataSource); &#125; @Bean public SqlSessionFactory sqlSessionFactoryBean(DataSourceProxy dataSourceProxy) throws Exception &#123; SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean(); sqlSessionFactoryBean.setDataSource(dataSourceProxy); sqlSessionFactoryBean.setMapperLocations(new PathMatchingResourcePatternResolver().getResources(mapperLocations)); sqlSessionFactoryBean.setTransactionFactory(new SpringManagedTransactionFactory()); return sqlSessionFactoryBean.getObject(); &#125;&#125; 主启动 12345678@SpringBootApplication@EnableDiscoveryClient@EnableFeignClientspublic class SeataStorageServiceApplication2002 &#123; public static void main(String[] args) &#123; SpringApplication.run(SeataStorageServiceApplication2002.class, args); &#125;&#125; 4.新建账户 Account-Module seata-account-service2003 POM 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859 &lt;dependencies&gt; &lt;!--nacos--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--seata--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-seata&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;seata-all&lt;/artifactId&gt; &lt;groupId&gt;io.seata&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.seata&lt;/groupId&gt; &lt;artifactId&gt;seata-all&lt;/artifactId&gt; &lt;version&gt;0.9.0&lt;/version&gt; &lt;/dependency&gt; &lt;!--feign--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.0.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.37&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.10&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; YML 123456789101112131415161718192021222324252627282930server: port: 2003spring: application: name: seata-account-service cloud: alibaba: seata: tx-service-group: fsp_tx_group nacos: discovery: server-addr: localhost:8848 datasource: driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://localhost:3306/seata_account username: root password: 6090feign: hystrix: enabled: falselogging: level: io: seata: infomybatis: mapperLocations: classpath:mapper/*.xml file.conf registry.conf domain CommonResult 12345678910111213@Data@AllArgsConstructor@NoArgsConstructorpublic class CommonResult&lt;T&gt; &#123; private Integer code; private String message; private T data; public CommonResult(Integer code, String message) &#123; this(code,message,null); &#125;&#125; Account 12345678910111213141516171819202122@Data@AllArgsConstructor@NoArgsConstructorpublic class Account &#123; private Long id; /** * 用户 id */ private Long userId; /** * 总额度 */ private BigDecimal total; /** * 已用额度 */ private BigDecimal used; /** * 剩余额度 */ private BigDecimal residue;&#125; Dao 接口及实现 AccountDao 1234567@Mapperpublic interface AccountDao &#123; /** * 扣减账户余额 */ void decrease(@Param(&quot;userId&quot;) Long userId, @Param(&quot;money&quot;) BigDecimal money);&#125; resources 文 件 夹 下 新 建 mapper 文 件 夹 后 添 加 AccountMapper.xml 12345678910111213141516171819&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.oy.springcloud.dao.AccountDao&quot;&gt; &lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.oy.springcloud.domain.Account&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot; jdbcType=&quot;BIGINT&quot;/&gt; &lt;result column=&quot;user_id&quot; property=&quot;userId&quot; jdbcType=&quot;BIGINT&quot;/&gt; &lt;result column=&quot;total&quot; property=&quot;total&quot; jdbcType=&quot;DECIMAL&quot;/&gt; &lt;result column=&quot;used&quot; property=&quot;used&quot; jdbcType=&quot;DECIMAL&quot;/&gt; &lt;result column=&quot;residue&quot; property=&quot;residue&quot; jdbcType=&quot;DECIMAL&quot;/&gt; &lt;/resultMap&gt; &lt;update id=&quot;decrease&quot;&gt; UPDATE t_account SET residue = residue - #&#123;money&#125;,used = used + #&#123;money&#125; WHERE user_id = #&#123;userId&#125;; &lt;/update&gt;&lt;/mapper&gt; Service 接口及实现 AccountService 123456public interface AccountService &#123; /** * 扣减账户余额 */ void decrease(@RequestParam(&quot;userId&quot;) Long userId, @RequestParam(&quot;money&quot;) BigDecimal money);&#125; AccountServiceImpl 1234567891011121314public class AccountServiceImpl implements AccountService &#123; private static final Logger LOGGER = LoggerFactory.getLogger(AccountServiceImpl.class); @Resource AccountDao accountDao; @Override public void decrease(Long userId, BigDecimal money) &#123; LOGGER.info(&quot;-------&gt;account-service 中扣减账户余额开始&quot;); try &#123; TimeUnit.SECONDS.sleep(20); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; accountDao.decrease(userId,money); LOGGER.info(&quot;-------&gt;account-service 中扣减账户余额结束&quot;); &#125;&#125; Controller 12345678910111213@RestControllerpublic class AccountController &#123; @Resource AccountService accountService; /** * 扣减账户余额 */ @RequestMapping(&quot;/account/decrease&quot;) public CommonResult decrease(@RequestParam(&quot;userId&quot;) Long userId, @RequestParam(&quot;money&quot;) BigDecimal money)&#123; accountService.decrease(userId,money);return new CommonResult(200,&quot;扣减账户余额成功！ &quot;); &#125;&#125; Config 配置 MyBatisConfig 12345@Configuration@MapperScan(&#123;&quot;com.oy.springcloud.dao.AccountDao&quot;&#125;)public class MyBatisConfig &#123;&#125; DataSourceProxyConfig 123456789101112131415161718192021222324252627282930313233343536373839404142package com.oy.springcloud.config;import com.alibaba.druid.pool.DruidDataSource;import io.seata.rm.datasource.DataSourceProxy;import org.apache.ibatis.session.SqlSessionFactory;import org.mybatis.spring.SqlSessionFactoryBean;import org.mybatis.spring.transaction.SpringManagedTransactionFactory;import org.springframework.beans.factory.annotation.Value;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.core.io.support.PathMatchingResourcePatternResolver;import javax.sql.DataSource;@Configurationpublic class DataSourceProxyConfig &#123; @Value(&quot;$&#123;mybatis.mapperLocations&#125;&quot;) private String mapperLocations; @Bean @ConfigurationProperties(prefix = &quot;spring.datasource&quot;) public DataSource druidDataSource()&#123; return new DruidDataSource(); &#125; @Bean public DataSourceProxy dataSourceProxy(DataSource dataSource) &#123; return new DataSourceProxy(dataSource); &#125; @Bean public SqlSessionFactory sqlSessionFactoryBean(DataSourceProxy dataSourceProxy) throws Exception &#123; SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean(); sqlSessionFactoryBean.setDataSource(dataSourceProxy); sqlSessionFactoryBean.setMapperLocations(new PathMatchingResourcePatternResolver().getResources(mapperLocations)); sqlSessionFactoryBean.setTransactionFactory(new SpringManagedTransactionFactory()); return sqlSessionFactoryBean.getObject(); &#125;&#125; 主启动 123456789@SpringBootApplication(exclude = DataSourceAutoConfiguration.class)@EnableDiscoveryClient@EnableFeignClientspublic class SeataAccountMainApp2003 &#123; public static void main(String[] args) &#123; SpringApplication.run(SeataAccountMainApp2003.class, args); &#125;&#125; 注意：如果报错 A component required a bean of type &#39;com.oy.springcloud.dao.AccountDao&#39; that could not be found. 请在启动类上加： 六、Test① 下订单-&gt;减库存-&gt;扣余额-&gt;改（订单） 状态 我们只需要使用一个 @GlobalTransactional 注解在业务方法上； ② 数据库初始化情况 ③ 正常下单 http://localhost:2001/order/create?userId=1&amp;producId=1&amp;count=10&amp;money=100 数据库情况 ④ 超时异常， 没加@GlobalTransactional AccountServiceImpl 添加超时 数据库情况 余额和库存都已经扣除，但是订单状态还是未支付，结果就是，这个订单仍要再次支付 故障情况 当库存和账户余额扣减后， 订单状态并没有设置为已经完成，没有从零改为 1 而且由于 feign 的重试机制， 账户余额还有可能被多次扣减 ⑤ 超时异常， 添加@GlobalTransactional AccountServiceImpl 添加超时 OrderServiceImpl @GlobalTransactional 下单后数据库数据并没有任何改变， 记录都添加不进来 七、Seata 之原理简介① Seata​ 2019 年 1 月份蚂蚁金服和阿里巴巴共同开源的分布式事务解决方案 Simple Extensible Autonomous Transaction Architecture,简单可扩展自治事务框架 2020 起初， 参加工作后用 1.0 以后的版本 ② 再看 TC/TM/RM 三大组件分布式事务的执行流程 TM 开启分布式事务(TM 向 TC 注册全局事务记录) 换业务场景， 编排数据库， 服务等事务内资源（RM 报资源准备状态） TM 结束分布式事务， 事务一阶段结束（TM 通知 TC 滚分布式事务） TC 汇总事务信息， 决定分布式事务是提交还是回滚 TC 通知所有 RM 提交/回滚资源， 事务二阶段结束 ③ AT 模式如何做到对业务的无侵入 一阶段加载 二阶段提交 二阶段回滚 ④ 补充","categories":[{"name":"JavaEE框架","slug":"JavaEE框架","permalink":"http://blog.oy6090.top/categories/JavaEE%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"java","slug":"java","permalink":"http://blog.oy6090.top/tags/java/"},{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://blog.oy6090.top/tags/SpringCloud/"}]},{"title":"SpringCloud Alibaba Sentinel实现熔断与限流","slug":"SpringCloud Alibaba Sentinel实现熔断与限流","date":"2020-11-12T16:00:00.000Z","updated":"2021-01-20T14:49:25.374Z","comments":true,"path":"posts/13005592.html","link":"","permalink":"http://blog.oy6090.top/posts/13005592.html","excerpt":"","text":"博客参考学习视频 SpringCloud Alibaba Sentinel 实现熔断与限流一、Sentinel① 官网 英文： https://github.com/alibaba/Sentinel 中文：https://github.com/alibaba/Sentinel/wiki/%E4%BB%8B%E7%BB%8D ② 是什么 一句话解释， 之前我们讲解过的 Hystrix ③ 去哪下​ https://github.com/alibaba/Sentinel/releases ④ 能干嘛 ⑤ 怎么玩https://spring-cloud-alibaba-group.github.io/github-pages/greenwich/spring-cloud-alibaba.html#_spring_cloud_alibaba_sentinel%E6%9C%8D%E5%8A%A1%E4%BD%BF%E7%94%A8%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E9%97%AE 服务使用中的各种问题 服务雪崩 服务降级 服务熔断 服务限流 二、安装 Sentinel 控制台① sentinel 组件由 2 部分组成 后台 前台 8080 ② 安装步骤下载： https://github.com/alibaba/Sentinel/releases 下载到本地 sentinel-dashboard-1.8.0.jar 运行命令 前提： java8 环境 OK 8080 端口不能被占用 命令： java -jar sentinel-dashboard-1.8.0.jar 访问 sentinel 管理界面 http://localhost:8080 登录账号密码均为 sentinel 三、初始化演示工程① 启动 Nacos8848 成功 http://localhost:8848/nacos/#/login ② Module 建 Module cloudalibaba-sentinel-service8401 POM 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;dependencies&gt; &lt;dependency&gt;&lt;!-- 引入自己定义的api通用包，可以使用Payment支付Entity --&gt; &lt;groupId&gt;com.atguigu.springcloud&lt;/groupId&gt; &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt; &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--SpringCloud ailibaba nacos --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--SpringCloud ailibaba sentinel-datasource-nacos 后续做持久化用到--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.csp&lt;/groupId&gt; &lt;artifactId&gt;sentinel-datasource-nacos&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--SpringCloud ailibaba sentinel --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-sentinel&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--openfeign--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- SpringBoot整合Web组件+actuator --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--日常通用jar包配置--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;cn.hutool&lt;/groupId&gt; &lt;artifactId&gt;hutool-all&lt;/artifactId&gt; &lt;version&gt;4.6.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; YML 1234567891011121314151617181920212223242526272829303132server: port: 8401spring: application: name: cloudalibaba-sentinel-service cloud: nacos: discovery: server-addr: localhost:8848 #Nacos服务注册中心地址 sentinel: transport: dashboard: localhost:8080 #配置Sentinel dashboard地址 port: 8719 datasource: ds1: nacos: server-addr: localhost:8848 dataId: cloudalibaba-sentinel-service groupId: DEFAULT_GROUP data-type: json rule-type: flowmanagement: endpoints: web: exposure: include: &quot;*&quot;feign: sentinel: enabled: true # 激活Sentinel对Feign的支持 主启动 1234567@EnableDiscoveryClient@SpringBootApplicationpublic class MainApp8401 &#123; public static void main(String[] args) &#123; SpringApplication.run(MainApp8401.class, args); &#125;&#125; 业务类 FlowLimitController 12345678910111213@RestControllerpublic class FlowLimitController &#123; @GetMapping(&quot;/testA&quot;) public String testA()&#123; return &quot;-----testA&quot;; &#125; @GetMapping(&quot;/testB&quot;) public String testB()&#123; return &quot;----testB&quot;; &#125;&#125; ③ 启动 Sentinel80801java -jar sentinel-dashboard-1.8.0 ④ 启动微服务 8401⑤ 启动 8401 微服务后查看 sentienl 控制台 空空如也， 啥都没有 ==Sentinel 采用的懒加载说明== 执行一次访问即可 结论 sentinel8080 正在监控微服务 8401 四、流控规则① 基本介绍 ② 流控模式 直接（默认） 直接-&gt;快速失败， 系统默认 配置及说明 测试 快速点击访问 http://localhost:8401/testA 结果 思考： 直接调用默认报错信息， 技术方面 OK but， 是否应该有我们自己的后续处理？类似有一个 fallback 的兜底方法？ 关联 是什么？ 当关联的资源达到阈值时， 就限流自己,当与 A 关联的资源 B 达到阈值后， 就限流自己 B 惹事， A 挂了 。 配置 A postman 模拟并发密集访问 testB 访问 testB 成功 postman 里新建多线程集合组 将访问地址添加进新线程组Run： 大批量线程高并发访问 B， 导致 A 失效了 运行后发现 testA 挂了 点击访问 http://localhost:8401/testA 结果： Blocked by Sentinel (flow limiting) 链路 链路模式针对的是上级接口，粒度控制的更细。 这个模式需要配合@SentinelResource 注解使用，在资源上添加 @SentinelResource 注解，表示这是一个资源，同时给出资源名。 新增 TestService 接口类： 123public interface TestService &#123; void message();&#125; 新增 TestServiceImpl 类，该类的 message()方法上加上@SentinelResource(“message”)注解，表示资源名为 messge： 12345678910111213import com.alibaba.csp.sentinel.annotation.SentinelResource;import com.example.mallorder.service.TestService;import org.springframework.stereotype.Service;@Servicepublic class TestServiceImpl implements TestService &#123; @Override @SentinelResource(&quot;message&quot;) public void message() &#123; System.out.println(&quot;message&quot;); &#125;&#125; 修改 TestController 类，让两个测试方法都调用 TestService 提供的方法： 12345678910111213141516171819202122package com.oy.springcloud.config;import com.alibaba.csp.sentinel.adapter.servlet.CommonFilter;import org.springframework.boot.web.servlet.FilterRegistrationBean;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configurationpublic class FilterContextConfig &#123; @Bean public FilterRegistrationBean sentinelFilterRegistration() &#123; FilterRegistrationBean registration = new FilterRegistrationBean(); registration.setFilter(new CommonFilter()); registration.addUrlPatterns(&quot;/*&quot;); // 入口资源关闭聚合 registration.addInitParameter(CommonFilter.WEB_CONTEXT_UNIFY, &quot;false&quot;); registration.setName(&quot;sentinelFilter&quot;); registration.setOrder(1); return registration; &#125;&#125; 此时的路口资源就是 /testA /testB 当入口资源达到阈值的时候，就会启动此资源名为 message 的对应路口资源的流控。 ==坑来了，怎么解决？== 禁止收敛 URL 的入口 context 从 1.6.3 版本开始，Sentinel Web filter 默认收敛所有 URL 的入口 context，因此链路限流不生效。 1.7.0 版本开始（对应 SCA 的 2.1.1.RELEASE)，官方在 CommonFilter 引入了 WEB_CONTEXT_UNIFY 参数，用于控制是否收敛 context。将其配置为 false 即可根据不同的 URL 进行链路限流。 SCA 2.1.1.RELEASE 之后的版本,可以通过配置 spring.cloud.sentinel.web-context-unify=false 即可关闭收敛，我们当前使用的版本是 SpringCloud Alibaba 2.1.0.RELEASE，无法实现链路限流。 目前官方还未发布 SCA 2.1.2.RELEASE，所以我们只能使用 2.1.1.RELEASE，需要写代码的形式实现。 暂时将 SpringCloud Alibaba 的版本调整为 2.1.1.RELEASE 配置文件中关闭 sentinel 的 CommonFilter 实例化 添加一个配置类，自己构建 CommonFilter 实例 12345678910111213141516171819202122package com.oy.springcloud.config;import com.alibaba.csp.sentinel.adapter.servlet.CommonFilter;import org.springframework.boot.web.servlet.FilterRegistrationBean;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configurationpublic class FilterContextConfig &#123; @Bean public FilterRegistrationBean sentinelFilterRegistration() &#123; FilterRegistrationBean registration = new FilterRegistrationBean(); registration.setFilter(new CommonFilter()); registration.addUrlPatterns(&quot;/*&quot;); // 入口资源关闭聚合 registration.addInitParameter(CommonFilter.WEB_CONTEXT_UNIFY, &quot;false&quot;); registration.setName(&quot;sentinelFilter&quot;); registration.setOrder(1); return registration; &#125;&#125; 分别通过两个路口资源进行访问，发现设置的入口资源被限流了。 ③ 流控效果直接-&gt;快速失败（默认的流控处理） ： 直接失败， 抛出异常 1Blocked by Sentinel (flow limiting) 源码 1com.alibaba.csp.sentinel.slots.block.flow.controller.DefaultController 预热： 说明 公式： 阈值除以 coldFactor（默认值为 3） ， 经过预热时长后才会达到阈值 官网 默认 coldFactor 为 33. 默认 coldFactor 为 3， 即请求 QPS 从 threshold/3 开始， 经预热时长逐渐升至设定的 QPS 阈值。 限流冷启动 ： https://github.com/alibaba/Sentinel/wiki/%E9%99%90%E6%B5%81---%E5%86%B7%E5%90%AF%E5%8A%A8 源码 Warmup 配置 多次点击 http://localhost:8401/testB 刚开始不行， 后续慢慢 OK 应用场景 如秒杀系统在开启的瞬间会有很多流量上来， 很有可能把系统打死， 预热方式就是为了保护系统， 可慢慢的把流量放进来， 慢慢的把阈值增长到设置的阈值 排队等待： 匀速排队， 阈值必须设置为 QPS 官网 源码 com.alibaba.csp.sentinel.slots.block.flow.controller.RateLimiterController 测试 五、降级规则① 基本介绍 进一步说明 ​ Sentinel 熔断降级会在调用链路中某个出现稳定的资源不稳定状态时（例如调用超时或异常比例高），对这个资源的调用进行限制，让请求快速失败，避免影响到其他的资源而导致级联错误。 ​ 当资源被降级后，在接下来的降级时间窗口之内，对该资源的调用都自动熔断（默认行为是抛出 DegradeException）。 Sentinel 的断路器是没有半开状态的 ​ 半开的状态系统自动去检测是否请求有异常， 没有异常就关闭断路器恢复使用， 有异常则继续打开断路器不可用。 具体可以参考 Hystrix 复习 Hystrix ​ ② 降级策略实战 RT 是什么 测试 代码 1234567891011@GetMappingpublic String testD()&#123; try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; log.info(&quot;TestD 测试 RT&quot;); return &quot;-----testD&quot;;&#125; 配置 注意：我这里更换了版本，有些配置选项不一样了。版本是 1.7 jmeter 压测 结论： ​ 按照一秒钟打进来 10 个线程（大于 5 个了）调用 testD ,我们希望 200 毫秒处理本次任务，如果超过 200 毫秒还没处理完，在未来 1 秒钟的时间窗口内，断路器打开（保险丝跳闸）微服务不可用，保险丝跳闸断电了，后续我停止 jmeter， 没有这么大的访问量，断路器关闭（保险丝恢复），微服务恢复 OK。 异常比例 1. 是什么 2. 测试 代码 1234567@GetMapping(&quot;/testE&quot;)public String testE()&#123; log.info(&quot;testE 异常比例&quot;); int age = 10/0; return &quot;------testE&quot;;&#125; 配置 Jmeter 结论： ​ 按照上述配置，单独访问一次，必须来一次报错一次（int age = 10/0）,调用一次错一次； 开启 jmeter 后， 直接高并发发送请求，多次调用达到我们的配置条件了。断路器开启（保险丝跳闸），微服务不可用了，不在报错 error 而是服务降级了。 异常数 是什么 异常数是按照分钟统计的 测试 123456@GetMapping(&quot;/testF&quot;)public String testF()&#123; log.info(&quot;testF 测试异常数&quot;); int age = 10/0; return &quot;------testF 测试异常数&quot;;&#125; 配置 ​ http://localhost:8041/testF, 第一次访问决定报错，因为除数不能为零，我们看到 error 窗口，但是达到 5 次报错后，进入熔断后降级。 六、热点 key 限流① 基本介绍 是什么： ② 官网https://github.com/alibaba/Sentinel/wiki/ 热点参数限流 ③ 承上启下复习 start兜底方法： 分为系统默认和客户自定义，两种之前的 Case, 限流出问题，都是 sentinel 系统默认的提示： Blocked by sentinel （flow limiting）我们能不能自定？ 类似 hystrix， 某个方法出问题了，就找对应的兜底降级方法？ 结论： 从 ==HystrixCommand== 到 ==@SentinelResource== ④ 代码123456789101112131415 /** * 热点 key 限流 */@GetMapping(&quot;/testHotKey&quot;)@SentinelResource(value = &quot;testHotKey&quot;, blockHandler = &quot;deal_testHotKey&quot;)public String testHotKey(@RequestParam(value = &quot;p1&quot;, required = false) String p1, @RequestParam(value = &quot;p2&quot;, required = false) String p2)&#123; return &quot;----testHotKey&quot;;&#125; /** * 兜底方法 */public String deal_testHotKey(String p1, String p2, BlockException exception)&#123; return &quot;-----deal_testHotKey,o(╥﹏╥)o&quot;;&#125; com.alibaba.csp.sentinel.slots.block.BlockException ⑤ 配置​ @SentinelResource(value = “testHotKey”), 异常打到了前台用户界面看不到，不友好 ​ @SentinelResource(value = “testHotKey “, blockHandler = “deal_testHotKey”), 方法 testHostKey 里面的一个参数只要 QPS 超过每秒 1 次，马上降级处理。用了我们自己定义的 blockHandler 。 ⑥ 测试 Error： http://localhost:8401/testHotKey?p1=abc Error： http://localhost:8401/testHotKey?p1=abc&amp;p2=33 Right： http://localhost:8401/testHotKey?p2=abc ⑦ 参数例外项上述案例演示了第一个参数 p1,当 QPS 超过 1 秒 1 次点击后马上被限流 普通 超过 1 秒钟一个后， 达到阈值 1 后马上被限流 我们期望 p1 参数当它是某个特殊值时， 它的限流值和平时不一样 特例 假如当 p1 的值等于 5 时， 它的阈值可以达到 200 配置 测试 1. http://localhost:8401/testHotKey?p1=5 √ http://localhost:8401/testHotKey?p1=3 × 当 p1 等于 5 的时候， 阈值变为 200 当 p1 不等于 5 的时候， 阈值就是平常的 1 前提条件 热点参数的注意点， 参数必须是基本类型或者 String ⑧ 其他==@SentinelResource== ​ 处理的是 Sentinel 控制台配置的违规情况，有 blockHandler 方法配置的兜底处理 ==RuntimeException== ​ int age = 10/ 0, 这个是 java 运行时报出的运行时异常 RuntimeException, @SentinelException, @SentineResource 不管 ==总结== @SentineIResource 主管配置出错，运行出错该走异常走异常 七、系统规则① 是什么https://github.com/alibaba/Sentinel/wiki/%E7%B3%BB%E7%BB%9F%E8%87%AA%E9%80%82%E5%BA%94%E9%99%90%E6%B5%81 ② 各项配置参数说明系统保护规则是从应用级别的入口流量进行控制，从单台机器的 load、CPU 使用率、平均 RT、入口 QPS 和并发线程数等几个维度监控应用指标，让系统尽可能跑在最大吞吐量的同时保证系统整体的稳定性。 系统保护规则是应用整体维度的，而不是资源维度的，并且仅对入口流量生效。入口流量指的是进入应用的流量（EntryType.IN），比如 Web 服务或 Dubbo 服务端接收的请求，都属于入口流量。 系统规则支持以下的模式： Load 自适应（仅对 Linux/Unix-like 机器生效）：系统的 load1 作为启发指标，进行自适应系统保护。当系统 load1 超过设定的启发值，且系统当前的并发线程数超过估算的系统容量时才会触发系统保护（BBR 阶段）。系统容量由系统的 maxQps * minRt 估算得出。设定参考值一般是 CPU cores * 2.5。 CPU usage（1.5.0+ 版本）：当系统 CPU 使用率超过阈值即触发系统保护（取值范围 0.0-1.0），比较灵敏。 平均 RT：当单台机器上所有入口流量的平均 RT 达到阈值即触发系统保护，单位是毫秒。 并发线程数：当单台机器上所有入口流量的并发线程数达到阈值即触发系统保护。 入口 QPS：当单台机器上所有入口流量的 QPS 达到阈值即触发系统保护。 ③ 配置全局 QPS 八、@SentinelResource① 按资源名称限流+后续处理 启动 Nacos 成功 启动 Sentinel 成功 Module ​ cloudalibaba-sentinel-service8401 POM 12345&lt;dependency&gt; &lt;groupId&gt;com.atguigu.springcloud&lt;/groupId&gt; &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt; &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt;&lt;/dependency&gt; YML 1234567891011121314151617181920server: port: 8401spring: application: name: cloudalibaba-sentinel-service cloud: nacos: discovery: server-addr: localhost:8848 #Nacos服务注册中心地址 sentinel: transport: dashboard: localhost:8080 #配置Sentinel dashboard地址 port: 8719 #默认 8719， 假如被占用了会自动从 8719 开始依次+1 扫描。 直至找到未被占用的端口management: endpoints: web: exposure: include: &quot;*&quot; 业务类 RateLimitController 12345678910111213@RestControllerpublic class RateLimitController &#123; @GetMapping(&quot;/byResource&quot;) @SentinelResource(value = &quot;byResource&quot;,blockHandler = &quot;handleException&quot;) public CommonResult byResource()&#123; return new CommonResult(200,&quot; 按 资 源 名 称 限 流 测 试 OK&quot;,new Payment(2020L,&quot;serial001&quot;)); &#125; public CommonResult handleException(BlockException exception)&#123; return new CommonResult(444,&quot;exception.getClass().getCanonicalName()+\\&quot;t 服务\\n&quot; + &quot;不可用&quot;); &#125;&#125; 主启动 1234567@EnableDiscoveryClient@SpringBootApplicationpublic class MainApp8401 &#123; public static void main(String[] args) &#123; SpringApplication.run(MainApp8401.class, args); &#125;&#125; 配置流控规则 配置步骤 图形配置和代码关系 表示 1 秒钟内查询次数大于 1， 就跑到我们自定义的处流， 限流 。 测试 1 秒钟点击 1 下， OK 超过上述问题， 疯狂点击， 返回了自己定义的限流处理信息. 限流发送 ② 按照 Url 地址限流+后续处理 通过访问的 URL 来限流， 会返回 Sentinel 自带默认的限流处理信息 。 业务类 RateLimitController 1234@GetMapping(value = &quot;byUrl&quot;)public CommonResult byUrl()&#123; return new CommonResult(200,&quot;按 url 限流测试 OK&quot;,new Payment(2020L,&quot;serial002&quot;));&#125; 访问一次 Sentinel 控制台配置 测试 疯狂点击 http://localhost:8401/rateLimit/byUrl 结果 会返回 Sentinel 自带的限流处理限流结果 ③ 上面兜底方法面临的问题 系统默认的，没有体现我们自己的业务要求。 依照现有的条件，我们自定义的处理方法又和业务代码块耦合在一块，不直观。 每个业务方法都添加一个兜底的，那代码膨胀加剧。 全局统一的处理方法没有体现。 ④ 客户自定义限流处理逻辑 创建 customerBlockHandler 类用于自定义限流处理逻辑,自定义限流处理类 CustomerBlockHandler 12345678910public class CustomerBlockHandler &#123; public static CommonResult handleException(BlockedException exception)&#123; return new CommonResult(2020, &quot;自定义限流处理信息....CustomerBlockHandler&quot;); &#125; public static CommonResult handleException2(BlockedException exception)&#123; return new CommonResult(2020, &quot;自定义限流处理信息2....CustomerBlockHandler--2&quot;); &#125;&#125; RateLimitController 12345678910111213import com.oy.springcloud.entities.CommonResult;import com.alibaba.csp.sentinel.slots.block.BlockException;public class CustomerBlockHandler &#123; public static CommonResult handleException(BlockException exception)&#123; return new CommonResult(2020, &quot;自定义限流处理信息....CustomerBlockHandler&quot;); &#125; public static CommonResult handleException2(BlockException exception)&#123; return new CommonResult(2020, &quot;自定义限流处理信息2....CustomerBlockHandler--2&quot;); &#125;&#125; 启动微服务后先调用一次 http://localhost:8401/rateLimit/customerBlockHandler Sentinel 控制台配置 测试后我们自定义的出来了 进一步说明 ⑤ 更多注解属性说明 @SentinelResource 用于定义资源，并提供可选的异常处理和 fallback 配置项。 @SentinelResource 注解包含以下属性： value：资源名称，必需项（不能为空） entryType：entry 类型，可选项（默认为 EntryType.OUT） blockHandler / blockHandlerClass: blockHandler 对应处理 BlockException 的函数名称，可选项。blockHandler 函数访问范围需要是 public，返回类型需要与原方法相匹配，参数类型需要和原方法相匹配并且最后加一个额外的参数，类型为 BlockException。blockHandler 函数默认需要和原方法在同一个类中。若希望使用其他类的函数，则可以指定 blockHandlerClass 为对应的类的 Class 对象，注意对应的函数必需为 static 函数，否则无法解析。 fallback / fallbackClass：fallback 函数名称，可选项，用于在抛出异常的时候提供 fallback 处理逻辑。fallback 函数可以针对所有类型的异常（除了 exceptionsToIgnore 里面排除掉的异常类型）进行处理。fallback 函数签名和位置要求： 返回值类型必须与原函数返回值类型一致； 方法参数列表需要和原函数一致，或者可以额外多一个 Throwable 类型的参数用于接收对应的异常。 fallback 函数默认需要和原方法在同一个类中。若希望使用其他类的函数，则可以指定 fallbackClass 为对应的类的 Class 对象，注意对应的函数必需为 static 函数，否则无法解析。 defaultFallback（since 1.6.0）：默认的 fallback 函数名称，可选项，通常用于通用的 fallback 逻辑（即可以用于很多服务或方法）。默认 fallback 函数可以针对所有类型的异常（除了 exceptionsToIgnore 里面排除掉的异常类型）进行处理。若同时配置了 fallback 和 defaultFallback，则只有 fallback 会生效。defaultFallback 函数签名要求： 返回值类型必须与原函数返回值类型一致； 方法参数列表需要为空，或者可以额外多一个 Throwable 类型的参数用于接收对应的异常。 defaultFallback 函数默认需要和原方法在同一个类中。若希望使用其他类的函数，则可以指定 fallbackClass 为对应的类的 Class 对象，注意对应的函数必需为 static 函数，否则无法解析。 exceptionsToIgnore（since 1.6.0）：用于指定哪些异常被排除掉，不会计入异常统计中，也不会进入 fallback 逻辑中，而是会原样抛出。 注：1.6.0 之前的版本 fallback 函数只针对降级异常（DegradeException）进行处理，不能针对业务异常进行处理。 特别地，若 blockHandler 和 fallback 都进行了配置，则被限流降级而抛出 BlockException 时只会进入 blockHandler 处理逻辑。若未配置 blockHandler、fallback 和 defaultFallback，则被限流降级时会将 BlockException 直接抛出（若方法本身未定义 throws BlockException 则会被 JVM 包装一层 UndeclaredThrowableException）。 官网：https://github.com/alibaba/Sentinel/wiki/%E6%B3%A8%E8%A7%A3%E6%94%AF%E6%8C%81 多说一句 Sentinel 主要有三个核心 API SphU 定义资源 Tracer 定义统计 ContextUtil 定义了上下文 九、服务熔断功能① sentinel 整合 ribbon+openFeign+fallback② Ribbon 系列1. 启动 nacos 和 sentinel,提供者 9003/9004 新建 cloudalibaba-provider-payment9003/9004 POM 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;clould&lt;/artifactId&gt; &lt;groupId&gt;com.oy&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;cloudalibaba-provider-payment9003&lt;/artifactId&gt; &lt;dependencies&gt; &lt;!--SpringCloud openfeign --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--SpringCloud ailibaba nacos --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--SpringCloud ailibaba sentinel --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-sentinel&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 引入自己定义的api通用包，可以使用Payment支付Entity --&gt; &lt;dependency&gt; &lt;groupId&gt;com.oy&lt;/groupId&gt; &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;!-- SpringBoot整合Web组件 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--日常通用jar包配置--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; YML： 记得修改不同的端口号 12345678910111213141516server: port: 9003spring: application: name: nacos-payment-provider cloud: nacos: discovery: server-addr: localhost:8848 #配置Nacos地址management: endpoints: web: exposure: include: &quot;*&quot; 主启动 1234567@SpringBootApplication@EnableDiscoveryClientpublic class PaymentMain9003 &#123; public static void main(String[] args) &#123; SpringApplication.run(PaymentMain9003.class, args); &#125;&#125; 业务类 123456789101112131415161718192021@RestControllerpublic class PaymentController &#123; @Value(&quot;$&#123;server.port&#125;&quot;) private String serverPort; public static HashMap&lt;Long, Payment&gt; hashMap = new HashMap&lt;&gt;(); static&#123; hashMap.put(1L,new Payment(1L,&quot;28a8c1e3bc2742d8848569891fb42181&quot;)); hashMap.put(2L,new Payment(2L,&quot;bba8c1e3bc2742d8848569891ac32182&quot;)); hashMap.put(3L,new Payment(3L,&quot;6ua8c1e3bc2742d8848569891xt92183&quot;)); &#125; @GetMapping(value = &quot;/paymentSQL/&#123;id&#125;&quot;) public CommonResult&lt;Payment&gt; paymentSQL(@PathVariable(&quot;id&quot;) Long id)&#123; Payment payment = hashMap.get(id); CommonResult&lt;Payment&gt; result = new CommonResult(200,&quot;frommysql,serverPort: &quot;+serverPort,payment); return result; &#125;&#125; 测试 地址： http://localhost:9003/paymentSQL/1 2.消费者 84 新建 cloudalibaba-consumer-nacos-order84 POM 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;dependencies&gt; &lt;!--SpringCloud openfeign --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--SpringCloud ailibaba nacos --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--SpringCloud ailibaba sentinel --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-sentinel&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 引入自己定义的api通用包，可以使用Payment支付Entity --&gt; &lt;dependency&gt; &lt;groupId&gt;com.atguigu.springcloud&lt;/groupId&gt; &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt; &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- SpringBoot整合Web组件 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--日常通用jar包配置--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; YML 12345678910111213141516171819202122232425server: port: 84spring: application: name: nacos-order-consumer cloud: nacos: discovery: server-addr: localhost:8848 sentinel: transport: #配置Sentinel dashboard地址 dashboard: localhost:8080 #默认8719端口，假如被占用会自动从8719开始依次+1扫描,直至找到未被占用的端口 port: 8719#消费者将要去访问的微服务名称(注册成功进nacos的微服务提供者)service-url: nacos-user-service: http://nacos-payment-provider# 激活Sentinel对Feign的支持feign: sentinel: enabled: true 主启动 12345678@EnableDiscoveryClient@SpringBootApplication@EnableFeignClientspublic class OrderNacosMain84 &#123; public static void main(String[] args) &#123; SpringApplication.run(OrderNacosMain84.class, args); &#125;&#125; 业务类 ApplicationContextConfig 123456789@Configurationpublic class ApplicationContextConfig &#123; @Bean @LoadBalanced public RestTemplate getRestTemplate()&#123; return new RestTemplate(); &#125;&#125; CircleBreakerController 的全部源码 123456789101112131415161718192021222324252627282930313233343536@RestController@Slf4jpublic class CircleBreakerController &#123; public static final String SERVICE_URL = &quot;http://nacos-payment-provider&quot;; @Resource private RestTemplate restTemplate; @RequestMapping(&quot;/consumer/fallback/&#123;id&#125;&quot;) //@SentinelResource(value = &quot;fallback&quot;) //没有配置 //@SentinelResource(value = &quot;fallback&quot;,fallback = &quot;handlerFallback&quot;) //fallback 只负责业务异常 //@SentinelResource(value = &quot;fallback&quot;,blockHandler = &quot;blockHandler&quot;) //blockHandler只负责 sentinel 控制台配置违规 //@SentinelResource(value = &quot;fallback&quot;,fallback = &quot;handlerFallback&quot;,blockHandler = &quot;blockHandler&quot;, exceptionsToIgnore = &#123;IllegalArgumentException.class&#125;) public CommonResult&lt;Payment&gt; fallback(@PathVariable Long id) &#123; CommonResult&lt;Payment&gt; result = restTemplate.getForObject(SERVICE_URL +&quot;/paymentSQL/&quot;+id, CommonResult.class,id); if (id == 4) &#123; throw new IllegalArgumentException (&quot;IllegalArgumentException,非法参数异常....&quot;); &#125;else if (result.getData() == null) &#123; throw new NullPointerException (&quot;NullPointerException,该 ID 没有对应记录,空指针异常&quot;); &#125; return result; &#125; //fallback public CommonResult handlerFallback(@PathVariable Long id,Throwable e) &#123; Payment payment = new Payment(id,&quot;null&quot;); return new CommonResult&lt;&gt;(444,&quot; 兜 底 异 常 handlerFallback,exception 内 容 &quot;+e.getMessage(),payment); &#125; //blockHandler public CommonResult blockHandler(@PathVariable Long id, BlockException blockException) &#123; Payment payment = new Payment(id,&quot;null&quot;); return new CommonResult&lt;&gt;(445,&quot;blockHandler-sentinel 限 流 , 无 此 流 水 : blockException &quot;+blockException.getMessage(),payment); &#125;&#125; 修改后重启微服务 热部署对 java 代码级生效即使 对@SentinelResource 注解内属性，有时效果不好 目的 fallback 管运行异常 blockHandler 管配置违规 测试地址 http://localhost:84/consumer/fallback/1 没有任何配置 123456789101112131415161718192021222324252627282930313233@RestController@Slf4jpublic class CircleBreakerController &#123; public static final String SERVICE_URL = &quot;http://nacos-payment-provider&quot;; @Resource private RestTemplate restTemplate; @RequestMapping(&quot;/consumer/fallback/&#123;id&#125;&quot;) @SentinelResource(value = &quot;fallback&quot;) //没有配置 public CommonResult&lt;Payment&gt; fallback(@PathVariable Long id) &#123; CommonResult&lt;Payment&gt; result = restTemplate.getForObject(SERVICE_URL +&quot;/paymentSQL/&quot;+id, CommonResult.class,id); if (id == 4) &#123; throw new IllegalArgumentException (&quot;IllegalArgumentException,非法参数异常....&quot;); &#125;else if (result.getData() == null) &#123; throw new NullPointerException (&quot;NullPointerException,该 ID 没有对应记录,空指针异常&quot;); &#125; return result; &#125; //fallback public CommonResult handlerFallback(@PathVariable Long id,Throwable e) &#123; Payment payment = new Payment(id,&quot;null&quot;); return new CommonResult&lt;&gt;(444,&quot; 兜 底 异 常 handlerFallback,exception 内 容 &quot;+e.getMessage(),payment); &#125; //blockHandler public CommonResult blockHandler(@PathVariable Long id, BlockException blockException) &#123; Payment payment = new Payment(id,&quot;null&quot;); return new CommonResult&lt;&gt;(445,&quot;blockHandler-sentinel 限 流 , 无 此 流 水 : blockException &quot;+blockException.getMessage(),payment); &#125;&#125; 给客户 error 页面， 不友好 只配置 fallback 编码（那个业务类下面的 CircleBreakerController 的全部源码） 1@SentinelResource(value = &quot;fallback&quot;,fallback = &quot;handlerFallback&quot;) 只配置 blockHandler 编码（那个业务类下面的 CircleBreakerController 的全部源码） 1@SentinelResource(value = &quot;fallback&quot;,blockHandler = &quot;blockHandler&quot;) fallback 和 blockHandler 都配置 结果 忽略属性… 编码（那个业务类下面的 CircleBreakerController 的全部源码）==图说== 3.Feign 系列 修改 84 模块 POM 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;&lt;/dependency&gt; YML 12345678910111213141516171819202122232425server: port: 84spring: application: name: nacos-order-consumer cloud: nacos: discovery: server-addr: localhost:8848 sentinel: transport: #配置Sentinel dashboard地址 dashboard: localhost:8080 #默认8719端口，假如被占用会自动从8719开始依次+1扫描,直至找到未被占用的端口 port: 8719#消费者将要去访问的微服务名称(注册成功进nacos的微服务提供者)service-url: nacos-user-service: http://nacos-payment-provider# 激活Sentinel对Feign的支持feign: sentinel: enabled: true 业务类 带@FeignClient 注解的业务接口 12345@FeignClient(value = &quot;nacos-payment-provider&quot;,fallback = PaymentFallbackService.class)public interface PaymentService &#123; @GetMapping(&quot;/paymentSQL/&#123;id&#125;&quot;) public CommonResult&lt;Payment&gt; paymentSQL(@PathVariable(&quot;id&quot;) Long id);&#125; fallback=PaymentFallbackService.class 12345678@Componentpublic class PaymentFallbackService implements PaymentService &#123; @Override public CommonResult&lt;Payment&gt; paymentSQL(Long id) &#123; return new CommonResult&lt;&gt;(44444,&quot; 服 务 降 级 返 回,---PaymentFallbackService&quot;,new Payment(id,&quot;errorSerial&quot;)); &#125;&#125; Controller 12345678// OpenFeign@Resourceprivate PaymentService paymentService;@GetMapping(value = &quot;/consumer/paymentSQL/&#123;id&#125;&quot;)public CommonResult&lt;Payment&gt; paymentSQL(@PathVariable(&quot;id&quot;) Long id) &#123; return paymentService.paymentSQL(id);&#125; 主启动 添加@EnableFeignClients 启动 Feign 的功能 12345678@EnableDiscoveryClient@SpringBootApplication@EnableFeignClientspublic class OrderNacosMain84 &#123; public static void main(String[] args) &#123; SpringApplication.run(OrderNacosMain84.class, args); &#125;&#125; http://localhost:84/consumer/paymentSQL/1 测试 84 调用 9003， 此时故意关闭 9003 微服务提供者， 看 84 消费侧自动降级， 不会被耗死。 4.熔断框架比较 十、规则持久化① 是什么​ 一旦我们重启应用， Sentinel 规则将消失， 生产环境需要将配置规则进行持久化 ② 怎么玩将限流配置规则持久化进 Nacos 保存， 只要刷新 8401 某个 rest 地址， sentinel 控制台的流控规则就能看到， 只要 Nacos 里面的配置不删除， 针对 8401 上 Sentinel 上的流控规则持续有效 。 ③ 步骤 修改 cloudalibaba-sentinel-service8401 POM 1234&lt;dependency&gt; &lt;groupId&gt;com.alibaba.csp&lt;/groupId&gt; &lt;artifactId&gt;sentinel-datasource-nacos&lt;/artifactId&gt;&lt;/dependency&gt; YML 1234567891011121314151617181920212223242526272829303132server: port: 8401spring: application: name: cloudalibaba-sentinel-service cloud: nacos: discovery: server-addr: localhost:8848 #Nacos服务注册中心地址 sentinel: transport: dashboard: localhost:8080 #配置Sentinel dashboard地址 port: 8719 datasource: ds1: nacos: server-addr: localhost:8848 dataId: cloudalibaba-sentinel-service groupId: DEFAULT_GROUP data-type: json rule-type: flowmanagement: endpoints: web: exposure: include: &quot;*&quot;feign: sentinel: enabled: true # 激活Sentinel对Feign的支持 添加 Nacos 数据源配置 123456789101112spring: cloud: sentinel: datasource: ds1: nacos: server-addr: localhost:8848 dataId: cloudalibaba-sentinel-service groupId: DEFAULT_GROUP data-type: json rule-type: flow 添加 Nacos 业务规则配置 内容解析 1234567891011[ &#123; &quot;resource&quot;: &quot;/rateLimit/byUrl&quot;, &quot;limitApp&quot;: &quot;default&quot;, &quot;grade&quot;: 1, &quot;count&quot;: 1, &quot;strategy&quot;: 0, &quot;controlBehavior&quot;: 0, &quot;clusterMode&quot;: false &#125;] 启动 8401 后刷新 sentinel 发现业务规则有了 快速访问测试接口 http://localhost:8401/rateLimit/byUrl 默认 停止 8401 再看 sentinel 重新启动 8401 再看 sentinel 乍一看还是没有， 稍等一会儿 , 多次调用： http://localhost:8401/rateLimit/byUrl , 重新配置出现了， 持久化验证通过","categories":[{"name":"JavaEE框架","slug":"JavaEE框架","permalink":"http://blog.oy6090.top/categories/JavaEE%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"java","slug":"java","permalink":"http://blog.oy6090.top/tags/java/"},{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://blog.oy6090.top/tags/SpringCloud/"}]},{"title":"SpringCloud Alibaba Nacos 服务注册和配置中心","slug":"SpringCloud Alibaba Nacos 服务注册和配置中心","date":"2020-11-05T16:00:00.000Z","updated":"2021-01-20T14:49:39.910Z","comments":true,"path":"posts/dfb9e877.html","link":"","permalink":"http://blog.oy6090.top/posts/dfb9e877.html","excerpt":"","text":"博客参考学习视频 SpringCloud Alibaba Nacos 服务注册和配置中心一、Nacos 简介① 为什么叫 Nacos前四个字母分别为 Naming 和 Configuration 的前两个字母，最后的 s 为 Service。 ② 是什么一个更易于构建云原生应用的动态服务发现，配置管理和服务管理中心。 Nacos : Dynamic Naming and Configuration Service Nacos 就 是 注 册 中 心 + 配 置 中 心 的 组 合 等 价 于 Nacos = Eureka + Config+Bus ③ 能干嘛 代替 Eureka 做服务注册中心 替代 Config 做服务配置中心 ④ 去哪下https://github.com/alibaba/Nacos 官网文档： https://nacos.io/zh-cn/index.html https://spring-cloud-alibaba-group.github.io/github-pages/greenwich/spring-cloud-alibaba.html#_spring_cloud_alibaba_nacos_discovery ⑤ 各种注册中心比较 二、安装并运行 Nacos① 本地 Java8+Maven 环境已经 OK ② 先从官网下载 Nacoshttps://github.com/alibaba/nacos/releases/tag/1.1.4 ③ 解压安装包， 直接运行 bin 目录下的 startup.cmd ④ 命令运行成功后直接访问 http://localhost:8848/nacos​ 默认账号密码都是 nacos 三、Nacos 作为服务注册中心演示① 官网文档​ https://nacos.io/zh-cn/docs/what-is-nacos.html ② 基于 Nacos 的服务提供者 新建 Module： cloudalibaba-provider-payment9001 POM 父 POM 12345678&lt;!--Spring cloud alibaba 2.1.0.RELEASE--&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.cloud.alibaba.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt;&lt;/dependency&gt; 本模块 POM 123456789101112131415161718192021222324252627282930313233&lt;dependencies&gt; &lt;!--SpringCloud ailibaba nacos --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- SpringBoot整合Web组件 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--日常通用jar包配置--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; YML 12345678910111213141516server: port: 9001spring: application: name: nacos-payment-provider cloud: nacos: discovery: server-addr: localhost:8848 #配置Nacos地址management: endpoints: web: exposure: include: &quot;*&quot; 主启动 1234567@EnableDiscoveryClient@SpringBootApplicationpublic class PaymentMain9001 &#123; public static void main(String[] args) &#123; SpringApplication.run(PaymentMain9001.class, args); &#125;&#125; 业务类 123456789101112@RestControllerpublic class PaymentController &#123; @Value(&quot;$&#123;server.port&#125;&quot;) private String serverPort; @GetMapping(value = &quot;/payment/nacos/&#123;id&#125;&quot;) public String getPayment(@PathVariable(&quot;id&quot;) Integer id) &#123; return &quot;nacos registry, serverPort: &quot;+ serverPort+&quot;\\t id:&quot;+id; &#125;&#125; 测试 http://lcoalhost:9001/payment/nacos/1 nacos 控制台 nacos 服务注册中心 + 服务提供者 9001 都 OK ③ 演示 nacos 的负载均衡，参照 9001 新建 9002 新建 cloudalibaba-provider-payment9002 9002 其他步骤参考 9001 或者取巧不想新建重复的劳动力，直接拷贝虚拟端口映射 ④ 基于 Nacos 的服务消费者 新建 Module: cloudalibaba-consumer-nacos-order83 POM 12345678910111213141516171819202122232425262728293031323334353637383940&lt;dependencies&gt; &lt;!--SpringCloud ailibaba nacos --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 引入自己定义的api通用包，可以使用Payment支付Entity --&gt; &lt;dependency&gt; &lt;groupId&gt;com.atguigu.springcloud&lt;/groupId&gt; &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt; &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- SpringBoot整合Web组件 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--日常通用jar包配置--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; ==为什么 nacos 支持负载均衡： 因为依赖了 ribbon== YML 1234567891011121314server: port: 83spring: application: name: nacos-order-consumer cloud: nacos: discovery: server-addr: localhost:8848#消费者将要去访问的微服务名称(注册成功进nacos的微服务提供者)service-url: nacos-user-service: http://nacos-payment-provider 主启动 1234567@EnableDiscoveryClient@SpringBootApplicationpublic class OrderNacosMain83 &#123; public static void main(String[] args) &#123; SpringApplication.run(OrderNacosMain83.class, args); &#125;&#125; 业务类 ① ApplicationContextBean 123456789@Configurationpublic class ApplicationContextConfig &#123; @Bean @LoadBalanced public RestTemplate getRestTemplate()&#123; return new RestTemplate(); &#125;&#125; ② OrderNacosController 123456789101112131415@RestController@Slf4jpublic class OrderNacosController &#123; @Resource private RestTemplate restTemplate; @Value(&quot;$&#123;service-url.nacos-user-service&#125;&quot;) private String serverURL; @GetMapping(value = &quot;/consumer/payment/nacos/&#123;id&#125;&quot;) public String paymentInfo(@PathVariable(&quot;id&quot;) Long id)&#123; return restTemplate.getForObject(serverURL+&quot;/payment/nacos/&quot;+id,String.class); &#125;&#125; 测试 ① nacos 控制台 ② http://localhost:83/consumer/payment/nacos/13 ③ 83 访问 9001/9002， 轮询负载 OK ⑤ 服务注册中心对比Nacos 全景图所示 Nacos 和 CAP Nacos 支持 AP 和 CP 模式的切换 1curl -X PUT &#x27;$NACOS_SERVER:8848/nacos/v1/ns/operator/switches?entry=serverMode&amp;value=CP&#x27; 四、Nacos 作为服务配置中心演示① Nacos 作为配置中心-基础配置 cloudalibaba-config-nacos-client3377 POM 123456789101112131415161718192021222324252627282930313233343536373839&lt;dependencies&gt; &lt;!--nacos-config--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--nacos-discovery--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--web + actuator--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--一般基础配置--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; YML why 配置两个 Nacos 同 springcloud-config 一样，在项目初始化时，要保证先从配置中心配置拉取，拉取配置之后，才能保证项目的正常启动。 springboot 中配置文件的加载是存在优先级顺序的，bootstrap 优先级高于 application bootstrap 1234567891011121314# nacos配置server: port: 3377spring: application: name: nacos-config-client cloud: nacos: discovery: server-addr: localhost:8848 #Nacos服务注册中心地址 config: server-addr: localhost:8848 #Nacos作为配置中心地址 file-extension: yaml #指定yaml格式的配置 application.yml 123spring: profiles: active: dev 主启动 1234567@EnableDiscoveryClient@SpringBootApplicationpublic class NacosConfigClientMain3377 &#123; public static void main(String[] args) &#123; SpringApplication.run(NacosConfigClientMain3377.class, args); &#125;&#125; 业务类(controller) 123456789101112@RestController@RefreshScopepublic class ConfigClientController &#123; @Value(&quot;$&#123;config.info&#125;&quot;) private String configinfo; @GetMapping(&quot;/config/info&quot;) public String getConfiginfo()&#123; return configinfo; &#125;&#125; 注意：@RefreshScope 通过 Spring Cloud 原生注解 @RefreshScope 实现配置自动更新 ② 在 Nacos 中添加配置信息 Nacos 中的匹配规则 理论： ​ Nacos 中的 dataid 的组成格式与 springBoot 配置文件中的匹配规则 ​ 官网：https://nacos.io/zh-cn/docs/quick-start-spring-cloud.html ​ ③ 实操 配置新增： nacos-config-client-dev Nacos 界面配置对应 ==设置 DataId== 公 式 : ${spring.application.name}-${spring.profile.active}.${spring.cloud.nacos.config.file-extension} prefix 默认为 spring.application.name 的值 spring.profile.active 既 为 当 前 环 境 对 应 的 profile, 可 以 通 过 配 置 项 spring.profile.active 来配置 file-exetension 为 配 置 内 容 的 数 据 格 式 ， 可 以 通 过 配 置 项 spring.cloud.nacos.config.file-extension 配置 小总结说明 测试 启动前需要在 nacos 客户端-配置管理-配置管理栏目下有没有对应的 yaml 配置文件 运行 cloud-config-nacos-client3377 的主启动类 调用接口查看配置信息： http://localhost:3377/config/info 自带动态刷新 自带动态刷新 修改下 Nacos 中的 yaml 配置文件， 再次调用查看配置的接口， 就会发现配置已经刷新 ④ Nacos 作为配置中心-分类配置问题： 多环境多项目管理 Nacos 的图形化管理界面 配置管理 命名空间 Namespace+Group+Data ID 三者关系？ 为什么这么设计？ Case 1.DataID 方案指定 spring.profile.active 和配置文件的 DataID 来使不同环境下读取不同的配置默认空间+默认分组+新建 dev 和 test 两个 DataID 新建 dev 配置 DataID 新建 test 配置 DataID 通过 spring.profile.active 属性就能进行多环境下配置文件的读取 测试 http://localhost:3377/config/info 配置是什么就加载什么： test 2.Group 方案 通过 Group 实现环境区分新建 Group 在 nacos 图形界面控制台上面新建配置文件 DataID bootstrap+application ​ 在 config 下 增 加 一 条 group 的 配 置 即 可 。 可 配 置 为 DEV_GROUP 或 TEST_GROUP 3.Namespace 方案 新建 dev/test 的 Namespace 回到服务管理-服务列表查看 按照域名配置填写 YML Bootstrap 1namespace: Application： 不变 五、Nacos 集群和持久化配置① 官网说明https://nacos.io/zh-cn/docs/cluster-mode-quick-start.html 官网架构图： 上图官网翻译， 真实情况 ==说明== ​ 默认使用 Nacos 使用嵌入式数据库实现数据的存储。所以，如果启动多个默认配置下的 Nacos 节点，数据存储是存在一致性问题的。为了解决这个问题，Nacos 采用了集中式存储的方式集群化部署，目前只支持 MySQL 的存储。 Nacos 支持三种部署，模式 单机模式，用于测试和单机试用 集群部署，用于生产环境，确保高可用。 多集群模式，用于多数据中心场景。 windows cmd starup.cmd 或者双击 startup.cmd 文件 单机模式支持 mysql 按照上述： 我们需要 mysql 数据库。 ==官网说明== https://nacos.io/zh-cn/docs/deployment.html ② Nacos 持久化配置解释​ Nacos 默认自带的是嵌入式数据库 derby derby 到 mysql 切换配置步骤 nacos-server-1.1.4\\nacos\\conf 目录下找到 sql 脚本 执行脚本: 1234567891011121314151617181920212223242526CREATE DATABASE nacos_config;USE nacos_config;/* 数据库全名 = nacos_config *//* 表名称 = config_info *//******************************************/CREATE TABLE `config_info` ( `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#x27;id&#x27;, `data_id` varchar(255) NOT NULL COMMENT &#x27;data_id&#x27;, `group_id` varchar(255) DEFAULT NULL, `content` longtext NOT NULL COMMENT &#x27;content&#x27;, `md5` varchar(32) DEFAULT NULL COMMENT &#x27;md5&#x27;, `gmt_create` datetime NOT NULL DEFAULT &#x27;2010-05-05 00:00:00&#x27; COMMENT &#x27;创建时间&#x27;, `gmt_modified` datetime NOT NULL DEFAULT &#x27;2010-05-05 00:00:00&#x27; COMMENT &#x27;修改时间&#x27;, `src_user` text COMMENT &#x27;source user&#x27;, `src_ip` varchar(20) DEFAULT NULL COMMENT &#x27;source ip&#x27;,`app_name` varchar(128) DEFAULT NULL, `tenant_id` varchar(128) DEFAULT &#x27;&#x27; COMMENT &#x27;租户字段&#x27;, `c_desc` varchar(256) DEFAULT NULL, `c_use` varchar(64) DEFAULT NULL, `effect` varchar(64) DEFAULT NULL, `type` varchar(64) DEFAULT NULL, `c_schema` text, PRIMARY KEY (`id`), UNIQUE KEY `uk_configinfo_datagrouptenant` (`data_id`,`group_id`,`tenant_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT=&#x27;config_info&#x27;;....省略后面的。参考自己的 nacos-server-1.1.4\\nacos\\conf 目 录 下 找 到 application.properties 在文件下面添加 12345spring.datasource.platform=mysqldb.num=1db.url.0=jdbc:mysql://11.162.196.16:3306/nacos_devtest?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=truedb.user=nacos_devtestdb.password=youdontknow ​ 参考 启动 nacos， 可以看到是个全新的空记录界面， 以前是记录进 derby ③ Linux 版 Nacos+MySQL 生产环境配置 预计需要， 1 个 nginx+3 个 nacos 注册中心+1 个 mysql Nacos 下载 linux 版本 https://github.com/alibaba/nacos/releases/tag/1.1.4 nacos-server-1.1.4.tar.gz 解压后安装 集群配置步骤（==重点==） Linux 服务器上 mysql 数据库配置 application.properties 配置 位置: 内容 12345spring.datasource.platform=mysqldb.num=1db.url.0=jdbc:mysql://1.7.0.1:3306/nacos_config?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=truedb.user=rootdb.password=HF_mysql_654321 **==注意==**： mysql 授权远程访问 12GRANT ALL PRIVILEGES ON *.* TO &#x27;root&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;123456&#x27; WITH GRANT OPTION;flush privileges; ④ Linux 服务器上 nacos 的集群配置 cluster.conf 梳理出 3 台 nacos 机器的不同服务端口号复制出 cluster.conf 内容 这个 IP 不能写 127.0.0.1,必须是 Linux 命令 hostname -I 能够识别的 IP ⑤ 编辑 Nacos 的启动脚本 startup.sh， 使它能够接受不同的启动端 /mynacos/nacos/bin 目录下有 startup.sh 在什么地方， 修改什么， 怎么修改思考 修改内容 ==注意：== 1这里是 —Dserver.port&#x3D;$&#123;PORT&#125;, 不要误认为是“.” 在启动前一定要先启动 mysql 服务，不然 nacos 会报错： 1[root@localhost ~]# service mysql start 执行方式 同时通过 window 浏览器访问 http://192.168.64.129:3333/nacos/#/login http://192.168.64.129:4444/nacos/#/login http://192.168.64.129:5555/nacos/#/login ⑥ Nginx 的配置， 由它作为负载均衡器安装 nginx 请参考我这篇博客： 修改 nginx 的配置文件 nginx.conf 123456789101112upstream cluster&#123; server 127.0.0.1:3333; server 127.0.0.1:4444; server 127.0.0.1:5555;&#125;server&#123; listen 1111; server_name localhost; location &#x2F;&#123; proxy_pass http:&#x2F;&#x2F;cluster &#125; ....省略 按照指定启动 ⑦ 截止到此处， 1 个 Nginx+3 个 nacos 注册中心+1 个 mysql 测试通过 nginx 访问 nacoshttps://写你自己虚拟机的 ip:1111/nacos/#/login 新建一个配置测试 linux 服务器的 mysql 插入一条记录 ⑧ 测试​ 微服务 cloudalibaba-provider-payment9002 启动注册进 nacos 集群 Yml 1server-addr: 写你自己的虚拟机 ip:1111 结果 六、高可用小总结","categories":[{"name":"JavaEE框架","slug":"JavaEE框架","permalink":"http://blog.oy6090.top/categories/JavaEE%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"java","slug":"java","permalink":"http://blog.oy6090.top/tags/java/"},{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://blog.oy6090.top/tags/SpringCloud/"}]},{"title":"SpringCloud Sleuth 分布式请求链路","slug":"SpringCloud Sleuth 分布式请求链路","date":"2020-10-22T16:00:00.000Z","updated":"2021-01-20T14:49:48.471Z","comments":true,"path":"posts/1330258666.html","link":"","permalink":"http://blog.oy6090.top/posts/1330258666.html","excerpt":"","text":"博客学习参考视频 一、概述① 为什么会出现这个技术？ 需要解决哪些问题？​ 在微服务框架中，一个由客户端发起的请求在后端系统中会经过多个不同的服务点调用来协同产生最后的请求结果，每一个前端请求都会形成一条复杂的分布式服务调用链路，链路中的任何一环出现高延迟或错误都会引起整个请求最后的失败。 ② 是什么https://github.com/spring-cloud/spring-cloud-sleuth Spring Cloud Sleuth 提供了一套完整的服务跟踪的解决方案，在分布式系统中提供追踪解决方案并且兼容支持了 zipkin。 ③ 解决 二、搭建链路监控步骤① zipkin 下载 SpringCloud 从 F 版起已不需要自己构建 Zipkin server 了，只需要调用 jar 包即可 https://dl.bintray.com/openzipkin/maven/io/zipkin/java/zipkin-server/ zipkin-server-2.12.9.exec.jar 运行 jar 运行控制台 http://localhost:9411/zipkin/ 术语 完整的调用链路 上图 what 名词解释 Trace： 类似于树结构的 Span 集合，表示一条调用链路，存在唯一标识 span: 表示调用链路来源，通俗的理解 span 就是一次请求信息 ② 服务提供者 cloud-provider-payment8001 POM 12345&lt;!--包含了 sleuth+zipkin--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-zipkin&lt;/artifactId&gt;&lt;/dependency&gt; YML 12345678910111213141516171819202122232425262728293031server: port: 8001spring: application: name: cloud-payment-service zipkin: base-url: http://localhost:9411 sleuth: sampler: #采样率值介于 0 到 1 之间，1 则表示全部采集 probability: 1 datasource: type: com.alibaba.druid.pool.DruidDataSource driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/db2019?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false&amp;serverTimezone=UTC username: root password: 6090mybatis: mapperLocations: classpath:mapper/*.xml type-aliases-package: com.oy.springcloud.entities # 所有Entity别名类所在包eureka: client: register-with-eureka: true fetch-registry: true service-url: # 集群版 defaultZone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka instance: instance-id: payment8001 prefer-ip-address: true 业务类 PaymentController 123456// ====================&gt; zipkin+sleuth@GetMapping(&quot;/payment/zipkin&quot;)public String paymentZipkin()&#123; return &quot;hi ,i&#x27;am paymentzipkin server fall back，welcome to atguigu，O(∩_∩)O哈哈~&quot;;&#125; ③ 服务消费者（调用方） cloud-consumer-order80 POM 12345&lt;!--包含了 sleuth+zipkin--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-zipkin&lt;/artifactId&gt;&lt;/dependency&gt; YML 12345zipkin: base-url: http://localhost:9411sleuth: sampler: probability: 1 业务类 OrderController 1234567@GetMapping(&quot;/consumer/payment/zipkin&quot;)public String paymentZipkin()&#123; String result = restTemplate.getForObject(&quot;http://localhost:8001&quot;+&quot;/payment/zipkin/&quot;, String.class); return result;&#125; ④ 依次启动 eureka7001/8001/8080 调用 8001 几次测试下 ： http://localhost/consumer/payment/zipkin ⑤ 打开浏览器访问：http:localhost:9411 会出现以下界面 查看依赖关系 原理","categories":[{"name":"JavaEE框架","slug":"JavaEE框架","permalink":"http://blog.oy6090.top/categories/JavaEE%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"java","slug":"java","permalink":"http://blog.oy6090.top/tags/java/"},{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://blog.oy6090.top/tags/SpringCloud/"}]},{"title":"SpringCloud Stream 消息驱动","slug":"SpringCloud Stream 消息驱动","date":"2020-10-20T16:00:00.000Z","updated":"2021-01-22T03:52:54.713Z","comments":true,"path":"posts/1677637013.html","link":"","permalink":"http://blog.oy6090.top/posts/1677637013.html","excerpt":"","text":"博客学习参考视频 一、消息驱动概述① 是什么​ 一句话： 屏蔽底层消息中间件的差异，降低切换版本，统一消息的编程模型 官网 https://spring.io/projects/spring-cloud-stream#overview Spring Cloud Stream 是用于构建与共享 消息传递系统 连接的高度可伸缩的事件驱动微服务框架，该框架提供一个灵活的编程模型，它建立在 spring 的基础上，包括支持持久化的发布/订阅、消费以及分区 这三个核心概念 https://cloud.spring.io/spring-cloud-static/spring-cloud-stream/3.0.1.RELEASE/reference/html/ Spring Cloud Stream 中 文 指 导 手 册 ：https://m.wang1314.com/doc/webapp/topic/20971999.html ② 设计思想 标准 MQ 生产者/消费者 之间靠消息媒介传递消息内容 – Message 消息必须走特定的通道 – 消息通道 MessageChannel 消息通道里的消息如何被消费呢，谁负责处理 – 消息通道 MessageChannel 的子接口 SubscribaleChannel， 由 MessageHandle 消息处理器订阅 为什么用 Cloud Stream 比方说我们用到的了 RabbitMQ 和 Kafka，由于这两个消息中间件的架构上的不同，像 RabbitMQ 有 exchange, kafka 有 Topic 和 Partitions 分区 这些中间件的差异性导致我们实际项目开发中会造成一定困扰， 我们如果用了两个消息队列的其中一种， 后面的业务需求，我们想往另外一种消息队列进行迁移， 这时候无疑就是一个灾难性的， 一大堆东西都要中心推倒重新做， 因为他跟我们的系统耦合了， 这时候 springcloud Stream 给我们提供了一种解耦合的方式。 stream 凭什么可以统一底层差异 。 4.Binder INPUT 对应消费者 OUTPUT 对应于生产者 Stream 中的消息通信方式遵循了发布-订阅模式 Topic 主题进行广播 在 RabbitMQ 就是 Exchange 在 Kafka 中就是 Topic ③ Spring Cloud Stream 标准流程套路 Binder：很方便的连接中间件，屏蔽差异 Channel： 通道，是队列 Query 的一种抽象，在消息通讯系统中就是实现存储和转发的媒介，通过对 Channel 对队列进行配置 Source 和 Sink： 简答的可理解为参照对象是 Spring Cloud Stream 自身，从 Stream 发布消息就是输出，接收消息就是输入 ④ 编码 API 和常用注解 二、案例说明① RabbitaMQ 环境已经 OK​ 请参考这篇博客： SpringBoot 与消息 ② 工程中新建三个子模块 cloud-stream-rabbitmq-provider8801,作为生产者进行发消息模块 cloud-stream-rabbitmq-consumer8802,作为消息接收模块 cloud-stream-rabbitmq-consumer8803,作为消息接收模块 三、消息驱动之生产者 新建 Module： cloud-stream-rabbitmq-provider8801 POM 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;clould&lt;/artifactId&gt; &lt;groupId&gt;com.oy&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;cloud-stream-rabbitmq-provider8801&lt;/artifactId&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-stream-rabbit&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--基础配置--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; YML 123456789101112131415161718192021222324252627282930313233server: port: 8801spring: application: name: cloud-stream-provider cloud: stream: binders: # 在此处配置要绑定的rabbitmq的服务信息； defaultRabbit: # 表示定义的名称，用于于binding整合 type: rabbit # 消息组件类型 environment: # 设置rabbitmq的相关的环境配置 spring: rabbitmq: host: 116.63.177.72 port: 5672 username: guest password: guest bindings: # 服务的整合处理 output: # 这个名字是一个通道的名称 destination: studyExchange # 表示要使用的Exchange名称定义 content-type: application/json # 设置消息类型，本次为json，文本则设置“text/plain” binder: defaultRabbit # 设置要绑定的消息服务的具体设置eureka: client: # 客户端进行Eureka注册的配置 service-url: defaultZone: http://localhost:7001/eureka instance: lease-renewal-interval-in-seconds: 2 # 设置心跳的时间间隔（默认是30秒） lease-expiration-duration-in-seconds: 5 # 如果现在超过了5秒的间隔（默认是90秒） instance-id: send-8801.com # 在信息列表时显示主机名称 prefer-ip-address: true # 访问的路径变为IP地址 主启动类 123456@SpringBootApplicationpublic class StreamMQMain8801 &#123; public static void main(String[] args) &#123; SpringApplication.run(StreamMQMain8801.class, args); &#125;&#125; 业务类 发消息接口： 1234public interface IMessageProvider &#123; public String send();&#125; 发送消息接口实现类 1234567891011121314@EnableBinding(Source.class) // 定义消息的推送管道public class MessionProvicerImpl implements IMessageProvider &#123; @Resource private MessageChannel output; // 消息发送管道 @Override public String send() &#123; String serial = UUID.randomUUID().toString(); output.send(MessageBuilder.withPayload(serial).build()); System.out.println(&quot;******serial:&quot; + serial); return null; &#125;&#125; Controller 123456789101112@RestControllerpublic class SendMessageController &#123; @Resource private IMessageProvider messageProvider; @GetMapping(value = &quot;/sendMessage&quot;) public String sendMessage() &#123; return messageProvider.send(); &#125;&#125; 测试 启动 7001eureka 启动 rabbitmq http://localhost:15672/ （自己使用的是 Docker） 启动 8801 访问： http://localhost:8801/sendMessage 注意：有个大坑,视频里的 application.yml 使用了 spring.cloud.stream.binders.defaultRabbit.environment.spring.rabbitmq.xx 来配置 rabbitmq 的环境如果你是用的其他服务器上的 rabbitmq，比如我使用的我自己的华为云服务器然后创建 docker 容器来运行 rabbitmq。按照视频中的配置方式的话，启动时会试图连接两次 rabbitmq 程序第一次试图连接访问的就是 application.yml 中配置 的地址，此时已经订阅成功了但是程序还会在之后进行第二次连接，此时访问的地址就是 localhost:5672，在我的环境中，我本地 没有 rabbitmq 环境，所以直接报 IOException 所以，如果是使用的自己的服务器来配置，则需要修改配置文件，将 rabbitmq 的配置 信息移动到 application.yml 中的 spring 节点下修改后的配置如下： 12345678910111213141516171819202122232425262728293031server: port: 8801spring: application: name: cloud-stream-provider rabbitmq: host: 华为云ip port: 5672 username: guest password: guest cloud: stream: binders: defaultRabbit: type: rabbit bindings: output: destination: studyExchange content-type: application/json binder: defaultRabbiteureka: client: # 客户端进行Eureka注册的配置 service-url: defaultZone: http://localhost:7001/eureka instance: lease-renewal-interval-in-seconds: 2 # 设置心跳的时间间隔（默认是30秒） lease-expiration-duration-in-seconds: 5 # 如果现在超过了5秒的间隔（默认是90秒） instance-id: send-8801.com # 在信息列表时显示主机名称 prefer-ip-address: true # 访问的路径变为IP地址 四、消息驱动之消费者 新建 Module ​ cloud-stream-rabbitmq-consumer8802 POM 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;clould&lt;/artifactId&gt; &lt;groupId&gt;com.oy&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;cloud-stream-rabbitmq-consumer8802&lt;/artifactId&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-stream-rabbit&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-eure ka-server --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.oy&lt;/groupId&gt; &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;!--https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-web --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-web --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-devtools --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.projectlombok/lombok --&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt;&lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-test --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; YML 12345678910111213141516171819202122232425262728293031server: port: 8802spring: application: name: cloud-stream-consumer rabbitmq: host: 华为云ip // localhost port: 5672 username: guest password: guest cloud: stream: binders: # 在此处配置要绑定的rabbitmq的服务信息； defaultRabbit: # 表示定义的名称，用于于binding整合 type: rabbit # 消息组件类型 bindings: # 服务的整合处理 input: # 这个名字是一个通道的名称 destination: studyExchange # 表示要使用的Exchange名称定义 content-type: application/json # 设置消息类型，本次为对象json，如果是文本则设置“text/plain” binder: defaultRabbit # 设置要绑定的消息服务的具体设置eureka: client: # 客户端进行 Eureka 注册的配置 service-url: defaultZone: http://localhost:7001/eureka instance: lease-renewal-interval-in-seconds: 2 # 设置心跳的时间间隔（默认是 30 秒） lease-expiration-duration-in-seconds: 5 # 如果现在超过了 5 秒的间隔（默认是 90秒） instance-id: receive-8802.com # 在信息列表时显示主机名称 prefer-ip-address: true # 访问的路径变为 IP 地址 主启动 123456@SpringBootApplicationpublic class StreamMQMain8802 &#123; public static void main(String[] args) &#123; SpringApplication.run(StreamMQMain8802.class, args); &#125;&#125; 业务类 12345678910111213141516171819202122232425package com.oy.springcloud.controller;import org.springframework.cloud.stream.annotation.EnableBinding;import org.springframework.messaging.Message;import org.springframework.beans.factory.annotation.Value;import org.springframework.cloud.stream.annotation.StreamListener;import org.springframework.cloud.stream.messaging.Sink;import org.springframework.stereotype.Component;/** * @Author OY * @Date 2020/10/22 */@Component@EnableBinding(Sink.class)public class ReceiveMessageListenerController &#123; @Value(&quot;$&#123;server.port&#125;&quot;) private String serverPort; @StreamListener(Sink.INPUT) public void input(Message&lt;String&gt; message)&#123; System.out.println(&quot; 消 费 者 1 号 ， 接 受 ： &quot;+message.getPayload()+&quot;\\t port:&quot;+serverPort); &#125;&#125; 测试 8801 发送 8802 接收消息： ​ http://localhost:8801/sendMessage 五、分组消费与持久化① 配置 8803 依照 8802， clone 出来一份运行 8803 cloud-stream-rabbitmq-consumer8803 POM 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;clould&lt;/artifactId&gt; &lt;groupId&gt;com.oy&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;cloud-stream-rabbitmq-consumer8803&lt;/artifactId&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-stream-rabbit&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--基础配置--&gt; &lt;dependency&gt;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; YML 12345678910111213141516171819202122232425262728293031server: port: 8803spring: application: name: cloud-stream-consumer rabbitmq: host: 116.63.177.72 port: 5672 username: guest password: guest cloud: stream: binders: # 在此处配置要绑定的rabbitmq的服务信息； defaultRabbit: # 表示定义的名称，用于于binding整合 type: rabbit # 消息组件类型 bindings: # 服务的整合处理 input: # 这个名字是一个通道的名称 destination: studyExchange # 表示要使用的Exchange名称定义 content-type: application/json # 设置消息类型，本次为对象json，如果是文本则设置“text/plain” binder: defaultRabbit # 设置要绑定的消息服务的具体设置eureka: client: # 客户端进行 Eureka 注册的配置 service-url: defaultZone: http://localhost:7001/eureka instance: lease-renewal-interval-in-seconds: 2 # 设置心跳的时间间隔（默认是 30 秒） lease-expiration-duration-in-seconds: 5 # 如果现在超过了 5 秒的间隔（默认是 90秒） instance-id: receive-8803.com # 在信息列表时显示主机名称 prefer-ip-address: true # 访问的路径变为 IP 地址 主启动类 123456@SpringBootApplicationpublic class StreamMQMain8803 &#123; public static void main(String[] args) &#123; SpringApplication.run(StreamMQMain8803.class, args); &#125;&#125; Controller 12345678910111213141516171819202122232425package com.oy.springcloud.controller;import org.springframework.beans.factory.annotation.Value;import org.springframework.cloud.stream.annotation.EnableBinding;import org.springframework.cloud.stream.annotation.StreamListener;import org.springframework.cloud.stream.messaging.Sink;import org.springframework.messaging.Message;import org.springframework.stereotype.Component;/** * @Author OY * @Date 2020/10/22 */@Component@EnableBinding(Sink.class)public class ReceiveMessageListenerController &#123; @Value(&quot;$&#123;server.port&#125;&quot;) private String serverPort; @StreamListener(Sink.INPUT) public void input(Message&lt;String&gt; message)&#123; System.out.println(&quot; 消 费 者 2 号 ， 接 受 ： &quot;+message.getPayload()+&quot;\\t port:&quot;+serverPort); &#125;&#125; ② 启动 RabbitMQ 7001： 服务注册 8801： 消息生产 8802： 消息消费 8803： 消息消费 ③ 运行后两个问题 有重复消费问题 消息持久化问题 、 ④ 消费： 目前是 8802/8803 同时都收到了， 存在重复消费问题 http://localhost:8801/sendMessage 如何解决： 分组和持久化属性 group 生产实际案例 ⑤ 分组原理 ​ 微服务应用放置于同一个 group 中，就能保证消息只会被其中一个应用消费一次。不同的组是可以消费的。同一个组内发生的竞争的关系，只有一个可以消费。 8802/8803 都变成不同组， group 两个不同 group: atguiguA、 atguiguB 8802 修改 YML 1group: atguiguA 8803 修改 YML 1group: atguiguB 我们自己配置 ​ 分布式微服务应用为了实现高可用和负载均衡，实际上都会户数多个实例，本例启动了两个消费微服务（8802/8803）多数情况，生产者发送消息给某个具体微服务只希望被消费一次，按照上面我们启动两个应用的例子，虽然它们同属一个应用，但是这个消息出现了被重复消费两次的情况。为了解决这个问题，在 Spring Cloud Stream 中提供了消费组的概念。 结论： 还是重复消费 8802/8803 实现了轮询分组， 每次只有一个消费者 8801 模块的发的消息只能被 8802 或 8803 其中一个接收到， 这样避免了重复 消费 。 8802/8803 都变成相同组， group 两个相同 。 group: atguiguA 8802 修改 YML 1group: atguiguA 8803 修改 YML 1group: atguiguA 结论： 同一个组的多个微服务实例， 每次只会有一个拿到 ⑥ 持久化通过上述， 解决了重复消费问题， 再看看持久化，停止 8802/8803 并去除掉 8802 的分组 group:atguiguA，8803 的分组 group:atguiguA 没有去掉。8801 先发送 4 条信息到 rabbitmq。 先启动 8802， 无分组属性配置， 后台没有打出来消息 先启动 8803， 有分组属性配置， 后台打出来了 MQ 上的消息","categories":[{"name":"JavaEE框架","slug":"JavaEE框架","permalink":"http://blog.oy6090.top/categories/JavaEE%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"java","slug":"java","permalink":"http://blog.oy6090.top/tags/java/"},{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://blog.oy6090.top/tags/SpringCloud/"}]},{"title":"SpringCloud Alibaba 入门简介","slug":"SpringCloud Alibaba 入门简介","date":"2020-10-19T16:00:00.000Z","updated":"2020-11-06T14:53:31.708Z","comments":true,"path":"posts/80f09d1c.html","link":"","permalink":"http://blog.oy6090.top/posts/80f09d1c.html","excerpt":"","text":"博客参考学习视频 SpringCloud Alibaba 入门简介一、 why 会出现 SpringCloud Alibaba 入门简介① spring cloud Netflix 项目进入维护模式 说明： Spring Cloud Netflix 项目进入维护模式 最近，Netflix 正式进入维护阶段模式。自2016年以来， Ribbon已处于类似的状态。虽然Hystrix 和 Raibbon 现处于维护模式，但它们仍在Netflix大规模的部署。 Hystrix仪表板和涡轮已被Atlas取代。对这些项目的最后承诺分别是2年和4年前。Zuul 1和Archaius 1都已被不向后兼容的更高版本所取代。 以下Spring Cloud Netflix模块和相应的启动器将进入维护模式： spring-cloud-netflix-archaiusspring-cloud-netflix-hystrix-contractspring-cloud-netflix-hystrix-dashboardspring-cloud-netflix-hystrix-streamspring-cloud-netflix-hystrixspring-cloud-netflix-ribbonspring-cloud-netflix-turbine-streamspring-cloud-netflix-turbinespring-cloud-netflix-zuul 这不包括Eureka或并发限制模块。 什么是维护模式？将模块置于维护模式意味着Spring Cloud团队将不再向该模块添加新功能。我们将修复阻止程序错误和安全性问题，还将考虑并审查社区的一些小请求。 ② SpringCloud NetFlix Projects Entering Maintenance Mode什么是维护模式 进入维护模式意味着什么呢？ 二、SpringBoot alibaba 带来了什么 是什么 官网： https://github.com/alibaba/spring-cloud-alibaba/blob/master/README-zh.md 能干嘛 去哪下 https://github.com/alibaba/spring-cloud-alibaba/blob/master/README-zh.md 怎么玩 Sentinel： 把流量作为切入点， 从流量控制、 熔断降级、 系统负载保护等多个维度保护服务的稳定性。 Nacos： 一个更易于构建云原生应用的动态服务发现、 配置管理和服务管理平台。 RocketMQ： 一款开源的分布式消息系统， 基于高可用分布式集群技术， 提供低延时的、 高可靠的消息发布与订阅服务。 Dubbo： Apache Dubbo™ 是一款高性能 Java RPC 框架。 Seata： 阿里巴巴开源产品， 一个易于使用的高性能微服务分布式事务解决方案。 Alibaba Cloud ACM： 一款在分布式架构环境中对应用配置进行集中管理和推送的应用配置中心产品。 Alibaba Cloud OSS: 阿里云对象存储服务（Object Storage Service， 简称 OSS） ，是阿里云提供的海量、 安全、 低成本、 高可靠的云存储服务。 您可以在任何应用、任何时间、 任何地点存储和访问任意类型的数据。 Alibaba Cloud SchedulerX: 阿里中间件团队开发的一款分布式任务调度产品，提供秒级、 精准、 高可靠、 高可用的定时（基于 Cron 表达式） 任务调度服务。 Alibaba Cloud SMS: 覆盖全球的短信服务， 友好、 高效、 智能的互联化通讯能力， 帮助企业迅速搭建客户触达通道。 SpringCloud alibaba 学习资料获取 三、SpringCloud alibaba 学习资料获取① 官网https://spring.io/projects/spring-cloud-alibaba#overview ② 英文 https://github.com/alibaba/spring-cloud-alibaba https://spring-cloud-alibaba-group.github.io/github-pages/greenwich/spring-cloud-alibaba.html ③ 中文 https://github.com/alibaba/spring-cloud-alibaba/blob/master/README-zh.md","categories":[{"name":"JavaEE框架","slug":"JavaEE框架","permalink":"http://blog.oy6090.top/categories/JavaEE%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"java","slug":"java","permalink":"http://blog.oy6090.top/tags/java/"},{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://blog.oy6090.top/tags/SpringCloud/"}]},{"title":"SpringCloud Bus 消息总线","slug":"SpringCloud Bus 消息总线","date":"2020-10-19T16:00:00.000Z","updated":"2020-10-25T02:32:29.042Z","comments":true,"path":"posts/272460835.html","link":"","permalink":"http://blog.oy6090.top/posts/272460835.html","excerpt":"","text":"博客学习参考视频 一、概述① 上一讲解的加深和扩充， 一言以蔽之​ 分布式自动刷新配置功能，Spring Cloud Bus 配合 Spring Cloud Config 使用可以实现配置的动态刷新。 ② 是什么 Bus 支持两种消息代理： RabbitMQ 和 Kafka ③ 能干嘛 ④ 为何被称为总线 二、RabbitMQ 环境配置安装采用的是 Linux CentOS7 的 Docker 容器，具体安装请参考这篇博客：https://oy6090.top/2020/10011634411798.html 安装完成之后，测试：你的 linux 地址:15672 输入账号密码并登录: guest guest 三、SpringCloud Bus 动态刷新全局广播1.必须先具备良好的 RabbitMQ 环境2.演示广播效果， 增加复杂度， 再以 3355 为模板再制作一个 3366 新建： cloud-config-client-3366 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;clould&lt;/artifactId&gt; &lt;groupId&gt;com.oy&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;cloud-config-client-3366&lt;/artifactId&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.oy&lt;/groupId&gt; &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; YML (bootstrap.yml) 123456789101112131415161718192021222324252627282930313233server: port: 3366spring: application: name: config-client cloud: #Config客户端配置 config: label: main #分支名称 ,注意最新GitHub对master进行了调整，改为main了。 name: config #配置文件名称 profile: dev #读取后缀名称 上述3个综合：master分支上config-dev.yml的配置文件被读取http://config-3344.com:3344/master/config-dev.yml uri: http://localhost:3344 #配置中心地址 #rabbitmq相关配置 15672是Web管理界面的端口；5672是MQ访问的端口 rabbitmq: host: localhost port: 5672 username: guest password: guest#服务注册到eureka地址eureka: client: service-url: defaultZone: http://localhost:7001/eureka# 暴露监控端点management: endpoints: web: exposure: include: &quot;*&quot; 主启动 1234567@SpringBootApplication@EnableEurekaClientpublic class ConfigClientMain3366 &#123; public static void main(String[] args) &#123; SpringApplication.run(ConfigClientMain3366.class, args); &#125;&#125; 3.设计思想 利用消息总线触发一个客户端 /bus/refresh , 而刷新所有的客户端的配置 2.利用消息总线触发一个服务端 ConfigServer 的 /bus/refresh 端点，而刷新所有客户端的配置（更加推荐） 图二的架构显然更加合适， 图一不适合的原因如下 打破了微服务的职责单一性，因为微服务本身的业务模块，它本身不应该承担配置刷新职责。 破坏了微服务个节点的对等性 有一定的局限性。例如，微服务在迁移时，它的网络地址常常会发生变化，此时如果想要做到自动刷新，那就会增加更多的修改。 4.给 cloud-config-center-3344 配置中心服务端添加消息总线支持 POM 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;/artifactId&gt;&lt;/dependency&gt; YML 12345678910111213141516171819202122232425262728293031323334353637server: port: 3344spring: application: name: cloud-config-center #注册进Eureka服务器的微服务名 cloud: config: server: git: uri: https://github.com/18731049401/springcloud-config.git #GitHub上面的git仓库名字 ####搜索目录 search-paths: - springcloud-config ####读取分支 label: main # 注意最新GitHub对master进行了调整，改为main了。#rabbitmq相关配置 rabbitmq: host: localhost port: 5672 username: guest password: guest#服务注册到eureka地址eureka: client: service-url: defaultZone: http://localhost:7001/eureka##rabbitmq相关配置,暴露bus刷新配置的端点management: endpoints: #暴露bus刷新配置的端点 web: exposure: include: &#x27;bus-refresh&#x27; 5.给 cloud-config-center-3355 客户端添加消息总线支持 POM 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;/artifactId&gt;&lt;/dependency&gt; YML 123456789101112131415161718192021222324252627282930313233server: port: 3355spring: application: name: config-client cloud: #Config客户端配置 config: label: main #分支名称 name: config #配置文件名称 profile: dev #读取后缀名称 上述3个综合：master分支上config-dev.yml的配置文件被读取http://config-3344.com:3344/master/config-dev.yml uri: http://localhost:3344 #配置中心地址k #rabbitmq相关配置 15672是Web管理界面的端口；5672是MQ访问的端口 rabbitmq: host: localhost port: 5672 username: guest password: guest#服务注册到eureka地址eureka: client: service-url: defaultZone: http://localhost:7001/eureka# 暴露监控端点management: endpoints: web: exposure: include: &quot;*&quot; 6.给 cloud-config-center-3366 客户端添加消息总线支持 POM 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;/artifactId&gt;&lt;/dependency&gt; YML 123456789101112131415161718192021222324252627282930313233server: port: 3366spring: application: name: config-client cloud: #Config客户端配置 config: label: main #分支名称 name: config #配置文件名称 profile: dev #读取后缀名称 上述3个综合：master分支上config-dev.yml的配置文件被读取http://config-3344.com:3344/master/config-dev.yml uri: http://localhost:3344 #配置中心地址 #rabbitmq相关配置 15672是Web管理界面的端口；5672是MQ访问的端口 rabbitmq: host: localhost port: 5672 username: guest password: guest#服务注册到eureka地址eureka: client: service-url: defaultZone: http://localhost:7001/eureka# 暴露监控端点management: endpoints: web: exposure: include: &quot;*&quot; 7.测试 修改 Github 上配置文件增加版本号 发送 Post 请求 1curl -X POST &quot;http://localhost:3344/actuator/bus-refresh&quot; 一次发送， 处处生效 配置中心 http://config-3344.com/config-dev.yml 客户端 http://localhost:3355/configInfo , http://localhost:3366/configInfo 获取配置信息， 发现都已经刷新了 8.一次修改， 广播通知， 处处生效四、SpringCloud Bus 动态刷新定点通知1.不想全部通知， 只想定点通知 只通知 3355不通知 3366 2.简单一句话指定具体某一个实例生效而不是全部 公 式 ： http://localhost: 配 置 中 心 的 端 口 号 /actuator/bus-refresh/{destination} /bus/refresh 请求不再发送到具体的服务实例上， 而是发给 config server 并通过 destination 参数类指定需要更新配置的服务或实例 3.案例 我们这里以刷新运行在 3355 端口上的 config-client 为例 只通知 3355,不通知 3366 1curl -X POST http:&#x2F;&#x2F;localhost:3344&#x2F;actuator&#x2F;bus-refresh&#x2F;config-client:3355 4.通知总结 All","categories":[{"name":"JavaEE框架","slug":"JavaEE框架","permalink":"http://blog.oy6090.top/categories/JavaEE%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"java","slug":"java","permalink":"http://blog.oy6090.top/tags/java/"},{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://blog.oy6090.top/tags/SpringCloud/"}]},{"title":"SpringCloud 分布式配置中心","slug":"SpringCloud config 分布式配置中心","date":"2020-10-17T16:00:00.000Z","updated":"2020-10-25T02:32:53.006Z","comments":true,"path":"posts/1519064184.html","link":"","permalink":"http://blog.oy6090.top/posts/1519064184.html","excerpt":"","text":"博客学习参考视频 ① 概述1.分布式系统面临的配置问题​ 微服务意味着要将单体应用中的业务拆分成一个个子服务，每个服务的粒度相对小，因此系统中出现大量的服务，由于每个服务都需要配置信息才能运行，所以一套集中式的、动态的配置管理设施是必不可少的。 ​ SpringCloud 提供了 ConfigServer 来解决这个问题，我们每一个微服务自己的带着一个 application.yml， 上百个配置文件的管理…o(╥﹏╥)o 2.是什么 是什么SpringCloud Config 为微服务架构中微服务提供了集中化的外部配置支持，配置服务器为各个不同微服务应用的的所有环境提供了一个中心化的外部配置。 如何使用 Spring Cloud 分为服务端和客户端两部分 服务端也称为分布式配置中心，它是一个独立的微服务应用， 用来连接配置服务器并为客户端提供获取配置信息，加密/ 解密信息等访问接口。 客户端则是通过制定的配置中心来管理应用资源，以及与业务相关的配置内容，并在启动的时候从配置中心获取好加载配置信息配置服务器默认采用 git 来存储配置信息，这样就有助于缓解配置惊醒版本管理，并且可以通过 git 客户端工具来方便管理和访问配置内容。 3.能干嘛 集中管理配置文件 不同的环境不同配置，动态化的配置更新，分环境部署比如 dev/test/prod/beta/release 运行期间动态调整配置，不在需要在每个服务部署的机器上编写配置文件，服务回向配置中心统一拉取配置自己的信息 当配置发生变动时，服务不需要重启即可感知到配置的变化并用新的配置 将配置信息以 REST 接口的形式暴露， post、curl 访问刷新均可… 4.与 Github 整合配置由于 SpringCloud Config 默认使用 Git 来存储配置文件（也有其他方式，比如支持 svn 和 本地文件，但是推荐的还是 git ,而且使用的是 http/https 访问的形式） 5.官网https://cloud.spring.io/spring-cloud-static/spring-cloud-config/2.2.1.RELEASE/reference/html/ ② Config 服务端配置与测试1.用 你 自 己 的 账 号 在 Github 上 新 建 一 个 名 为 sprincloud-config 的新 Repository2.由上一步获得刚新建的 git 地址写你自己的仓库地址3.本地硬盘上新建 git 仓库并 clone 本地地址： D:\\44\\SpringCloud2020 git 命令： git clone xxx 4.此 时 在 本 地 D 盘 符 下 D:\\44\\SpringCloud2020\\springcloud-config 表示多个环境的配置文件,保存格式必须为 UTF-8,如果需要修改， 此处模拟运维人员操作 git 和 g 。 git add git commit -m “init yml” git push origin master 5.新建 Module 模块 cloud-config-center-3344 它既为 Cloud 的配置中心模块 cloudConfig Center POM 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;clould&lt;/artifactId&gt; &lt;groupId&gt;com.oy&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;cloud-config-center-3344&lt;/artifactId&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.oy&lt;/groupId&gt; &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; YML 12345678910111213141516171819202122server: port: 3344spring: application: name: cloud-config-center #注册进Eureka服务器的微服务名 cloud: config: server: git: uri: https://github.com/OY6090/sprincloud-config.git #GitHub上面的git仓库名字 ####搜索目录 search-paths: - springcloud-config ####读取分支 label: main#服务注册到eureka地址eureka: client: service-url: defaultZone: http://localhost:7001/eureka 主启动类 1234567@SpringBootApplication@EnableConfigServerpublic class ConfigCenterMain3344 &#123; public static void main(String[] args) &#123; SpringApplication.run(ConfigCenterMain3344.class, args); &#125;&#125; Windows 下修改 hosts 文件， 增加映射 路径：C:\\WINDOWS\\System32\\drivers\\etc 测试通过 Config 微服务是否可以从 Github 上获取配置内容 启动微服务 3344 http://config-3344.com:3344/main/config-dev.yml 6.读取配置规则 官网 /{label}/{application}-{profile}.yml（最推荐使用这种方式） main(maste) 分支 http://config-3344.com:3344/main/config-dev.yml http://config-3344.com:3344/main/config-test.yml http://config-3344.com:3344/main/config-prod.yml dev 分支 http://config-3344.com:3344/dev/config-dev.yml http://config-3344.com:3344/dev/config-test.yml http://config-3344.com:3344/dev/config-prod.yml /{application}-{profile}.yml http://config-3344.com:3344/config-dev.yml http://config-3344.com:3344/config-test.yml http://config-3344.com:3344/config-prod.yml http://config-3344.com:3344/config-xxxx.yml(不存在的配置) /{application}-{profile}[/{label}] http://config-3344.com:3344/config/dev/main http://config-3344.com:3344/config/test/main http://config-3344.com:3344/config/prod/main 重要配置细节总结 /{name}-{profiles}.yml /{label}-{name}-{profiles}.yml label:分支（branch） name:服务名 profiles：环境(dev/test/prod) 成功实现了用 SpringCloud Config 通过 GitHub 获取配置信息 ③ Config 客户端配置与测试1. 新建 cloud-config-client-33552.POM12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;clould&lt;/artifactId&gt; &lt;groupId&gt;com.oy&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;cloud-config-client-3355&lt;/artifactId&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.oy&lt;/groupId&gt; &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 3.bootstrap.yml 123456789101112131415161718server: port: 3355spring: application: name: config-client cloud: #Config客户端配置 config: label: main #分支名称 name: config #配置文件名称 profile: dev #读取后缀名称 上述3个综合：master分支上config-dev.yml的配置文件被读取http://config-3344.com:3344/master/config-dev.yml uri: http://localhost:3344 #配置中心地址k#服务注册到eureka地址eureka: client: service-url: defaultZone: http://localhost:7001/eureka 说明： 4.修改 config-dev.yml 配置并提交到 GitHub 中， 比如加个变量 age 或者版本号 version5.主启动123456@SpringBootApplicationpublic class ConfigClientMain3355 &#123; public static void main(String[] args) &#123; SpringApplication.run(ConfigClientMain3355.class, args); &#125;&#125; 6.业务类1234567891011@RestControllerpublic class ConfigClientController &#123; @Value(&quot;$&#123;config.info&#125;&quot;) private String configInfo; @GetMapping(&quot;/configInfo&quot;) public String getConfigInfo()&#123; return configInfo; &#125;&#125; 7.测试 启动 Config 配置中心 3344 微服务并自测 http://config-3344.com:3344/main/config-dev.yml http://config-3344.com:3344/main/config-test.yml 启动 3355 作为 Client 准备访问 http://localhost:3355/configInfo 8.成功实现了客户端 3355 访问 SpringCloud Config3344 通过 GitHub 获取配置信息9.问题随之而来， 分布式配置的动态刷新 Linux 运维修改 GitHub 上的配置文件内容做调整 刷新 3344， 发现 ConfigServer 配置中心立刻响应 刷新 3355， 发现 ConfigServer 客户端没有任何响应 3355 没有变化除非自己重启或者重新加载 难道每次运维修改配置文件， 客户端都需要重启？ ？ 噩梦 ④ Config 客户端之动态刷新1.避免每次更新配置都要重启2.动态刷新 修改 3355 模块， POM 文件引入 actuator 监控 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt; 修改 YML， 暴露监控端口 1234567891011121314151617181920212223server: port: 3355spring: application: name: config-client cloud: #Config客户端配置 config: label: main #分支名称 name: config #配置文件名称 profile: dev #读取后缀名称 上述3个综合：master分支上config-dev.yml的配置文件被读取http://config-3344.com:3344/master/config-dev.yml uri: http://localhost:3344 #配置中心地址k#服务注册到eureka地址eureka: client: service-url: defaultZone: http://localhost:7001/eurekamanagement: endpoints: web: exposure: include: &quot;*&quot; @RefreshScope 业务类 Controller 修改 123456789101112@RestController@RefreshScopepublic class ConfigClientController &#123; @Value(&quot;$&#123;config.info&#125;&quot;) private String configInfo; @GetMapping(&quot;/configInfo&quot;) public String getConfigInfo() &#123; return configInfo; &#125;&#125; 此时修改 github—&gt; 3344 —&gt; 3355 http://localhost:3355/configInfo 3355 改变了没有？ ？ ？ 没有改变， (┬＿┬) 需要运维人员发送 Post 请求刷新 3355 必 须 是 Post 请 求 ： curl -X POST “http://localhost:3355/actuator/refresh&quot; 再次： http://localhost:3355/configInfo ,成功实现了客户端 3355 刷新到最新配置内容,避免了服务的重启 3.想想还有什么问题？​ 假如有多个微服务客户端 3355/3366/3377。。。。每个微服务都要执行一次 post 请求， 手动刷新？可否广播， 一次通知， 处处生效？我们想大范围的自动刷新， 求方法———–结合消息总线 Bus 解决以上问题 。 ​ 具体请参考下篇博客：SpringCloud Bus 消息总线: https://oy6090.top/2020/1020272460835.html","categories":[{"name":"JavaEE框架","slug":"JavaEE框架","permalink":"http://blog.oy6090.top/categories/JavaEE%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"java","slug":"java","permalink":"http://blog.oy6090.top/tags/java/"},{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://blog.oy6090.top/tags/SpringCloud/"}]},{"title":"SpringCloud 服务网关","slug":"SpringCloud 服务网关","date":"2020-10-17T16:00:00.000Z","updated":"2021-01-22T03:52:49.469Z","comments":true,"path":"posts/3556927238.html","link":"","permalink":"http://blog.oy6090.top/posts/3556927238.html","excerpt":"","text":"博客学习参考视频 GateWay 新网关① 概述简介1.官网 上一代网关 zuul 1.X：https://github.com/Netflix/zuul/wiki 当 前 网 关 gateway ：https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.2.1.RELEASE/reference/html/ 2.是什么概述： 一句话： SpringCloud Getaway 使用的 Webflux 中的 reactor-netty 响应式编程组件，底层使用的 Netty 通讯框架 源码框架 3.能干嘛 反向代理 鉴权 浏览控制 熔断 日志监控 …. 4.微服务架构中网关在哪里 5.有了 Zuul 了怎么又出来了 gateway 我们为什么选择 Gatway? neflix 不太靠谱， zuul2.0 一直跳票,迟迟不发布 SpringCloud Gateway 具有如下特性 SpringCloud Gateway 与 Zuul 的区别 Zuul1.x 模型 GateWay 模型 WebFlux 是什么 ② 三大核心概念1.Route(路由)​ 路由的构建网关的基本模块，它由 ID ，目标 URI ， 一系列的断言和过滤器组成，如果断言为 true 则匹配该路由 2. Predicate(断言)​ 参考的是 java8 的 java.util.function.Predicate 开发人员可以匹配 HTTP 请求中的所有内容（例如请求头或请求参数），如果请求域断言相匹配则进行路由。 3. Filter(过滤)​ 指的是 Spring 框架中 GatewayFilter 的实例，使用过滤器，可以在请求被路由前或者之后对请求进行修改。 4. 总体 ③ Gateway 工作流程1.官网总结 2.核心逻辑​ 路由转发+执行过滤器链 ④ 入门配置 新建 Module: cloud-gateway-gateway9527 POM 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;clould&lt;/artifactId&gt; &lt;groupId&gt;com.oy&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;cloud-gateway-gateway9527&lt;/artifactId&gt; &lt;dependencies&gt; &lt;!--新增 gateway--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.oy&lt;/groupId&gt; &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; YML 12345678910111213server: port: 9527spring: application: name: cloud-gatewayeureka: instance: hostname: cloud-gateway-service client: #服务提供者provider注册进eureka服务列表中 service-url: register-with-eureka: true fetch-registry: true defaultZone: http://eureka7001.com:7001/eureka 业务类 （无） 主启动类 1234567@SpringBootApplication@EnableEurekaClientpublic class GateWayMain9527 &#123; public static void main(String[] args) &#123; SpringApplication.run(GateWayMain9527.class, args); &#125;&#125; **9527 网关如何做路由映射那？ ？ ？ ** cloud-provider-payment8001 看看 controller 的访问地址 get lb 我们目前不想暴露 8001 端口，希望在 8001 外面套一层 9527 YML 新增网关配置 123456789101112131415161718192021222324252627server: port: 9527spring: application: name: cloud-gateway cloud: gateway: discovery: locator: enabled: true # 开启从注册中心动态创建路由的功能，利用微服务名称j进行路由 routes: - id: payment_route # 路由的id,没有规定规则但要求唯一,建议配合服务名 #匹配后提供服务的路由地址 uri: http://localhost:8001 predicates: - Path=/payment/get/** # 断言，路径相匹配的进行路由 - id: payment_route2 uri: http://localhost:8001 predicates: Path=/payment/lb/** #断言,路径相匹配的进行路由eureka: instance: hostname: cloud-gateway-service client: #服务提供者provider注册进eureka服务列表中 service-url: register-with-eureka: true fetch-registry: true defaultZone: http://eureka7001.com:7001/eureka 测试 启动 7001 启动 8001： cloud-provider-payment8001 启动 8001： cloud-provider-payment8001 访问说明 添加网关前： http://localhost:8001/payment/get/1 添加网关后： http://localhost:9527/payment/get/1 YML 配置说明 Gateway 网关路由有两种配置方式 在配置文件 yml 中配置 (见前面步骤) 代码中注入 RouteLocator 的 Bean 官网案例 ： 自己写一个：业 务 需 求 ： 通 过 9527 网 关 访 问 到 外 网 的 百 度 新 闻 网 址 http://news.baidu.com/guoji 123456789101112131415161718192021222324/** * 配置网关 * @Author OY * @Date 2020/10/18 */@Configurationpublic class GateWayConfig &#123; @Bean public RouteLocator customRouteLocator(RouteLocatorBuilder routeLocatorBuilder)&#123; RouteLocatorBuilder.Builder routes = routeLocatorBuilder.routes(); routes.route(&quot;path_rote_oy&quot;, r -&gt; r.path(&quot;/guonei&quot;).uri(&quot;http://news.baidu.com/guonei&quot;)).build(); return routes.build(); &#125; @Bean public RouteLocator customRouteLocator2(RouteLocatorBuilder routeLocatorBuilder)&#123; RouteLocatorBuilder.Builder routes = routeLocatorBuilder.routes(); routes.route(&quot;path_rote_oy2&quot;, r -&gt; r.path(&quot;/guoji&quot;).uri(&quot;http://news.baidu.com/guoji&quot;)).build(); return routes.build(); &#125;&#125; 测试： ⑤ 通过服务名实现动态​ 默认情况下 Gateway 会根据注册中心的服务列表，以注册中心上微服务名为路径路径创建动态路由创建动态路由进行转发，从而实现动态路由的功能 启动： 一个 eureka7001 + 两个服务提供者 8001/8002 POM YML: uri: lb//cloud-payment-service 1234567891011121314151617181920212223242526272829server: port: 9527spring: application: name: cloud-gateway cloud: gateway: discovery: locator: enabled: true # 开启从注册中心动态创建路由的功能，利用微服务名称j进行路由 routes: - id: payment_route # 路由的id,没有规定规则但要求唯一,建议配合服务名 #匹配后提供服务的路由地址 #uri: http://localhost:8001 uri: lb//cloud-payment-service predicates: - Path=/payment/get/** # 断言，路径相匹配的进行路由 - id: payment_route2 #uri: http://localhost:8001 uri: lb//cloud-payment-service predicates: Path=/payment/lb/** #断言,路径相匹配的进行路由eureka: instance: hostname: cloud-gateway-service client: #服务提供者provider注册进eureka服务列表中 service-url: register-with-eureka: true fetch-registry: true defaultZone: http://eureka7001.com:7001/eureka 需要注意的是uri 的协议为 lb ，表示启用 Gateway 负载均衡功能。 lb ://serviceName 是 spring cloud gateway 在微服务中自动为我们创建负载均衡 uri。 测试： ​ http://localhost:9527/payment/lb： 8001/8002 两个端口切换 ⑥ Predicate 的使用1.是什么启动我们的 gateway9527 2.Route Predicate Factories 是什么? 3.常用的 Route Predicate After Route Predicate 问题一：上述这个 After 好懂，这个时间时间串串，有点不能理解。使用以下方式即可解开谜团。 12345678@Testpublic void test1()&#123; ZonedDateTime zbj = ZonedDateTime.now(); // 默认时区 System.out.println(zbj); // 2020-10-18T10:35:52.127+08:00[Asia/Shanghai] ZonedDateTime zny = ZonedDateTime.now(ZoneId.of(&quot;America/Denver&quot;));// 用指定时区获取当前时间 System.out.println(zny); // 2020-10-17T20:38:37.693-06:00[America/Denver]&#125; YML 1- After=2020-10-18T10:38:37.692+08:00[Asia/Shanghai] Before Route Predicate YML 12- After=2020-10-18T10:38:37.692+08:00[Asia/Shanghai]- Before=2020-10-18T10:38:37.692+08:00[Asia/Shanghai] Between Route Predicate YML 1- Between=2020-10-18T10:38:37.692+08:00[Asia/Shanghai],2020-10-19T10:38:37.692+08:00[Asia/Shanghai] Cookie Route Predicate 1) 不带 cookies 访问 2) 带上 cookies 访问 加 入 curl 返 回 中 文 乱 码 ：https://blog.csdn.net/leedee/article/details/82685636 1curl http://localhost:9527/payment/lb --cookie &quot;username=oy&quot; 3）YML 1- Cookie=username,oy #并且Cookie是username=oy才能访问 Header Route Predicate YML 1- Header=X-Request-Id, \\d+ #请求头中要有X-Request-Id属性并且值为整数的正则表达式 Host Route Predicate YML 1- Host=**.somehost.org,**.anotherhost.org Method Route Predicate YML 1- Method=GET,POST Path Route Predicate YML 1- Path=/red/&#123;segment&#125;,/blue/&#123;segment&#125; Query Route Predicate YML 1- Query=username, \\d+ #要有参数名称并且是正整数才能路由 测试： http://localhost:9527/payment/lb?username=1 小总结 All ​ 说白了,Predicate就是为了实现一组匹配规则, 让请求过来找到对应的Route进行处理 ⑦ Filter 的使用1.是什么 2.Spring Cloud Gateway 的 Filter 生命周期， Only Two Pre : 在业务逻辑之前 Post: 在业务逻辑之后 种类： Only Two GatewayFilter： 单一 GlobalFilter: 全局 3.常用的 GatewayFilter AddRequestParameter YML 4.自定义过滤器 自定义全局 GlobalFilter 两个主要接口介绍 1impiemerts GlobalFilter ， Ordered 能干嘛 全局日志记录 统一网关鉴权 …… 案例代码 1234567891011121314151617181920@Component@Slf4jpublic class MyLogGateWayFilter implements GlobalFilter, Ordered &#123; @Override public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) &#123; log.info(&quot;*********come in MyLogGateWayFilter: &quot;+new Date()); String username = exchange.getRequest().getQueryParams().getFirst(&quot;username&quot;); if(username == null)&#123; log.info(&quot;*****用户名为 NUll 非法用户.(┬＿┬)&quot;); exchange.getResponse().setStatusCode(HttpStatus.NOT_ACCEPTABLE);// 给人家一个回应 return exchange.getResponse().setComplete(); &#125; return chain.filter(exchange); &#125; @Override public int getOrder() &#123; return 0; &#125;&#125; 测试 启动 正确： http://localhost:9527/payment/lb?username=1 错误 ： http://localhost:9527/payment/lb?usernameaa=1","categories":[{"name":"JavaEE框架","slug":"JavaEE框架","permalink":"http://blog.oy6090.top/categories/JavaEE%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"java","slug":"java","permalink":"http://blog.oy6090.top/tags/java/"},{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://blog.oy6090.top/tags/SpringCloud/"}]},{"title":"SpringCloud 服务降级","slug":"SpringCloud 服务降级","date":"2020-10-15T16:00:00.000Z","updated":"2020-10-25T02:33:19.635Z","comments":true,"path":"posts/2164673978.html","link":"","permalink":"http://blog.oy6090.top/posts/2164673978.html","excerpt":"","text":"博客学习参考视频 一、Hystrix 断路器① 概述1.分布式系统面临的问题 2.是什么 3.能干嘛 服务降级 服务熔断 接近实时的监控 4.官 网 资 料​ https://github.com/Netflix/Hystrix/wiki/How-To-Use 5.Hystrix 官宣，停更进维​ https://github.com/Netflix/Hystrix 不在修复 Bug 不在接收合并请求 不在发布新版本 ② Hystrix 重要概念1.服务降级服务器忙， 请稍候再试， 不让客户端等待并立刻返回一个友好提示， fallback 哪些情况会触发降级： 1 程序运行异常、 2 超时、 3 服务熔断触发服务降级 、4 线程池/信号量打满也会导致服务降级 2.服务熔断​ 类比保险丝达到最大服务访问后， 直接拒绝访问， 拉闸限电， 然后调用服务降级的方法并返回友好提示，就是保险丝。 ​ 服务的降级-&gt;进而熔断-&gt;恢复调用链路 3.服务限流​ 秒杀高并发等操作， 严禁一窝蜂的过来拥挤， 大家排队， 一秒钟 N 个， 有序进行 ③ hystrix 案例1.构建 新建 cloud-provider-hystrix-payment8001 POM 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;clould&lt;/artifactId&gt; &lt;groupId&gt;com.oy&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;cloud-provider-hystrix-payment8001&lt;/artifactId&gt; &lt;dependencies&gt; &lt;!--新增 hystrix--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.oy&lt;/groupId&gt; &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; YML 12345678server: port: 8001eureka: client: register-with-eureka: true #表示不向注册中心注册自己 fetch-registry: true #表名自己就是注册中心，职责维护服务实例，并不需要去检索服务 service-url: defaultZone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka 主启动类 1234567@SpringBootApplication@EnableEurekaClientpublic class PaymentHystrixMain8001 &#123; public static void main(String[] args) &#123; SpringApplication.run(PaymentHystrixMain8001.class, args); &#125;&#125; 业务类 ​ Service 123456789101112131415161718192021@Servicepublic class PaymentService &#123; // 成功 public String paymentInfo_OK(Integer id)&#123; return &quot;线程池：&quot; + Thread.currentThread().getName() + &quot;paymentInfo_OK,id:&quot;+id+&quot;\\t&quot;+&quot;O(∩_∩)O哈哈~&quot;; &#125; // 失败 public String paymentInfo_TimeOut(Integer id)&#123; int timeNumber = 3; try &#123; TimeUnit.SECONDS.sleep(timeNumber); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; return &quot;线程池：&quot; + Thread.currentThread().getName()+ &quot;paymentInfo_TimeOut,id:&quot; + id +&quot;\\t&quot; +&quot;┭┮﹏┭┮&quot;+&quot;耗时(秒)&quot; + timeNumber; &#125;&#125; Controller 12345678910111213141516171819202122232425@RestController@Slf4jpublic class PaymentController &#123; @Resource private PaymentService paymentService; @Value(&quot;$&#123;server.port&#125;&quot;) private String serverPort; @GetMapping(value = &quot;/payment/hystrix/ok/&#123;id&#125;&quot;) public String paymentInfo_OK(@PathVariable(&quot;id&quot;) Integer id)&#123; String result = paymentService.paymentInfo_OK(id); log.info(&quot;*************result:&quot; + result); return result; &#125; @GetMapping(value = &quot;/payment/hystrix/timeout/&#123;id&#125;&quot;) public String paymentInfo_TimeOut(@PathVariable(&quot;id&quot;) Integer id)&#123; String result = paymentService.paymentInfo_TimeOut(id); log.info(&quot;******result:&quot; + result); return result; &#125;&#125; 测试： 先启动 eureka 7001, 启动 cloud-provider-hystrix-payment8001 访问： http://localhost:8001/payment/hystrix/ok/1 在测试访问：http://localhost:8001/payment/hystrix/timeout/1，每 次 调 用 耗 费 3 秒 钟 上述 module 均 OK，以上述为根基平台，从正确-&gt;错误-&gt;降级熔断-&gt;恢复 2.高并发测试 Jmeter 压测测试 ​ 开 启 Jmeter ， 来 20000 个 并 发 压 死 8001 ， 20000 个 请 求 都 去 访 问 paymentInfo_TimeOut 服务。 再来一个访问：http://localhost:8001/payment/hystrix/ok/1， http://localhost:8001/payment/hystrix/timeout/1 看演示结果： 两个都在自己转圈圈 为什么会被卡死： tomcat 的默认的工作线程数被打满了。没有多余的线程来分解压力和处理 3.Jmeter 压测结论​ 上面还是服务提供者 8001 自己测试， 假如此时外部的消费者 80 也来访问，那消费者只能干等， 最终导致消费端 80 不满意， 服务端 8001 直接被拖死 4.看热闹不嫌弃事大， 80 新建加入 新建 cloud-consumer-feign-hystrix-order80 POM 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;clould&lt;/artifactId&gt; &lt;groupId&gt;com.oy&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;cloud-consumer-feign-hystrix-order80&lt;/artifactId&gt; &lt;dependencies&gt; &lt;!--新增 hystrix--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.oy&lt;/groupId&gt; &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; YML 12345678server: port: 80eureka: client: register-with-eureka: true fetch-registry: true service-url: defaultZone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka 主启动类 1234567@SpringBootApplication@EnableEurekaClientpublic class PaymentHystrixMain8001 &#123; public static void main(String[] args) &#123; SpringApplication.run(PaymentHystrixMain8001.class, args); &#125;&#125; 业务类 PaymentHystrixService 123456789101112131415161718192021222324252627282930313233package com.oy.springcloud.service;import org.springframework.cloud.openfeign.FeignClient;import org.springframework.stereotype.Component;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;/** * @Author OY * @Date 2020/10/16 */@Component@FeignClient(value = &quot;CLOUD-PROVIDER-HYSTRIX-PAYMENT&quot;)public interface PaymentHystrixService &#123; /** * 正常访问 * * @param id * @return */ @GetMapping(&quot;/payment/hystrix/ok/&#123;id&#125;&quot;) public String paymentInfo_OK(@PathVariable(&quot;id&quot;) Integer id); /** * 超时访问 * * @param id * @return */ @GetMapping(&quot;/payment/hystrix/timeout/&#123;id&#125;&quot;) public String paymentInfo_TimeOut(@PathVariable(&quot;id&quot;) Integer id);&#125; Controller 12345678910111213141516171819202122232425262728293031323334@RestController@Slf4jpublic class OrderHyrixController &#123; @Resource private PaymentHystrixService paymentHystrixService; /** * 正常访问 * * @param id * @return */ @GetMapping(&quot;/consumer/payment/hystrix/ok/&#123;id&#125;&quot;) public String paymentInfo_OK(@PathVariable(&quot;id&quot;) Integer id) &#123; String result = paymentHystrixService.paymentInfo_OK(id); log.info(&quot;*****result:&quot; + result); return result; &#125; /** * 超时访问 * * @param id * @return */ @GetMapping(&quot;/consumer/payment/hystrix/timeout/&#123;id&#125;&quot;) public String paymentInfo_TimeOut(@PathVariable(&quot;id&quot;) Integer id) &#123; String result = paymentHystrixService.paymentInfo_TimeOut(id); log.info(&quot;*****result:&quot; + result); return result; &#125;&#125; 正常测试 http://localhost/consumer/payment/hystrix/ok/1 http://localhost/consumer/payment/hystrix/timeout/1 注意：测试这个时有可能会报超时错误，如果出现错误只需要在配置文件中配置 12345ribbon: # 指的是建立连接所用的时间,适用于网络状态正常的情况下,两端连接所用的时间 ReadTimeout: 5000 # 指的是建立连接后从服务器读取到可用资源所用的时间 ConnectTimeout: 5000 高并发测试 2W 个线程压 8001，消费端 80 微服务再去访问正常的 OK 微服务 8001 地址 http://localhost/consumer/payment/hystrix/timeout/1 ​ 消费者 80， 要么转圈圈等待、 要么消费端报超时错误 5.故障现象和导致原因 8001 同一层次的接口服务被困死，因为 tomcat 线程里面的工作线程已经被挤占完毕 80 此时调用 8001，客户端访问的响应缓慢，转圈圈 6.上诉结论​ 正因为有上述故障或不佳表现， 才有我们的降级/容错/限流等技术诞生 7.如何解决？解决的要求 超时导致服务器变慢（转圈） ： 超时不再等待 出错（宕机或程序运行出错） ： 出错要有兜底 解决： 对方服务（8001） 超时了， 调用者（80） 不能一直卡死等待，必须有服务降级。 对方服务（8001） down 机了， 调用者（80） 不能一直卡死等待， 必须有服务降级。 对方服务（8001） OK， 调用者（80） 自己出故障或有自我要求（自己的等待时间小于服务提供者） ， 自己处理降级 ④ 服务降级1.降低配置： @HystrixCommand2.8001 先从自身找问题​ 置自身调用超时时间的峰值，峰值内可以正常运行，超过了需要有兜底的方法处理，做服务降级 fallback 3.8001fallback 业务类启用 12345678910111213141516171819202122232425262728293031@Servicepublic class PaymentService &#123; // 成功 public String paymentInfo_OK(Integer id)&#123; return &quot;线程池：&quot; + Thread.currentThread().getName() + &quot;paymentInfo_OK,id:&quot;+id+&quot;\\t&quot;+&quot;O(∩_∩)O哈哈~&quot;; &#125; /** * 超时访问，演示降级 * @param id * @return */ @HystrixCommand(fallbackMethod = &quot;paymentInfo_TimeOutHandler&quot;, commandProperties = &#123; @HystrixProperty(name =&quot;execution.isolation.thread.timeoutInMilliseconds&quot;,value=&quot;3000&quot;) &#125;) public String paymentInfo_TimeOut(Integer id)&#123; int timeNumber = 5; try &#123; TimeUnit.SECONDS.sleep(timeNumber); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; return &quot;线程池：&quot; + Thread.currentThread().getName()+ &quot;paymentInfo_TimeOut,id:&quot; + id +&quot;\\t&quot; +&quot;┭┮﹏┭┮&quot;+&quot;耗时(秒)&quot; + timeNumber; &#125; public String paymentInfo_TimeOutHandler(Integer id)&#123; return &quot;o(╥﹏╥)o 调用支付接口超时异常：\\t&quot; + &quot;\\t当前线程池名字：&quot; + Thread.currentThread().getName(); &#125;&#125; @HystrixCommand报异常后如何处理 一旦调用服务方法失败并抛出了错误信息后,会自动调用@HystrixCommand标注好的fallbckMethod调用类中的指定方法 图示： 主启动类激活： 添加新注解**@EnableCircuitBreaker** 12345678@SpringBootApplication@EnableEurekaClient@EnableCircuitBreakerpublic class PaymentHystrixMain8001 &#123; public static void main(String[] args) &#123; SpringApplication.run(PaymentHystrixMain8001.class, args); &#125;&#125; 4.80fallback80 订单微服务， 也可以更好的保护自己， 自己也依样画葫芦进行客户端降级保护。 题外话 切记我 们 自 己 配 置 过 的 热 部 署 方 式 对 java 代 码 的 改 动 明 显 ， 但对@HystrixCommand 内属性的修改建议重启微服务 YML 123feign: hystrix: enabled: true # 如果处理自身的容错就开启。开启方式与生产端不一样。 主启动： @EnableHystrix 123456789@SpringBootApplication@EnableEurekaClient@EnableFeignClients@EnableHystrixpublic class OrderHystrixMain80 &#123; public static void main(String[] args) &#123; SpringApplication.run(OrderHystrixMain80.class, args); &#125;&#125; 业务类 12345678910111213@GetMapping(&quot;/consumer/payment/hystrix/timeout/&#123;id&#125;&quot;)@HystrixCommand(fallbackMethod = &quot;paymentTimeOutFallbackMethod&quot;,commandProperties = &#123; @HystrixProperty(name=&quot;execution.isolation.thread.timeoutInMilliseconds&quot;,value = &quot;15000&quot;)&#125;)public String paymentInfo_TimeOut(@PathVariable(&quot;id&quot;) Integer id) &#123; String result = paymentHystrixService.paymentInfo_TimeOut(id); log.info(&quot;*****result:&quot; + result); return result;&#125;public String paymentTimeOutFallbackMethod(@PathVariable(&quot;id&quot;) Integer id)&#123; return &quot;我是消费者80,对方支付系统繁忙请10秒钟后再试或者自己运行出错请检查自己，o(╥﹏╥)o&quot;;&#125; 5.目前方法 每个业务方法对应一个兜底的方法，代码膨胀 统一和自定义的需要分开 6.解决问题 每个方法配置一个？ ？ ？ 膨胀 feign 接口系列 @DefaultProperties(defaultFallback = “”) 说明： controller 配置 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849@RestController@Slf4j@DefaultProperties(defaultFallback = &quot;payment_Global_FallbackMethod&quot;)public class OrderHyrixController &#123; @Resource private PaymentHystrixService paymentHystrixService; /** * 正常访问 * * @param id * @return */ @GetMapping(&quot;/consumer/payment/hystrix/ok/&#123;id&#125;&quot;) public String paymentInfo_OK(@PathVariable(&quot;id&quot;) Integer id) &#123; String result = paymentHystrixService.paymentInfo_OK(id); log.info(&quot;*****result:&quot; + result); return result; &#125; /** * 超时访问 * * @param id * @return */ @GetMapping(&quot;/consumer/payment/hystrix/timeout/&#123;id&#125;&quot;) @HystrixCommand public String paymentInfo_TimeOut(@PathVariable(&quot;id&quot;) Integer id) &#123; String result = paymentHystrixService.paymentInfo_TimeOut(id); log.info(&quot;*****result:&quot; + result); return result; &#125; // 兜底方法 public String paymentTimeOutFallbackMethod(@PathVariable(&quot;id&quot;) Integer id)&#123; return &quot;我是消费者80,对方支付系统繁忙请10秒钟后再试或者自己运行出错请检查自己，o(╥﹏╥)o&quot;; &#125; /** * 全局fallback * @return */ public String payment_Global_FallbackMethod() &#123; return &quot;Global异常处理信息,请稍后重试.o(╥﹏╥)o&quot;; &#125;&#125; **和业务逻辑混一起？ ？ ？ 混乱 ** 服务降级，客户端去调用服务端，碰上服务器宕机或关闭 本次案例服务案例级处理是在客户端 80 实现完成的，与服务端 8001 没有关系，只需要为 Feign 客户端定义的接口添加一个服务降级处理的实现类即可实现解耦。 未来我们要面对的异常 运行、超时、宕机 再看我们的业务类 PaymentController 修改 cloud-consumer-feign-hystrix-order80 根 据 cloud-consumer-feign-hystrix-order80 已 经 有 的 PaymentHystrixService 接 口 ， 重 新 新 建 一 个 类（PaymentFallbackService） 实现该接口， 统一为接口里面的方法进行异常处理 。 PaymentFallbackService 类 实 现 PaymentFeignClientService 接口 123456789101112@Componentpublic class PaymentFallbackService implements PaymentHystrixService&#123; @Override public String paymentInfo_OK(Integer id) &#123; return &quot;-----PaymentFallbackService fall back-paymentInfo_OK , (┬＿┬)&quot;; &#125; @Override public String paymentInfo_TimeOut(Integer id) &#123; return &quot;-----PaymentFallbackService fall back-paymentInfo_TimeOut , (┬ ＿┬)&quot;; &#125;&#125; YML 123feign: hystrix: enabled: true # 如果处理自身的容错就开启。开启方式与生产端不一样。 PaymentFeignClientService 接口 12345678910111213141516171819202122@Component@FeignClient(value = &quot;CLOUD-PROVIDER-HYSTRIX-PAYMENT&quot;,fallback = PaymentFallbackService.class)public interface PaymentHystrixService &#123; /** * 正常访问 * * @param id * @return */ @GetMapping(&quot;/payment/hystrix/ok/&#123;id&#125;&quot;) public String paymentInfo_OK(@PathVariable(&quot;id&quot;) Integer id); /** * 超时访问 * * @param id * @return */ @GetMapping(&quot;/payment/hystrix/timeout/&#123;id&#125;&quot;) public String paymentInfo_TimeOut(@PathVariable(&quot;id&quot;) Integer id);&#125; 测试 单个 eureka 先启动 7001，PaymentHystrixMain8001 启动 正常测试： http://localhost/consumer/payment/hystrix/ok/1 故意关闭微服务 8001 ​ 客户端自己调用提升： 此时服务端 provider 已经 down 了， 但是我们做了服务降级处理， 让客户端在服务端不可用时也会获得提示信息而不会挂起耗死服务器 。 ⑤ 服务熔断1.断路器​ 一句话就是家里保险丝 2.熔断是什么 大神论文：https://martinfowler.com/bliki/CircuitBreaker.html 3.实操 修改 cloud-provider-hystrix-payment8001 PaymentService 123456789101112131415161718 @HystrixCommand(fallbackMethod = &quot;paymentCircuitBreaker_fallback&quot;,commandProperties = &#123; @HystrixProperty(name = &quot;circuitBreaker.enabled&quot;,value = &quot;true&quot;), //是否开启断路器 @HystrixProperty(name = &quot;circuitBreaker.requestVolumeThreshold&quot;,value = &quot;10&quot;), //请求次数 @HystrixProperty(name = &quot;circuitBreaker.sleepWindowInMilliseconds&quot;,value = &quot;10000&quot;), //时间范围 @HystrixProperty(name = &quot;circuitBreaker.errorThresholdPercentage&quot;,value = &quot;60&quot;), //失败率达到多少后跳闸 &#125;)public String paymentCircuitBreaker(@PathVariable(&quot;id&quot;) Integer id)&#123; if (id &lt; 0)&#123; throw new RuntimeException(&quot;*****id 不能负数&quot;); &#125; String serialNumber = IdUtil.simpleUUID(); return Thread.currentThread().getName()+&quot;\\t&quot;+&quot;调用成功,流水号： &quot;+serialNumber;&#125;public String paymentCircuitBreaker_fallback(@PathVariable(&quot;id&quot;) Integer id)&#123; return &quot;id 不能负数， 请稍候再试,(┬＿┬)/~~ id: &quot; +id;&#125; why 配置这些参数： PaymentController 123456@GetMapping(&quot;/payment/circuit/&#123;id&#125;&quot;)public String paymentCircuitBreaker(@PathVariable(&quot;id&quot;) Integer id)&#123; String result = paymentService.paymentCircuitBreaker(id); log.info(&quot;*******result:&quot;+result); return result;&#125; 测试 自测 cloud-provider-hystrix-payment8001 正确： http://localhost:8001/payment/circuit/1 错误： http://localhost:8001/payment/circuit/-1 一次正确一次错误 trytry 重点测试： 多次错误,然后慢慢正确， 发现刚开始不满足条件，就算是正确的访问地址也不能进行访问， 需要慢慢的恢复链路 4.原理（小总结） 大神结论 熔断类型 熔断打开 请求不再进行调用当前服务， 内部设置时钟一般为 MTTR(平均故障处理时间)，当打开时长达到所设时钟则进入熔断状态 。 熔断关闭 熔断关闭不会对服务进行熔断。 熔断半开 部分请求根据规则调用当前服务， 如果请求成功且符合规则则认为当前服务恢复正常， 关闭熔断 。 官网断路器流程图 官网步骤 断路器在什么情况下开始起作用 断路器开启或者关闭的条件 当满足一定阀值的时候（默认 10 秒内超过 20 个请求次数） 当失败率达到一定的时候（默认 10 秒内超过 50%请求失败） 到达以上阀值， 断路器将会开启 当开启的时候， 所有请求都不会进行转发 一段时间之后（默认是 5 秒）， 这个时候断路器是半开状态， 会让其中一个请求进行转发。 如果成功， 断路器会关闭， 若失败， 继续开启。 重复 4 和 5 。 断路器打开之后 All 配置 ⑥ 服务限流 参考我后面的关于高级篇的 alibaba 的 Sentinel 说明 ⑦ hystrix 工作流程1.hystrix 工作流程​ https://github.com/Netflix/Hystrix/wiki/How-it-Works 2.hystrix 工作流程**官网图例 : ** 步骤说明: ⑧ 服务监控 hystrixDashboard1.概述 2.仪表盘 9001 新建 cloud-consumer-hystrix-dashboard9001 POM 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;clould&lt;/artifactId&gt; &lt;groupId&gt;com.oy&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;cloud-consumer-hystrix-dashboard9001&lt;/artifactId&gt; &lt;dependencies&gt;&lt;!--新增 hystrix dashboard--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix-dashboard&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; YML 12server: port: 9001 HystrixDashboardMain9001+新注解**@EnableHystrixDashboard** 1234567@SpringBootApplication@EnableHystrixDashboardpublic class HystrixDashboardMain9001 &#123; public static void main(String[] args) &#123; SpringApplication.run(HystrixDashboardMain9001.class, args); &#125;&#125; 所有 Provider 微服务提供类（8001/8002/8003） 都需要监控依赖配置 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt; 启动 cloud-consumer-hystrix-dashboard9001 该微服务后续将监控微服务 8001 ​ http://localhost:9001/hystrix 3.断路器演示(服务监控 hystrixDashboard) 修改 cloud-provider-hystrix-payment8001 注意:新版本 Hystrix 需要在主启动 PaymentHystrixMain8001 中指定监控路径 123456789101112131415/** * 此配置是为了服务监控而配置，与服务容错本身无观，springCloud 升级之后的坑 * ServletRegistrationBean因为springboot的默认路径不是/hystrix.stream * 只要在自己的项目中配置上下面的servlet即可 * @return */@Beanpublic ServletRegistrationBean getServlet()&#123; HystrixMetricsStreamServlet streamServlet = new HystrixMetricsStreamServlet(); ServletRegistrationBean&lt;HystrixMetricsStreamServlet&gt; registrationBean = new ServletRegistrationBean&lt;&gt;(streamServlet); registrationBean.setLoadOnStartup(1); registrationBean.addUrlMappings(&quot;/hystrix.stream&quot;); registrationBean.setName(&quot;HystrixMetricsStreamServlet&quot;); return registrationBean;&#125; Unable to connect to Command Metric Stream. 404 监控测试 启动 1 个 eureka 或者 3 个 eureka 集群均可 观察监控窗口 9001 监控 8001 填写监控地址： http://localhost:8001/hystrix.stream 测试地址： http://localhost:8001/payment/circuit/1、http://localhost:8001/payment/circuit/1 上述测试通过： ok 先访问正确地址， 再访问错误地址， 再正确地址， 会发现图示断路器都，是慢慢放开的 。 监控结果，成功 监控结果， 失败 如何看： 7 色 1 圈 1 线 整图说明 整图说明 2 搞懂一个才能看懂复杂的","categories":[{"name":"JavaEE框架","slug":"JavaEE框架","permalink":"http://blog.oy6090.top/categories/JavaEE%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"java","slug":"java","permalink":"http://blog.oy6090.top/tags/java/"},{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://blog.oy6090.top/tags/SpringCloud/"}]},{"title":"SpringCloud 服务注册与发现","slug":"SpringCloud服务注册与发现","date":"2020-10-11T16:00:00.000Z","updated":"2020-10-25T02:33:45.948Z","comments":true,"path":"posts/368886813.html","link":"","permalink":"http://blog.oy6090.top/posts/368886813.html","excerpt":"","text":"本篇博客参考学习视频 一、Eureka 服务注册与发现① Eureka 基础知识1. 服务治理​ SpringCloud 封装了 Netflix 公司开发的 Eureka 模块来实现服务治理。 在传统的 RPC 远程调用框架中， 管理每个服务与服务之间依赖关系比较复杂， 所以需要使用服务治理管理服务与服务之间依赖关系， 了以实现服务调用、 负载均衡、容错等， 实现服务发现与注册 。 2. 服务注册 3.Eureka 两组件 ② 单机 Eureka 构建步骤1.IDEA 生成 EurekaServer 端服务注册中心 类似物业公司 建 Module 改 POM 12345678910111213141516171819202122232425262728293031323334353637&lt;dependencies&gt; &lt;!--eureka-server--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.atguigu.springcloud&lt;/groupId&gt; &lt;artifactId&gt;cloud-api-common&lt;/artifactId&gt; &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--一般为通用配置--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 1.X 和 2.X 的对比说明 写 YML 1234567891011server: port: 7001eureka: instance: hostname: localhost #eureka服务端的实例名称 client: register-with-eureka: false #false表示不向注册中心注册自己。 fetch-registry: false #false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务 service-url: defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/ 主启动 1234567@SpringBootApplication@EnableEurekaServerpublic class EurekaMain7001 &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaMain7001.class, args); &#125;&#125; 注意：需要在启动类上配置注解 @EnableEurekaServer,开启注册中心 测试 http://localhost:7001/ ，效果页面 2.EurekaClient 端 cloud-provider-payment8001 将注册进 EurekaServer 成为服务提供者 provider 改 POM ( cloud-provider-payment8001) 12345&lt;!--https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-eureka-server --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt; 1.X 和 2.X 的对比说明 写 YML 12345678eureka: client: # 表示是否将自己注册进eurekaServer 默认为 true。 register-with-eureka: true # 是否从EureaServer 抓取已有的注册信息，默认为true.单节点无所谓，集群必须设置true才能配合ribbon使用负载均衡 fetchRegistry: true service-url: defaultZone: http://localhost:7001/eureka 主启动 1234567@EnableEurekaClient@SpringBootApplicationpublic class PaymentMain8001 &#123; public static void main(String[] args) &#123; SpringApplication.run(PaymentMain8001.class, args); &#125;&#125; 添加：注解 @EnableEurekaClient 测试 先启动 EurekaServer http://localhost:7001/ 微服务配置说明 自我保护机制 3.EurekaClient 端 cloud-consumer-order80 将注册进 EurekaServer 成为服务消费者 consumer 改 POM 12345&lt;!--https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-eureka-server --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt; 写 YML 123456789spring: application: name: cloud-order-serviceeureka: client: register-with-eureka: true fetchRegistry: true service-url: defaultZone: http://localhost:7001/eureka 主启动 @EnableEurekaClient 1234567@SpringBootApplication@EnableEurekaClientpublic class OrderMain80 &#123; public static void main(String[] args) &#123; SpringApplication.run(OrderMain80.class, args); &#125;&#125; 测试 先启动 EurekaServer, 7001 服务，在启动服务提供者 provider 8001 服务，在启动消费者 consumer 80 http://localhost/consumer/payment/get/1 BUG ③ Eureka 构建步骤1.Eureka 集群原理说明 **微服务 RPC 远程服务调用最核心的是什么 ** 1高可用 解决办法：搭建 Eureka 注册中心集群，实现负载均衡+故障容错 2.EurekaServer 集群环境构建步骤 新建 cloud-eureka-server7002 和 POM ​ 参考 cloud-eureka-server7001 项目工程 修改映射配置 找到 C:\\Windows\\System32\\drivers\\etc 路径下的 hosts 文件 修改映射配置添加进 hosts 文件 127.0.0.1 eureka7001.com 127.0.0.1 eureka7002.com 写 YML 以前单机 7001 1234567891011server: port: 7001eureka: instance: hostname: eureka7001.com #eureka服务端的实例名称 client: register-with-eureka: false #false表示不向注册中心注册自己。 fetch-registry: false #false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务 service-url: defaultZone: http://eureka7002.com:7002/eureka/ #设置与 eureka server 交互的地址查询服务和注册服务都需要依赖这个地址 7002 1234567891011server: port: 7002eureka: instance: hostname: eureka7002.com #eureka服务端的实例名称 client: register-with-eureka: false #false表示不向注册中心注册自己。 fetch-registry: false #false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务 service-url: defaultZone: http://eureka7001.com:7001/eureka/ #设置与 eureka server 交互的地址查询服务和注册服务都需要依赖这个地址 主启动类 （参考 cloud-eureka-server7001 的主启动类 ） 1234567@SpringBootApplication@EnableEurekaServerpublic class EurekaMain7002 &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaMain7002.class, args); &#125;&#125; 3.将支付服务 8001 微服务发布到上面 2 台 Eureka 集群配置中 YML 123456eureka: client: register-with-eureka: true fetch-registry: true service-url: defaultZone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka # 集群版 4.将订单服务 80 微服务发布到上面 2 台 Eureka 集群配置中 YML 1234567eureka: client: register-with-eureka: true fetchRegistry: true service-url: # defaultZone: http://localhost:7001/eureka defaultZone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka #集群版 5.测试 01 先要启动 EurekaServer， 7001/7002 服务，再要启动服务提供者 provider， 8001 服务，再要启动消费者， 80 http://localhost/consumer/payment/get/1 6.支付服务提供者 8001 集群环境构建 新建 cloud-provider-payment8002 和 POM ​ 参考 cloud-provider-payment8001 写 YML 12345678910111213141516171819202122server: port: 8002spring: application: name: cloud-payment-service datasource: type: com.alibaba.druid.pool.DruidDataSource driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/db2019?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false&amp;serverTimezone=UTC username: root password: 6090mybatis: mapperLocations: classpath:mapper/*.xml type-aliases-package: com.oy.springcloud.entities # 所有Entity别名类所在包eureka: client: register-with-eureka: true fetch-registry: true service-url: # 集群版 defaultZone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka 主启动 1234567@EnableEurekaClient@SpringBootApplicationpublic class PaymentMain8002 &#123; public static void main(String[] args) &#123; SpringApplication.run(PaymentMain8002.class, args); &#125;&#125; 业务类 直接从 8001 粘贴 修改 8001/8002 的 controller 12@Value(&quot;$&#123;server.port&#125;&quot;)private String serverPort; 8001 和 8002 7.负载均衡 Bug： 订单服务访问地址不能写死 原本：（cloud-consumer-order80） 更改： 1public static final String PAYMENT_URL = &quot;http://CLOUD-PAYMENT-SERVICE&quot;; 使用@LoadBalanced 注解赋予 RestTemplate 负载均衡的能力 （cloud-consumer-order80） 8.测试 02 先要启动 EurekaServer， 7001/7002 服务 再要启动服务提供者 provider， 8001/8002 服务 在启动 consumer 80 服务 http://localhost/consumer/payment/get/1 **负载均衡生效， 8001/8002 端口交替出现 ** ④ actuator 微服务信息完善1.主机名称：服务名称修改 修改 YML (cloud-provider-payment8001) 部分 12instance: instance-id: payment8001 2.访问信息有 ip 信息提示​ 当前问题：没有 ip 提示 修改 cloud-provider-payment8001 YML 部分 1prefer-ip-address: true _效果_： ⑤ 服务发现 Discovery1.对于注册进 eureka 里面的微服务，可以通过服务发现来获取服务的信息2.修改 cloud-provider-payment8001 的 Controller123456789101112131415161718@Resourceprivate DiscoveryClient discoveryClient;@GetMapping(value = &quot;/payment/discovery&quot;)public Object discovery()&#123; List&lt;String&gt; services = discoveryClient.getServices(); for (String element : services) &#123; log.info(&quot;**** element:&quot;+ element); &#125; List&lt;ServiceInstance&gt; instances = discoveryClient.getInstances(&quot;CLOUD-PAYMENT-SERVICE&quot;); for (ServiceInstance instance : instances) &#123; log.info(instance.getServiceId()+&quot;\\t&quot;+instance.getHost()+&quot;\\t&quot;+instance.getPort()+&quot;\\t&quot;+instance.getUri()); &#125; return this.discoveryClient;&#125; 3.8001 主启动类 @EnableDiscoveryClient 12345678@EnableEurekaClient@EnableDiscoveryClient // 服务发现@SpringBootApplicationpublic class PaymentMain8001 &#123; public static void main(String[] args) &#123; SpringApplication.run(PaymentMain8001.class, args); &#125;&#125; 4.测试 先启动 EurekaServer， 7001/7002 服务，再启动 8001 主启动类，需要稍等一会 http://localhost:8001/payment/discovery ⑥ Eureka 自我保护1.故障现象 2.导致原因 ​ 总结：某时刻某一个微服务不可用了，Eureka 不会立即清理，依旧会对该服务的信息进行保存，属于 CAP 里的 AP 分支 3.怎么禁止自我保护（一般生产环境中不会禁止自我保护） 注册中心 eureakeServer 端 7001: 出 厂 默 认 ， 自 我 保 护 机 制 是 开 启的:eureka.server.enable-self-preservation = true 使用 eureka.server.enable-self-preservation = false 可以禁用自我保护模式 在 eurekaServer 端 7001 处设置关闭自我保护机制 效果图： 生产者客户端 eureakeClient 端 8001 默认: 12eureka.instance.lease-renewal-interval-in-seconds=30 单位为秒（ 默认是 30 秒）eureka.instance.lease-expiration-duration-in-seconds=90 单 位 为 秒（ 默认是 90 秒） 配置: 1234567instance: instance-id: payment8001 prefer-ip-address: true #Eureka客户端向服务端发送心跳的时间间隔，单位为秒(默认是30秒) lease-renewal-interval-in-seconds: 1 #Eureka服务端在收到最后一次心跳后等待时间上限，单位为秒(默认是90秒)，超时将剔除服务 lease-expiration-duration-in-seconds: 2 4.测试 7001 和 8001 都配置完成 先启动 7001 再启动 8001 ，先关闭 8001 ，马上被删除了 二、Zookeeper 服务注册与发现① Eukeka 停止更新了怎么办​ https://github.com/Netflix/eureka/wiki ② SpringCloud 整合 Zookeeper 代替 Eureka1.注册中心 zookeeper zookeeper 是一个分布式协调工具，可以实现注册中心功能 使用 docker 快速创建 zookeeper 容器 关闭 Linux 服务器防火墙后启动 zookeeper 服务器 CentOS 7 关闭防火墙指令 1234567891011// 查看当前防火墙状态如果防火墙处于开启状态，firewalld.service前面的点是高亮的，Active：active（开启））systemctl status firewalld.service//关闭当前的防火墙（仅对本次开机有效，重启后防火墙会再次启用）systemctl stop firewalld.service//永久关闭防火墙（重启后防火墙依然关闭）systemctl disable firewalld.service// 启动防火墙 systemctl start firewalld zookeeper 服务器取代 Eureka 服务器，zk 作为服务器注册中心 2.服务提供者 新建 cloud-provider-payment8004 POM 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;clould&lt;/artifactId&gt; &lt;groupId&gt;com.oy&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;cloud-provider-payment8004&lt;/artifactId&gt; &lt;description&gt;Zookeeper服务提供者&lt;/description&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.oy&lt;/groupId&gt; &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt; &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--SpringBoot整合Zookeeper客户端--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-zookeeper-discovery&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; YML 1234567891011server: # 8004表示注册到zookeeper服务器的支付服务提供者端口号 port: 8004spring: application: # 服务别名---注册zookeeper到注册中心的名称 name: cloud-provider-payment cloud: zookeeper: connect-string: 116.63.177.72:2181 主启动类 123456789101112import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.client.discovery.EnableDiscoveryClient;@EnableDiscoveryClient@SpringBootApplicationpublic class PaymentMain8004 &#123; public static void main(String[] args) &#123; SpringApplication.run(PaymentMain8004.class, args); &#125;&#125; Controller 123456789101112@RestController@Slf4jpublic class PaymentController &#123; @Value(&quot;$&#123;server.port&#125;&quot;) private String serverPort; @GetMapping(value = &quot;/payment/zk&quot;) public String paymentzk()&#123; return &quot;springcloud with zookeeper:&quot;+serverPort+&quot;\\t&quot;+ UUID.randomUUID().toString(); &#125;&#125; 启动 8004 注册进 zookeeper 注意：启动后问题存在下面问题 Why： 解决 zookeeper 版本 jar 包冲突问题： 排出 zk 冲突后的新 POM： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;cloud2020&lt;/artifactId&gt; &lt;groupId&gt;com.atguigu.springcloud&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;cloud-provider-payment8004&lt;/artifactId&gt; &lt;description&gt;Zookeeper服务提供者&lt;/description&gt; &lt;dependencies&gt; &lt;!--SpringBoot整合Zookeeper客户端--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-zookeeper-discovery&lt;/artifactId&gt; &lt;exclusions&gt; &lt;!--先排除自带的zookeeper3.5.3--&gt; &lt;exclusion&gt; &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt; &lt;artifactId&gt;zookeeper&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;!--添加zookeeper3.4.9版本--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt; &lt;artifactId&gt;zookeeper&lt;/artifactId&gt; &lt;version&gt;3.4.9&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 测试 在 Linux 上查询 和 浏览器上（http://localhost:8004/payment/zk ） 获得 json 串后用在线工具查看试试 （dokcer 容器） 具体详细的操作参考：https://blog.csdn.net/qq_45738810/article/details/109002435 思考： 服务节点是临时节点还是持久节点——是临时节点 3.服务消费者 新建 cloud-consumerzk-order80 POM 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;cloud2020&lt;/artifactId&gt; &lt;groupId&gt;com.atguigu.springcloud&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;cloud-consumerzk-order80&lt;/artifactId&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.atguigu.springcloud&lt;/groupId&gt; &lt;artifactId&gt;cloud-api-common&lt;/artifactId&gt; &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--SpringBoot整合Zookeeper客户端--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-zookeeper-discovery&lt;/artifactId&gt; &lt;exclusions&gt; &lt;!--先排除自带的zookeeper3.5.3--&gt; &lt;exclusion&gt; &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt; &lt;artifactId&gt;zookeeper&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;!--添加zookeeper3.4.9版本--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt; &lt;artifactId&gt;zookeeper&lt;/artifactId&gt; &lt;version&gt;3.4.9&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; YML 12345678910server: port: 80spring: application: # 服务别名 name: cloud-consumer-order cloud: zookeeper: # 注册到zookeeper地址 connect-string: localhost:2181 主启动 1234567@SpringBootApplication@EnableDiscoveryClientpublic class OrderZkMain80 &#123; public static void main(String[] args) &#123; SpringApplication.run(OrderZkMain80.class, args); &#125;&#125; 主业务类 bean 123456789101112131415161718package com.springcloud.config;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.client.RestTemplate;/** * @Author OY * @Date 2020/10/10 */@Configurationpublic class ApplicationContextConfig &#123; @Bean public RestTemplate restTemplate()&#123; return restTemplate(); &#125;&#125; controller 1234567891011121314151617181920212223242526272829package com.springcloud.controller;import lombok.extern.slf4j.Slf4j;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;import org.springframework.web.client.RestTemplate;import javax.annotation.Resource;/** * @Author OY * @Date 2020/10/10 */@RestController@Slf4jpublic class OrderZkController &#123; @Resource private RestTemplate restTemplate; public static final String INVOKE_URL = &quot;http://cloud-provider-payment&quot;; @GetMapping(&quot;/consumer/payment/zk&quot;) public String paymentInfo() &#123; return restTemplate.getForObject(INVOKE_URL + &quot;/payment/zk&quot;, String.class); &#125;&#125; 验证测试 访问测试地址 ​ http://localhost/consumer/payment/zk 三、Consul 服务注册与发现① Consul 简介1.是什么：https://www.consul.io/intro/index.html 2.能干嘛： 服务发现： 提供 HTTP 和 DNS 两种发现方式 健康检查： 支持多种协议，HTTP、TCP、Docker、Shell 脚本定制化 KV 存储： Key，Value 的存储方式 多数据中心： Consul 支持多数据中心 可视化 Web 界面 3.下载https://www.consul.io/downloads.html 4.怎么玩https://www.springcloud.cc/spring-cloud-consul.html ② 安装并运行 Consul1.官网安装说明https://learn.hashicorp.com/consul/getting-started/install.html 2.下载完成后只有一个 consul.exe 文件，硬盘路径下双击运行，查看版本信息 3.使用开发者模式启动1consul agent -dev 通过以下地址可以访问 Consul 的首页：http://localhost:8500/ ③ 服务提供者 新 建 Module 支 付 服 务 provider8006 cloud-providerconsul-payment8006 POM 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;clould&lt;/artifactId&gt; &lt;groupId&gt;com.oy&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;cloud-providerconsul-payment8006&lt;/artifactId&gt; &lt;dependencies&gt; &lt;!--https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-consul-discovery --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-consul-discovery&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.oy&lt;/groupId&gt; &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;!--https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-web --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-web --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-devtools --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.projectlombok/lombok --&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;!--https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-test --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; YML 1234567891011server: port: 8006spring: application: name: consul-provider-payment cloud: consul: host: localhost port: 8500 discovery: service-name: $&#123;spring.application.name&#125; 主启动类 1234567@EnableDiscoveryClient@SpringBootApplicationpublic class PaymentMain8006 &#123; public static void main(String[] args) &#123; SpringApplication.run(PaymentMain8006.class, args); &#125;&#125; 主业务类 Controller 123456789101112@RestController@Slf4jpublic class PaymentController &#123; @Value(&quot;$&#123;server.port&#125;&quot;) private String serverPort; @GetMapping(value = &quot;/payment/consul&quot;) public String paymentConsul()&#123; return &quot;SpringCloud with consul:&quot; + serverPort + &quot;\\t&quot;+ UUID.randomUUID().toString(); &#125;&#125; 验证测试 ​ http://localhost:8006/payment/consul ④ 服务消费者 新 建 Module 消 费 服 务 order8006 ​ cloud-consumerconsul-order80 POM 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;clould&lt;/artifactId&gt; &lt;groupId&gt;com.oy&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;cloud-consumerconsul-order80&lt;/artifactId&gt; &lt;dependencies&gt; &lt;!--https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-consul-discovery --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-consul-discovery&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.oy&lt;/groupId&gt; &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;!--https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-web --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-web --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-devtools --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.projectlombok/lombok --&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;!--https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-test --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; YML 123456789101112server: port: 80spring: application: name: consul-consumer-order cloud: consul: host: localhost port: 8500 discovery: service-name: $&#123;spring.application.name&#125; 主启动类 12345678910111213package com.oy.springcloud;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.client.discovery.EnableDiscoveryClient;@SpringBootApplication@EnableDiscoveryClientpublic class OrderConsulMain80 &#123; public static void main(String[] args) &#123; SpringApplication.run(OrderConsulMain80.class, args); &#125;&#125; 配置 Bean 12345678910111213141516package com.oy.springcloud.config;import org.springframework.cloud.client.loadbalancer.LoadBalanced;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.client.RestTemplate;@Configurationpublic class ApplicationConfig &#123; @LoadBalanced // 负载均衡 @Bean public RestTemplate restTemplate()&#123; return new RestTemplate(); &#125;&#125; Controller 12345678910111213141516171819202122232425262728package com.oy.springcloud.controller;import lombok.extern.slf4j.Slf4j;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;import org.springframework.web.client.RestTemplate;import javax.annotation.Resource;/** * @Author OY * @Date 2020/10/11 */@RestController@Slf4jpublic class OrderConsulController &#123; public static final String INVOME_URL = &quot;http://consul-provider-payment&quot;; @Resource public RestTemplate restTemplate; @GetMapping(&quot;/consumer/payment/consul&quot;) public String payment()&#123; String result = restTemplate.getForObject(INVOME_URL+&quot;/payment/consul&quot;,String.class ); return result; &#125;&#125; 验证测试 访问测试地址：http://localhost/consumer/payment/consul ⑤ 三个注册中心异同点1.CAP C： Consistency (强一致性) A: Availability （可用性） P: Partition tolerance （分区容错） CAP 理论关注粒度是数据， 而不是整体系统设计的策略 2.经典 CAP 图 AP(Eureka) 架构 当网络分区出现后，为了保证可用性，系统 B可以返回值，保证系统的可用性。 结论：违背了一致性 C 的要求，只满足可用性和分区容错，即 AP CP(Zookeeper/Consul) 架构","categories":[{"name":"JavaEE框架","slug":"JavaEE框架","permalink":"http://blog.oy6090.top/categories/JavaEE%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"java","slug":"java","permalink":"http://blog.oy6090.top/tags/java/"},{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://blog.oy6090.top/tags/SpringCloud/"}]},{"title":"SpringCloud 服务调用","slug":"SpringCloud服务调用","date":"2020-10-10T16:00:00.000Z","updated":"2020-10-25T02:33:56.301Z","comments":true,"path":"posts/1872245415.html","link":"","permalink":"http://blog.oy6090.top/posts/1872245415.html","excerpt":"","text":"博客学习参考视频 一、Ribbon 负载均衡服务调用① 概述1.是什么 2.官网资料​ https://github.com/Netflix/ribbon/wiki/Getting-Started Ribbon 目前也进入维护模式 未来替换方案 3.能干嘛 LB（负载均衡） ： 集中式 LB、 进程内 LB ，前面我们写过了 80 通过轮询负载访问 8001/8002 一句话： 负载均衡+RestTemplate 调用 ② Ribbon 负载均衡演示1.架构说明 总结: Ribbon 其实就是一个软负载均衡的客户端组件，他可以和其他所需请求的客户端结合使用，和 eureka 结合只是其中的一个实例。 2.POM 3.RestTemplate 的使用官网：https://docs.spring.io/spring-framework/docs/5.2.2.RELEASE/javadoc-api/org/springframework/web/client/RestTemplate.html getForObject 方法/getForEntity 方法 postForObject/postForEntity ③ Ribbon 核心组件 IRule1.IRule根据特定算法从服务列表中选取一个要访问的服务 com.netflix.loadbalancer.RoundRobinRule 轮询 com.netflix.loadbalancer.RandomRule 随机 com.netflix.loadbalancer.RetryRule： 先按照 RoundRobinRule 的策略获取服务， 如果获取服务失败则在指定时间内会进行重试 WeightedResponseTimeRule ： 对 RoundRobinRule 的扩展， 响应速度越快的实例选择权重越大， 越容易被选择 BestAvailableRule ： 会先过滤掉由于多次访问故障而处于断路器跳闸状态的服务， 然后选择一个并发量最小的服务 AvailabilityFilteringRule ： 先过滤掉故障实例， 再选择并发较小的实例 ZoneAvoidanceRule： 默认规则， 复合判断 server 所在区域的性能和 server 的可用性选择服务器 2.如何替换 修改 cloud-consumer-order80 注意配置细节 新建 package： com.oy.myrule 主启动类添加@RibbonClient 1234567891011121314import com.oy.myrule.MySelfRule;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.netflix.eureka.EnableEurekaClient;import org.springframework.cloud.netflix.ribbon.RibbonClient;@SpringBootApplication@EnableEurekaClient@RibbonClient(name = &quot;CLOUD-PAYMENT-SERVICE&quot;,configuration = MySelfRule.class)public class OrderMain80 &#123; public static void main(String[] args) &#123; SpringApplication.run(OrderMain80.class, args); &#125;&#125; 测试 ​ http://localhost/consumer/payment/get/1 ④ Ribbon 负载均衡算法1.原理 2.RoundRobinRule 源码3.手写 7001/7002 集群启动 8001/8002 微服务改造 Controller: 1234@GetMapping(value = &quot;/payment/lib&quot;)public String getPaymentLB()&#123; return serverPort;&#125; 80 订单微服务改造 ApplicationContextBean 去掉@LoadBalanced LoadBalancer 接口 123456789101112131415161718192021222324252627282930313233package com.oy.springcloud.lb;import org.springframework.cloud.client.ServiceInstance;import org.springframework.stereotype.Component;import java.util.List;import java.util.concurrent.atomic.AtomicInteger;@Componentpublic class MyLB implements LoadBalancer&#123; private AtomicInteger atomicInteger = new AtomicInteger(0); // 坐标 private final int getAndIncrement()&#123; int current; int next; do&#123; current = this.atomicInteger.get(); next = current &gt;= 2147483647 ? 0 : current+1; &#125;while (!this.atomicInteger.compareAndSet(current,next)); // 第一个参数是期望值，第二个参数是修改值是 System.out.println(&quot;******第几次访问，次数next:&quot; + next + &quot;,current:&quot;+ current); return next; &#125; @Override public ServiceInstance instances(List&lt;ServiceInstance&gt; serviceInstances) &#123;// 得到机器列表 // 获取服务器的下标位置 int index = getAndIncrement() % serviceInstances.size(); return serviceInstances.get(index); &#125;&#125; OrderController 123456789101112131415161718192021222324252627282930/** * @Author OY * @Date 2020/10/7 */@RestControllerpublic class OrderController &#123; @Resource private RestTemplate restTemplate; @Resource LoadBalancer loadBalancer; @GetMapping(value = &quot;/consumer/payment/lb&quot;) public String getPaymentLB()&#123; List&lt;ServiceInstance&gt; instances = discoveryClient.getInstances(&quot;CLOUD-PAYMENT-SERVICE&quot;); if(instances == null || instances.size() &lt;= 0)&#123; return null; &#125; ServiceInstance serviceInstance = loadBalancer.instances(instances); URI uri = serviceInstance.getUri(); return restTemplate.getForObject(uri+&quot;/payment/lb&quot;,String.class); &#125;&#125; 测试 http://localhost/consumer/payment/lb _效果_： 二、OpenFeign 服务接口调用① 概述1.OpenFeign 是什么 Feign 是一个声明式的 web 服务客户端，让编写 web 服务客户端变得非常容易，只需要创建一个接口上添加注解即可 ​ GitHub: https://github.com/spring-cloud/spring-cloud-openfeign 2.能干嘛 3.Feign 和 OpenFeign 两者区别 ② OpenFeign 使用步骤 接口 + 注解： 微服务调用接口 + @FeignClient 新建 cloud-consumer-feign-order80 Feign 在消费端使用 POM 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;clould&lt;/artifactId&gt; &lt;groupId&gt;com.oy&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;cloud-consumer-feign-order80&lt;/artifactId&gt; &lt;!--openfeign--&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.oy&lt;/groupId&gt; &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; YML 1234567server: port: 80eureka: client: register-with-eureka: false service-url: defaultZone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka 主启动类 : @ EnableFeignClients 1234567@SpringBootApplication@EnableFeignClientspublic class OrderFeignMain80 &#123; public static void main(String[] args) &#123; SpringApplication.run(OrderFeignMain80.class, args); &#125;&#125; 业务类 业务逻辑接口 + @FeignClient 配置调用 provider 服务 新建 PaymentFeignService 接口并新增注解 @FeignClient 1234567@Component@FeignClient(value = &quot;CLOUD-PAYMENT-SERVICE&quot;)public interface PaymentFeignService &#123; @GetMapping(value = &quot;/payment/get/&#123;id&#125;&quot;) public CommonResult getPaymentById(@PathVariable(&quot;id&quot;) Long id);&#125; Controller 123456789101112@RestControllerpublic class OrderFeignController &#123; @Resource private PaymentFeignService paymentFeignService; @GetMapping(value = &quot;/consumer/payment/get/&#123;id&#125;&quot;) public CommonResult&lt;Payment&gt; getPaymentById(@PathVariable(&quot;id&quot;)Long id)&#123; return paymentFeignService.getPaymentById(id); &#125;&#125; 测试 先启动 2 个 eureka 集群 7001/7002 在启动 2 个微服务 8001/8002 启动 OpenFeign 启动 http://localhost/consumer/payment/get/1 小总结 ③ OpenFeign 超时控制1.超时设置，故意设置超时演示出错情况​ 服务提供方 8001 故意写暂停程序 12345678910@GetMapping(value = &quot;/payment/feign/timeout&quot;)public String paymentFeignTimeOut()&#123; try &#123; TimeUnit.SECONDS.sleep(3); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; return serverPort;&#125; ​ 服务消费方 80 添加超时方法 PaymentFeignService 1234567891011@Component@FeignClient(value = &quot;CLOUD-PAYMENT-SERVICE&quot;)public interface PaymentFeignService &#123; // 添加超时方法 PaymentFeignService @GetMapping(value = &quot;/payment/feign/timeout&quot;) public String paymentFeignTimeOut(); @GetMapping(value = &quot;/payment/get/&#123;id&#125;&quot;) public CommonResult getPaymentById(@PathVariable(&quot;id&quot;) Long id);&#125; ​ 服务消费方 80 添加超时方法 OrderFeignController 1234@GetMapping(value = &quot;/consumer/payment/feign/timeout&quot;)public String paymentFeignTimeOut()&#123; return paymentFeignService.paymentFeignTimeOut();&#125; 测试： 错误页面 2.OpenFeign 默认等待一秒钟， 超过后报错3.是什么​ 默认 Feign 客户端等待一秒，但是服务器处理需要超过 1 秒钟，导致 Feign 客户端不想等待了，直接返回报错。为了避免这样的情况，有时候我们需要设置 Feign 客户端的超时控制。 在 yml 文件中开启配置 4.YML 文件里需要开启 OpenFeign 客户端超时控制12345678910111213server: port: 80eureka: client: register-with-eureka: false service-url: defaultZone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka# 设置feign客户端超时时间(OpenFeign默认支持ribbon)ribbon: # 指的是建立连接所用的时间,适用于网络状态正常的情况下,两端连接所用的时间 ReadTimeout: 5000 # 指的是建立连接后从服务器读取到可用资源所用的时间 ConnectTimeout: 5000 测试： ​ http://localhost/consumer/payment/feign/timeout ④ OpenFeign 日志打印功能1.日志打印功能2.是什么 3.日志级别 4.配置日志 bean1234567891011121314151617181920package com.oy.springcloud;import feign.Logger;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;/** * @Author OY * @Date 2020/10/16 */@Configurationpublic class FeignConfig &#123; @Bean Logger.Level feignLoggerLevel()&#123; return Logger.Level.FULL; &#125;&#125; 5.YML 文件里面需要开启日志的 Feign 客户端123logging: level: com.oy.springcloud.service.PaymentFeignService: debug 6.后台日志查看","categories":[{"name":"JavaEE框架","slug":"JavaEE框架","permalink":"http://blog.oy6090.top/categories/JavaEE%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"java","slug":"java","permalink":"http://blog.oy6090.top/tags/java/"},{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://blog.oy6090.top/tags/SpringCloud/"}]},{"title":"SpringBoot与监控管理(Actuator)","slug":"Spring Boot与监控管理(Actuator)","date":"2020-10-05T16:00:00.000Z","updated":"2020-10-25T02:34:34.781Z","comments":true,"path":"posts/1175849155.html","link":"","permalink":"http://blog.oy6090.top/posts/1175849155.html","excerpt":"","text":"一、监控管理​ 通过引入 spring-boot-starter-actuator，可以使用 Spring Boot 为我们提供的准生产环境下的应用监控和管理功能。我们可以通过 HTTP， JMX， SSH 协议来进行操作，自动得到审计、健康及指标信息等 。 步骤： 引入 spring-boot-starter-actuctor 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt; 通过 http 方式访问监控点端点 首先在配置文件中把端点暴露出来 在 application.properties 中配置端点， 暴露部分端点 management.endpoints.web.exposure.include=info,health,beans,env 暴露所有端点 management.endpoints.web.exposure.include=* 不暴露 beans 端点 management.endpoints.web.exposure.exclude=beans 在上述配置中，首先使用 management.endpoints.web.exposure.include 暴露所有的端点，接着使用 management.endpoints .web.exposure.exclud 排除 en 端点，这样就能够暴露除 env 外的所有 ctuator 端点了。 http://localhost:8080/actuator/health 访问项目监控需要加前缀 /actuator ​ 如果不在配置文件中配置把端口暴露出来，则会出现以下这样的情况。 ​ 因为 actuator 默认只支持端点 /health、/info 所以访问 /env 会出现 404 页面。 监控点和管理端点 端点名 描述 autoconfig 所有自动配置信息 auditevents 审计事件 beans 所有 Bean 的信息 configprops 所有配置属性 dump 线程状态信息 env 当前环境信息 health 应用健康状况 info 当前应用信息 metrics 应用的各项指标 mappings 应用@RequestMapping 映射路径 shutdown 关闭当前应用（默认关闭） trace 追踪信息（最新的 http 请求） 示例：访问必须添加前缀/actuator 可进行 shutdown （POST 提交， 此端点默认关闭） 在配置文件中配置 12#启用shutdownmanagement.endpoint.shutdown.enabled=true 二、定制端点 # Actuator 管理端口management.server.port=8000 ＃暴露 有端management.endpoints.web.exposure.include ＝女 ＃默认情况下 有端点都不启用，此时需要按需启用端点management.endpoints.enabled-by-default=false ＃启用端点 infomanagement.endpoint.info.enabled=true ＃启用端点 beansmanagement.endpoint.beans.enabled=true ＃启用端点 configpropsmanagement.endpoint.configprops.enabled=true ＃启用端点 envmanagement.endpont.env.enabled=true ＃启用端点 healthmanagement.endpoint.health.enabled=true ＃启用端点 mappingsmanagement.endpont.mappings.enabed=true ＃启用端点 shutdownmanagement.endpoint.shutdown.enabled=true /# Actuator 端点前缀management.endpoints.web.base -path=/manage ＃将原来的 mappings 端点的请求路径修改为 urlMappingsmanagement.endpoints.web.path-mapping.mappings=request_mappings # Spring MVC 视图解析器配置spring.mvc.view.prefix=/WEB-INF/jsp/spring.mvc.view.suffix=.Jsp","categories":[{"name":"JavaEE框架","slug":"JavaEE框架","permalink":"http://blog.oy6090.top/categories/JavaEE%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"java","slug":"java","permalink":"http://blog.oy6090.top/tags/java/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://blog.oy6090.top/tags/SpringBoot/"}]},{"title":"SpringCloud 微服务搭建","slug":"SpringCloud 微服务搭建","date":"2020-10-05T16:00:00.000Z","updated":"2020-10-25T02:34:05.623Z","comments":true,"path":"posts/2086819267.html","link":"","permalink":"http://blog.oy6090.top/posts/2086819267.html","excerpt":"","text":"博客参考学习视频： https://www.bilibili.com/video/BV18E411x7eT?from=search&amp;seid=4388336378730572330 一、微服务架构编码构建① 约定 &gt; 配置 &gt; 编码 slave 会从 master 读取 binlog 来进行数据同步 三步骤+原理图 MySQL 复制过程分成三步：1 master 将改变记录到二进制日志（binary log）。这些记录过程叫做二进制日志事件，binary log events；2 slave 将 master 的 binary log events 拷贝到它的中继日志（relay log）；3 slave 重做中继日志中的事件，将改变应用到自己的数据库中。 MySQL 复制是异步的且串行化的 ② IDEA 新建 project 工作空间1.微服务 cloud 整体聚合父工程 Project​ 父工程步骤： 1） New Project 2）聚合总工程名字和工程名字（idea 2020.2 版本） 3）选择 Maven 版本 4）字符编码 5） 注解生效激活 6）Java 编译版本选择 8 File Type 过滤 2.父工程1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.oy&lt;/groupId&gt; &lt;artifactId&gt;clould&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;modules&gt; &lt;module&gt;cloud-provider-payment8001&lt;/module&gt; &lt;/modules&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;junit.version&gt;4.12&lt;/junit.version&gt; &lt;log4j.version&gt;1.2.17&lt;/log4j.version&gt; &lt;lombok.version&gt;1.16.18&lt;/lombok.version&gt; &lt;mysql.version&gt;8.0.19&lt;/mysql.version&gt; &lt;druid.version&gt;1.1.16&lt;/druid.version&gt; &lt;spring.boot.version&gt;2.2.2.RELEASE&lt;/spring.boot.version&gt; &lt;spring.cloud.version&gt;Hoxton.SR1&lt;/spring.cloud.version&gt; &lt;spring.cloud.alibaba.version&gt;2.1.0.RELEASE&lt;/spring.cloud.alibaba.version&gt; &lt;mybatis.spring.boot.version&gt;1.3.0&lt;/mybatis.spring.boot.version&gt; &lt;/properties&gt; &lt;!--子模块继承后,提供作用:锁定版本+子module不用groupId和version--&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!--springboot 2.2.2--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.boot.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;!--Spring cloud Hoxton.SR1--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;!--Spring cloud alibaba 2.1.0.RELEASE--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.cloud.alibaba.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;$&#123;mysql.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;$&#123;druid.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis.spring.boot.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;$&#123;lombok.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;fork&gt;true&lt;/fork&gt; &lt;addResources&gt;true&lt;/addResources&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 3.Maven 工程落地细节复习Maven 中的 dependencyManagement 和 dependencies maven 中跳过单元测试 4.父工程创建完成执行 mvn:insall 将父工程发布到仓库方便子工程继承二、Rest 微服务工程构建① 构建步骤(1) cloud-provider-payment8001 微服务提供者支付 Module 模块​ 建 cloud-provider-payment8001 ​ 创建完成之后请回到父工程产看 pom 文件的变化 1. **改POM 文件** 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;clould&lt;/artifactId&gt; &lt;groupId&gt;com.oy&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;cloud-provider-payment8001&lt;/artifactId&gt; &lt;dependencies&gt;&lt;!--https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-web --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter -web --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter -web --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.10&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter -jdbc --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-devtoo ls --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.projectlombok/lombok --&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter -test --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 写 YML 1234567891011121314server: port: 8001spring: application: name: cloud-payment-servicedatasource: type: com.alibaba.druid.pool.DruidDataSource driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/db2019?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false username: root password: 6090mybatis: mapperLocations: classpath:mapper/*.xml type-aliases-package: com.oy.springcloud.entities # 所有Entity别名类所在包 注意：有可能在编译时会出现以下的异常 The server time zone value ‘�й���׼ʱ��’ is unrecogni 需要在配置文件中的 datasource.url 后面添加上 serverTimezone=UTC 1url: jdbc:mysql://localhost:3306/db2019?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false&amp;serverTimezone=UTC 主启动类 123456@SpringBootApplicationpublic class PaymentMain8001 &#123; public static void main(String[] args) &#123; SpringApplication.run(PaymentMain8001.class, args); &#125;&#125; 业务类 建表 SQL 123456789CREATE TABLE `payment`( `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#x27;主键&#x27;, `serial` varchar(200) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT &#x27;支付流水号&#x27;, PRIMARY KEY (`id`) USING BTREE) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci COMMENT = &#x27;支付表&#x27; ROW_FORMAT = Dynamic; emtities ​ 主实体 Payment 1234567891011121314151617181920package com.oy.springcloud.entities;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;import java.io.Serializable;/** * @Author OY * @Date 2020/10/7 */@Data@AllArgsConstructor@NoArgsConstructorpublic class Payment implements Serializable &#123; private Long id; private String serial;&#125; Json 封装 CommonResult 1234567891011121314151617181920212223package com.oy.springcloud.entities;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;/** * @Author OY * @Date 2020/10/7 */@Data@AllArgsConstructor@NoArgsConstructorpublic class CommonResult&lt;T&gt; &#123; private Integer code; private String message; private T data; public CommonResult(Integer code, String message)&#123; this.code = code; this.message = message; &#125;&#125; Dao 123456@Mapperpublic interface PaymentDao &#123; public int create(Payment payment); public Payment getPaymentById(@Param(&quot;id&quot;) Long id);&#125; ​ mybatis 的映射文件为 PaymentMapper.xml, 路径为 src\\main\\resources\\mapper\\ParmentMapper.xml PaymentMapper.xml 12345678910111213141516171819202122&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.oy.springcloud.dao.PaymentDao&quot;&gt; &lt;!--public int create(Payment payment);--&gt; &lt;insert id=&quot;create&quot; parameterType=&quot;Payment&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt; insert into payment(serial) values(#&#123;serial&#125;) &lt;/insert&gt; &lt;!--public Payment getPaymentById(@Param(&quot;id&quot;) Long id);--&gt; &lt;resultMap id=&quot;BaseResult&quot; type=&quot;com.oy.springcloud.entitles.Payment&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot; jdbcType=&quot;BIGINT&quot;/&gt; &lt;id column=&quot;serial&quot; property=&quot;serial&quot; jdbcType=&quot;VARCHAR&quot;/&gt; &lt;/resultMap&gt; &lt;select id=&quot;getPaymentById&quot; parameterType=&quot;Long&quot; resultMap=&quot;BaseResult&quot;&gt; select * from payment where id=#&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; Service ​ 接口类 PaymentService 1234567891011package com.oy.springcloud.service;import com.oy.springcloud.entities.Payment;import org.apache.ibatis.annotations.Param;public interface PaymentService &#123; public int create(Payment payment); // 写 public Payment getPaymentById(@Param(&quot;id&quot;) Long id); // 读取&#125; ​ 实体类 123456789101112131415161718192021222324252627package com.oy.springcloud.service.impl;import com.oy.springcloud.dao.PaymentDao;import com.oy.springcloud.entities.Payment;import com.oy.springcloud.service.PaymentService;import org.springframework.stereotype.Service;import javax.annotation.Resource;@Servicepublic class PaymentServiceImpl implements PaymentService &#123; @Resource // @Autowired private PaymentDao paymentDao; @Override public int create(Payment payment)&#123; return paymentDao.create(payment); &#125; @Override public Payment getPaymentById(Long id)&#123; return paymentDao.getPaymentById(id); &#125;&#125; controller 12345678910111213141516171819202122232425262728293031323334@RestController@Slf4jpublic class PaymentController &#123; @Resource private PaymentService paymentService; @PostMapping(value = &quot;/payment/create&quot;) public CommonResult create(Payment payment) &#123; int result = paymentService.create(payment); log.info(&quot;*****插入结果： &quot; + result); // 成功 if (result &gt; 0) &#123; return new CommonResult(200, &quot;插入数据库成功&quot;, result); &#125; else &#123; return new CommonResult(444, &quot;插入数据库失败&quot;, null); &#125; &#125; @GetMapping(value = &quot;/payment/get/&#123;id&#125;&quot;) public CommonResult getPaymentById(@PathVariable(&quot;id&quot;) Long id) &#123; Payment payment = paymentService.getPaymentById(id); log.info(&quot;*****查询结果： &quot; + payment); // 成功 if (payment != null) &#123; return new CommonResult(200, &quot;查询成功&quot;, payment); &#125; else &#123; return new CommonResult(444, &quot;没 有 对 应 记 录 ， 查 询 ID ：&quot;+id, null); &#125; &#125;&#125; 测试 http://localhost:8001/payment/get/1 postman 模拟 post 通过修改 idea 的 workpace.xml 的方式来快速打开 Run DashBoard 窗口 开启 Run DashBoard(个别版本需要) 12345&lt;option name=&quot;configurationTypes&quot;&gt; &lt;set&gt; &lt;option value=&quot;SpringBootApplicationConfigurationType&quot; /&gt; &lt;/set&gt;&lt;/option&gt; 注意：部分同学可能由于 idea 版本不同， 需要关闭重启 (2) 热部署 Devtools Adding devtools to your project 1234567&lt;!--https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-devtools --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; Adding plugin to your pom.xml 12345678910111213// 下面这一段粘贴在父POM.xml中&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;fork&gt;true&lt;/fork&gt; &lt;addResources&gt;true&lt;/addResources&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 3.Enabling automatic build 4.Update the value of (3) cloud-consumer-order80 微服务消费者订单 Module 模块​ 建 cloud-consumer-order80 改 POM 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;clould&lt;/artifactId&gt; &lt;groupId&gt;com.oy&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;cloud-consumer-order80&lt;/artifactId&gt; &lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter -web --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter -web --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-devtoo ls --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.projectlombok/lombok --&gt; &lt;dependency&gt;&lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter -test --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 写 YML 12server: port: 80 主启动 1234567891011package com.oy.springcloud;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class OrderMain80 &#123; public static void main(String[] args) &#123; SpringApplication.run(OrderMain80.class, args); &#125;&#125; 业务类 创建 entities(将 cloud-provider-payment8001 工程下的 entities 包下的两个实体复制过来） RestTemplate: ​ 官网及使用 ​ 官网地址：https://docs.spring.io/spring-framework/docs/5.2.2.RELEASE/javadoc-api/org/springframework/web/client/RestTemplate.html ​ 使用：使用 restTemplate 访问 restful 接口非常的简单的粗暴无脑。（url, reuestMap, ResponseBean.class）这三个参数分别代表 REST 请求地址、请求参数、HTTP 响应转换成的对象类型。 config 配置类 1234567891011121314package com.oy.springcloud.config;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.client.RestTemplate;@Configurationpublic class ApplicationContextConfig &#123; @Bean public RestTemplate getRestTemplate()&#123; return new RestTemplate(); &#125;&#125; 测试 先启动 cloud-provider-payment8001 再启动 cloud-consumer-order80 http://localhost/consumer/payment/get/1 不要忘记@RequestBody 注解，不然在测试 http://localhost/consumer/payment/create?serial=&quot;商店 003” (4) 工程重构 观察问题：系统中有重复的部分 重构 新建 cloud-api-commons POM 12345678910111213141516171819202122232425262728293031323334&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;clould&lt;/artifactId&gt; &lt;groupId&gt;com.oy&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt; &lt;dependencies&gt; &lt;!--https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-devtools --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;!--https://mvnrepository.com/artifact/cn.hutool/hutool-all --&gt; &lt;dependency&gt; &lt;groupId&gt;cn.hutool&lt;/groupId&gt; &lt;artifactId&gt;hutool-all&lt;/artifactId&gt; &lt;version&gt;5.1.0&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 在 cloud-api-commons 项目下创建 entities 的 Payment 和 CommonResult 封装类 使用 maven 命名 clean 和 install 命令，把它存储到仓库里，方便其他的项目的复用。 对订单 80 和 支付 8001 分别改造， 删除各自原有的 entities 文件夹, 各自黏贴 POM 内容 80、8001 12345&lt;dependency&gt; &lt;groupId&gt;这里根据自己设置来定&lt;/groupId&gt;// com.oy 这是我自己的，不清楚查看一下自己的仓库 &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt; &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt;&lt;/dependency&gt; ② 目前项目样图","categories":[{"name":"JavaEE框架","slug":"JavaEE框架","permalink":"http://blog.oy6090.top/categories/JavaEE%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"java","slug":"java","permalink":"http://blog.oy6090.top/tags/java/"},{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://blog.oy6090.top/tags/SpringCloud/"}]},{"title":"SpringBoot与Dubbo、Zookeeper","slug":"Spring Boot与Dubbo、Zookeeper","date":"2020-10-03T16:00:00.000Z","updated":"2020-10-25T02:29:59.207Z","comments":true,"path":"posts/3991296734.html","link":"","permalink":"http://blog.oy6090.top/posts/3991296734.html","excerpt":"","text":"一、概念ZooKeeper​ ZooKeeper 是一个分布式的，开放源码的分布式应用程序协调服务。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步、组服务等。 Dubbo​ Dubbo 是 Alibaba 开源的分布式服务框架，它最大的特点是按照分层的方式来架构，使用这种方式可以使各个层之间解耦合（或者最大限度地松耦合）。从服务模型的角度来看， Dubbo 采用的是一种非常简单的模型，要么是提供方提供服务，要么是消费方消费服务，所以基于这一点可以抽象出服务提供方（Provider）和服务消费方（Consumer）两个角色。 二、SpringBoot 2.3 整合 Zookeeper、Dubbo① 安装 zookeeper 作为注册中心12345&#x2F;&#x2F; 安装镜像docker pull zookeeper:latest&#x2F;&#x2F; 启动镜像docker run --name zk01 -p 2181:2181 --restart always -d zookeeper:latest ​ 这里只需要用到 2181 这个端口，只把它暴露，其他的两个端口不需要。 This image includes EXPOSE 2181 2888 3888 8080 (the zookeeper client port, follower port, election port, AdminServer port respectively), so standard container linking will make it automatically available to the linked containers. Since the Zookeeper “fails fast” it’s better to always restart it. ② 编写服务提供者 pom.xml 文件中引入 dubbo 和 zkclient 相关依赖 123456789101112131415&lt;!-- https://mvnrepository.com/artifact/org.apache.dubbo/dubbo-spring-boot-starter --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba.boot&lt;/groupId&gt; &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;0.1.0&lt;/version&gt;&lt;/dependency&gt; &lt;!--引入zookeeper的客户端工具--&gt; &lt;!-- https://mvnrepository.com/artifact/com.github.sgroschupf/zkclient --&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.sgroschupf&lt;/groupId&gt; &lt;artifactId&gt;zkclient&lt;/artifactId&gt; &lt;version&gt;0.1&lt;/version&gt;&lt;/dependency&gt; 配置 dubbo 的扫描包和注册中心地址 12345dubbo.registry.address=zookeeper://192.168.64.129:2181dubbo.application.name=provider-tickerdubbo.scan.base-packages=com.oy.providerticket.service 使用@Service 发布服务 【TicketService.java】 123public interface TicketService &#123; public String getTicket();&#125; 【TicketServiceImpl.java】 123456789101112import com.alibaba.dubbo.config.annotation.Service;import org.springframework.stereotype.Component;@Component// 将服务发送出去@Servicepublic class TicketServiceImpl implements TicketService&#123; @Override public String getTicket() &#123; return &quot;《姜子牙》&quot;; &#125;&#125; 添加在 Applicaiton 上面@EnableDubbo 注解 123456789@SpringBootApplication@EnableDubbo // 开启Dubbo服务public class ProviderTickerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ProviderTickerApplication.class, args); &#125;&#125; ③ 编写服务消费者 1.引入依赖‘ 123456789101112131415&lt;!-- https://mvnrepository.com/artifact/org.apache.dubbo/dubbo-spring-boot-starter --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba.boot&lt;/groupId&gt; &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;0.1.0&lt;/version&gt;&lt;/dependency&gt;&lt;!--引入zookeeper的客户端工具--&gt;&lt;!-- https://mvnrepository.com/artifact/com.github.sgroschupf/zkclient --&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.sgroschupf&lt;/groupId&gt; &lt;artifactId&gt;zkclient&lt;/artifactId&gt; &lt;version&gt;0.1&lt;/version&gt;&lt;/dependency&gt; 2.配置 dubbo 的注册中心地址 12345dubbo.application.name=consumer-userdubbo.registry.address=zookeeper://192.168.64.129:2181 3.引用服务 【UserService.java】 12345678910111213@Servicepublic class UserService&#123; @Reference TicketService ticketService; public void hello()&#123; String ticket = ticketService.getTicket(); System.out.println(&quot;买到票了：&quot;+ticket); &#125;&#125; ④ 启动 先启动provider-ticket然后再启动consumer-user **consumer-user **中的 ConsumerUserApplicationTests.java 测试 12345678910111213@SpringBootTestclass ConsumerUserApplicationTests &#123; @Autowired UserService userService; @Test void contextLoads() &#123; userService.hello(); &#125;&#125;","categories":[{"name":"JavaEE框架","slug":"JavaEE框架","permalink":"http://blog.oy6090.top/categories/JavaEE%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"java","slug":"java","permalink":"http://blog.oy6090.top/tags/java/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://blog.oy6090.top/tags/SpringBoot/"}]},{"title":"SpringBoot与安全(Spring Security)","slug":"Spring Boot与安全(Spring Security)","date":"2020-10-03T16:00:00.000Z","updated":"2020-10-25T02:30:07.599Z","comments":true,"path":"posts/2243339053.html","link":"","permalink":"http://blog.oy6090.top/posts/2243339053.html","excerpt":"","text":"博客中涉及的源码，下载地址在博客文章底部，有需要的小伙伴自行下载 一、简介​ SpringSecurity 是针对 Spring 项目的安全框架，也是 Spring Boot 底层安全模块的技术选项。他可以实现强大的 web 安全控制。对于安全控制，我们需要引入 spring-boot-starter-securiy 模块。 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; 几个类： WebSecurityConfigurerAdapter: 自定义 Security 策略 AuthenticationManagerBuilder: 自定义认证的策略 @EnableWebSecurity: 开启 WebSecurity 模式 具体的参考 Spring 官网:https://spring.io/guides/gs/securing-web/ 二、功能演示配置 thymeleaf 模板依赖（springboot 2.3 版本） 12345// 其他有可能需要配置以下配置，2.3不需要&lt;properties&gt; &lt;thymeleaf.version&gt;3.0.9.RELEASE&lt;/thymeleaf.version&gt; &lt;thymeleaf-layout-dialect.version&gt;2.3.0&lt;/thymeleaf-layout-dialect.version&gt;&lt;/properties&gt; 以下都需要配置 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt; ① 引入 SpringSecurity1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;&lt;/dependency&gt; ② 编写 SpringSecurity 的配置类1234@EnableWebSecuritypublic class MySecurityConfig extends WebSecurityConfigurerAdapter &#123;&#125; ③ 登入控制请求的访问权限： 123456789101112@EnableWebSecuritypublic class MySecurityConfig extends WebSecurityConfigurerAdapter &#123; @Override protected void configure(HttpSecurity http) throws Exception &#123; //super.configure(http); // 定制请求的授权规则 http.authorizeRequests().antMatchers(&quot;/&quot;).permitAll() .antMatchers(&quot;/level1/**&quot;).hasRole(&quot;VIP1&quot;) .antMatchers(&quot;/level2/**&quot;).hasRole(&quot;VIP2&quot;) .antMatchers(&quot;/level2/**&quot;).hasRole(&quot;VIP3&quot;); &#125;&#125; 定义认证规则 注意：Security5 与之前的传输密码有部分的不同 参考我这篇博客：https://blog.csdn.net/qq_45738810/article/details/108912554 12345678910111213@EnableWebSecuritypublic class MySecurityConfig extends WebSecurityConfigurerAdapter &#123; @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123;// super.configure(auth); auth.inMemoryAuthentication().passwordEncoder(new BCryptPasswordEncoder()).withUser(&quot;zhangsan&quot;).password(new BCryptPasswordEncoder().encode(&quot;123456&quot;)).roles(&quot;VIP1&quot;, &quot;VIP2&quot;) .and() .withUser(&quot;lisi&quot;).password(new BCryptPasswordEncoder().encode(&quot;123456&quot;)).roles(&quot;VIP2&quot;, &quot;VIP3&quot;) .and() .withUser(&quot;wangwu&quot;).password(new BCryptPasswordEncoder().encode(&quot;123456&quot;)).roles(&quot;VIP1&quot;, &quot;VIP3&quot;); &#125; 开启自动配置的登录功能 /login 来登录页 重定项到/login?error 表示登录失败 默认 post 形式的/login 代表处理登录 一但定制 loginPage； 那么 loginPage 的 post 请求就是登录 1234567891011@Overrideprotected void configure(HttpSecurity http) throws Exception &#123; //super.configure(http); http.authorizeRequests().antMatchers(&quot;/&quot;).permitAll() .antMatchers(&quot;/level1/**&quot;).hasRole(&quot;VIP1&quot;) .antMatchers(&quot;/level2/**&quot;).hasRole(&quot;VIP2&quot;) .antMatchers(&quot;/level2/**&quot;).hasRole(&quot;VIP3&quot;); // 开启自动登录功能 http.formLogin();&#125; 定制页面 1http.formLogin().usernameParameter(&quot;username&quot;).passwordParameter(&quot;password&quot;).loginPage(&quot;/userlogin&quot;); ④ 注销123&lt;form th:action=&quot;@&#123;/logout&#125;&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;注销&quot; /&gt;&lt;/form&gt; 123456789101112131415@Overrideprotected void configure(HttpSecurity http) throws Exception &#123; //super.configure(http); http.authorizeRequests().antMatchers(&quot;/&quot;).permitAll() .antMatchers(&quot;/level1/**&quot;).hasRole(&quot;VIP1&quot;) .antMatchers(&quot;/level2/**&quot;).hasRole(&quot;VIP2&quot;) .antMatchers(&quot;/level2/**&quot;).hasRole(&quot;VIP3&quot;); // 开启自动登录功能 http.formLogin(); // 开启注销功能 http.logout(); // 注销成功会返回 /login?logout 页面 // http.logout().logoutSuccessUrl(&quot;/&quot;); 注销成功以后来到首页&#125; ⑤ 记住我12http.rememberMe(); 登陆成功以后，将 cookie 发给浏览器保存，以后访问页面带上这个 cookie，只要通过检查就可以免登录 点击注销会删除 cookie 定制： 123456&lt;form th:action=&quot;@&#123;/userlogin&#125;&quot; method=&quot;post&quot;&gt; 用户名:&lt;input name=&quot;username&quot; /&gt;&lt;br /&gt; 密码:&lt;input name=&quot;password&quot; /&gt;&lt;br /&gt; &lt;input type=&quot;checkbox&quot; name=&quot;remeber&quot; /&gt; 记住我&lt;br /&gt; &lt;input type=&quot;submit&quot; value=&quot;登陆&quot; /&gt;&lt;/form&gt; 12345678@Overrideprotected void configure(HttpSecurity http) throws Exception &#123; .....跟上面一致，省略了 // 记住我 http.rememberMe().rememberMeParameter(&quot;remeber&quot;);&#125; 三、SpringSecurity 标签 需要引入 thymeleaf-extras-springsecurity5 123456789&lt;properties&gt; &lt;thymeleaf-extras-springsecurity5.version&gt;3.0.4.RELEASE&lt;/thymeleaf-extras-springsecurity5.version&gt;&lt;/properties&gt;&lt;dependency&gt; &lt;groupId&gt;org.thymeleaf.extras&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-extras-springsecurity5&lt;/artifactId&gt; &lt;version&gt;3.0.4.RELEASE&lt;/version&gt;&lt;/dependency&gt; 使用 sec:authentication=“name” 获得当前用户的用户名 sec:authorize=“hasRole(‘ADMIN’)” 当前用户必须拥有 ADMIN 权限时才会显示标签内容 xmlns:sec=”http://www.thymeleaf.org/extras/spring-security 12345&lt;!DOCTYPE html&gt;&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot; xmlns:sec=&quot;http://www.thymeleaf.org/extras/spring-security&quot;&gt;&lt;/html&gt; 示例： 1234567891011121314151617&lt;div sec:authorize=&quot;!isAuthenticated()&quot;&gt; // 不登入显示以下 &lt;h2 align=&quot;center&quot;&gt; 游客您好，如果想查看武林秘籍 &lt;a th:href=&quot;@&#123;/userlogin&#125;&quot;&gt;请登录&lt;/a&gt; &lt;/h2&gt;&lt;/div&gt;&lt;div sec:authorize=&quot;isAuthenticated()&quot;&gt; // 登录显示这个 &lt;h2&gt; &lt;span sec:authentication=&quot;name&quot;&gt;&lt;/span&gt;，您好,您的角色有： &lt;span sec:authentication=&quot;principal.authorities&quot;&gt;&lt;/span&gt; &lt;/h2&gt; &lt;form th:action=&quot;@&#123;/logout&#125;&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;注销&quot; /&gt; &lt;/form&gt;&lt;/div&gt; 12345678&lt;div sec:authorize=&quot;hasRole(&#x27;VIP1&#x27;)&quot;&gt; &lt;h3&gt;普通武功秘籍&lt;/h3&gt; &lt;ul&gt; &lt;li&gt;&lt;a th:href=&quot;@&#123;/level1/1&#125;&quot;&gt;罗汉拳&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a th:href=&quot;@&#123;/level1/2&#125;&quot;&gt;武当长拳&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a th:href=&quot;@&#123;/level1/3&#125;&quot;&gt;全真剑法&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 四、官方文档https://www.thymeleaf.org/doc/articles/springsecurity.htmlhttps://github.com/thymeleaf/thymeleaf-extras-springsecurity该文档介绍了不同版本的 thymeleaf、 springsecurity 、thymeleaf-extras-springsecurity 对应使用以及一些使用示例 源码下载： 链接：https://pan.baidu.com/s/1oT_Dro3yi4xvSJqccU8D2g提取码：ljj7","categories":[{"name":"JavaEE框架","slug":"JavaEE框架","permalink":"http://blog.oy6090.top/categories/JavaEE%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"java","slug":"java","permalink":"http://blog.oy6090.top/tags/java/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://blog.oy6090.top/tags/SpringBoot/"}]},{"title":"SpringBoot和Spring Cloud","slug":"Spring Boot和Spring Cloud","date":"2020-10-03T16:00:00.000Z","updated":"2020-10-25T02:29:49.383Z","comments":true,"path":"posts/2187905911.html","link":"","permalink":"http://blog.oy6090.top/posts/2187905911.html","excerpt":"","text":"一、Spring Cloud​ Spring Cloud 是一个分布式的整体解决方案。 Spring Cloud 为开发者提供了在分布式系统（配置管理，服务发现，熔断，路由，微代理，控制总线，一次性 token，全局琐， leader 选举，分布式 session，集群状态）中快速构建的工具，使用 Spring Cloud 的开发者可以快速的启动服务或构建应用、同时能够快速和云平台资源进行对接。 SpringCloud 分布式开发五大常用组件 服务发现——Netflix Eureka 客服端负载均衡——Netflix Ribbon 断路器——Netflix Hystrix 服务网关——Netflix Zuul 分布式配置——Spring Cloud Config 二、微服务 Martin Fowler 微服务原文 https://martinfowler.com/articles/microservices.html 三、Spring Cloud 入门项目结构： 先创建一个空项目来存放 ① 编写 EurekaServer 注册中心 1. 项目结构 2.配置 Eureka 信息12345678910server: port: 8761eureka: instance: hostname: eureka-server # eureka实例的主机名 client: register-with-eureka: false #不把自己注册到eureka上 fetch-registry: false # 不从eureka上获取服务器的注册信息 service-url: defaultZone: http://localhost:8761/eureka/ 3.@EnableEurekaServer123456789@EnableEurekaServer@SpringBootApplicationpublic class EurekaServerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaServerApplication.class, args); &#125;&#125; 4.启动 ② 编写服务提供者 1.项目结构 2.编写 service 层 和 controller 层12345678@Servicepublic class TicketService &#123; public String getTicket()&#123; System.out.println(&quot;8001&quot;); return &quot;《姜子牙》&quot;; &#125;&#125; 12345678910@RestControllerpublic class TicketController &#123; @Autowired TicketService ticketService; @GetMapping(value = &quot;/ticket&quot;) public String getTicket() &#123; return ticketService.getTicket(); &#125;&#125; 3.配置信息123456789101112server: port: 8001spring: application: name: provider-ticketeureka: instance: prefer-ip-address: true # 注册服务的时候使用服务的ip地址 client: service-url: defaultZone: http://localhost:8761/eureka/ 4.启动去 Eureka 注册中心查看，http://localhost:8761/eureka/ 5.负载均衡为了显示效果，使用 Maven 仓库的打包，我复制一份提供者，改一下启动端口吗，防止冲突。 把包复制出来存放在文件夹里，并启动 ​ 8002 一样的方法启动即可 注册中心显示，都成功注入 ③ 编写服务消费者 1.项目结构 2.编写 controller 和 RestTemplate 模板123456789101112@RestControllerpublic class UserController &#123; @Autowired RestTemplate restTemplate; @GetMapping(&quot;/buy&quot;) public String buyTicket(String name)&#123; String s = restTemplate.getForObject(&quot;http://PROVIDER-TICKET/ticket&quot;,String.class); return name + &quot;购买了&quot; + s; &#125;&#125; @EnableDiscoveryClient 1234567891011121314@EnableDiscoveryClient // 开启发现服务功能@SpringBootApplicationpublic class ConsumerUserApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ConsumerUserApplication.class, args); &#125; @LoadBalanced // 使用负载均衡机制 @Bean public RestTemplate restTemplate()&#123; return new RestTemplate(); &#125;&#125; 3.配置信息123456789101112spring: application: name: consumer-userserver: port: 8200eureka: instance: prefer-ip-address: true # 注册服务的时候使用服务的ip地址 client: service-url: defaultZone: http://localhost:8761/eureka/ 4.启动 负载均衡生效 整合完成！！！","categories":[{"name":"JavaEE框架","slug":"JavaEE框架","permalink":"http://blog.oy6090.top/categories/JavaEE%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"java","slug":"java","permalink":"http://blog.oy6090.top/tags/java/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://blog.oy6090.top/tags/SpringBoot/"}]},{"title":"SpringBoot与任务","slug":"SpringBoot与任务","date":"2020-10-02T16:00:00.000Z","updated":"2020-10-25T02:30:52.323Z","comments":true,"path":"posts/315616543.html","link":"","permalink":"http://blog.oy6090.top/posts/315616543.html","excerpt":"","text":"一、异步任务两个注解： @EnableAysns、@Aysnc 代码示例： 123456789@EnableAsync // 开启异步注解功能@SpringBootApplicationpublic class SpringBoot04TaskApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringBoot04TaskApplication.class, args); &#125;&#125; 【AsyncService.java】 1234567891011121314@Servicepublic class AsyncService &#123; // 告诉spring这是一个异步方法 @Async public void hello()&#123; try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;处理数据中....&quot;); &#125;&#125; 【AsyncController.java】 123456789101112@RestControllerpublic class AsyncController &#123; @Autowired private AsyncService asyncService; @GetMapping(value = &quot;/hello&quot;) public String hello()&#123; asyncService.hello(); return &quot;success&quot;; &#125;&#125; 二、定时任务两个注解： @EnableScheduling、 @Scheduled cron 表达式： 开启基于注解的定任务 123456789@EnableScheduling // 开启基于注解的定时任务@SpringBootApplicationpublic class SpringBoot04TaskApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringBoot04TaskApplication.class, args); &#125;&#125; 【ScheduledService.java】 second(秒), minute（分）, hour（时）, day of month（日）, month（月）, day of week（周几） 对应：0 * * * * MON-FR 【0 0/5 14,18 * * ?】 每天 14 点整，和 18 点整，每隔 5 分钟执行一次 【0 15 10 ? * 1-6】 每个月的周一至周六 10:15 分执行一次 【0 0 2 ? * 6L】每个月的最后一个周六凌晨 2 点执行一次 【0 0 2 LW * ?】每个月的最后一个工作日凌晨 2 点执行一次 【0 0 2-4 ? * 1#1】每个月的第一个周一凌晨 2 点到 4 点期间，每个整点都执行一次； 1234567891011@Servicepublic class ScheduledService &#123; //@Scheduled(cron = &quot;0 * * * * MON-SAT&quot;) // 整点执行一次// @Scheduled(cron = &quot;0,1,2,3,4 * * * * MON-SAT&quot;) // 0,1,2,3,4 各执行一次// @Scheduled(cron = &quot;0-4 * * * * MON-SAT&quot;) //0-4执行 @Scheduled(cron = &quot;0/4 * * * * MON-SAT&quot;) // 每4秒执行一次 public void hello()&#123; System.out.println(&quot;hello...&quot;); &#125;&#125; 三、邮件任务① 导入 pom 依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt;&lt;/dependency&gt; ② 配置 application.properties1234spring.mail.username=// 自己的邮箱spring.mail.password=spring.mail.host=smtp.qq.comspring.mail.properties.mail.smtp.ssl.enable=true spring.mail.password 怎么获取：(以 QQ 邮箱为例) 登入 QQ 邮箱 ③ 测试基本格式： 123456789101112131415161718@AutowiredJavaMailSenderImpl javaMailSender;@Testvoid contextLoads() &#123; SimpleMailMessage message = new SimpleMailMessage(); // 邮件设置 message.setSubject(&quot;通知-今晚开会&quot;); message.setText(&quot;今晚7:30开会&quot;); // 邮件接收 message.setTo(&quot;2640379231@qq.com&quot;); // 邮件发送 message.setFrom(&quot;2097291754@qq.com&quot;); javaMailSender.send(message);&#125; 复杂格式 123456789101112131415161718192021222324@AutowiredJavaMailSenderImpl javaMailSender;@Testpublic void test02() throws MessagingException &#123; // 1.创建一个复杂的消息邮件 MimeMessage mimeMessage = javaMailSender.createMimeMessage(); MimeMessageHelper helper = new MimeMessageHelper(mimeMessage, true); // 邮件设置 helper.setSubject(&quot;通知-今晚开会&quot;); // 开启html 渲染，默认是false helper.setText(&quot;&lt;b style=&#x27;color:red&#x27;&gt;今天 7:30 开会&lt;/b&gt;&quot;, true); helper.setTo(&quot;2640379231@qq.com&quot;); helper.setFrom(&quot;2097291754@qq.com&quot;); // 上传文件 helper.addAttachment(&quot;1.jpg&quot;,new File(&quot;C:\\\\Users\\\\hp\\\\Desktop\\\\OY\\\\图片\\\\1.jpg&quot;)); helper.addAttachment(&quot;2.jpg&quot;,new File(&quot;C:\\\\Users\\\\hp\\\\Desktop\\\\OY\\\\图片\\\\2.jpg&quot;)); javaMailSender.send(mimeMessage);&#125;","categories":[{"name":"JavaEE框架","slug":"JavaEE框架","permalink":"http://blog.oy6090.top/categories/JavaEE%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"java","slug":"java","permalink":"http://blog.oy6090.top/tags/java/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://blog.oy6090.top/tags/SpringBoot/"}]},{"title":"SpringBoot与检索(ElasticSearch)","slug":"SpringBoot与检索(ElasticSearch)","date":"2020-10-02T16:00:00.000Z","updated":"2020-10-25T02:30:23.064Z","comments":true,"path":"posts/4004677012.html","link":"","permalink":"http://blog.oy6090.top/posts/4004677012.html","excerpt":"","text":"一、ElasticSearch 安装环境 Linux CentOS 7 Docker 容器 二、安装步骤① 下载 docker ElasticSearch 容器镜像Docker Hub 镜像下载地址：https://hub.docker.com/ 1docker pull elasticsearch:7.6.2 ② 启动镜像映射1docker run -e ES_JAVA_OPTS=&quot;-Xms256m -Xmx256m&quot; -d -p 9200:9200 -p 9300:9300 --name ES01 elasticsearch:7.6.2 注意：根据自己情况来配置 ==-e ES_JAVA_OPTS=”-Xms256m -Xmx256m”== 不配置的话，启动会占用你的 2G 内存，反之，配置的话，启动则根据你配置的内存来分配。 异常：如果启动后，docker 容器自动关闭，且无法访问 1docker logs -f id[容器id] // 查看启动日志 123456789// 修改 elasticsearch.yml 配置即可解决// 先查找 elasticsearch.ymlfind / -name elasticsearch.ymlvim elasticsearch.yml 路径// 在elasticsearch.yml添加下面内容bootstrap.system_call_filter: falsecluster.initial_master_nodes: [&quot;node-1&quot;] 解决详细方法，请参考博客 运行下面这条指令，并重新启动容器 1sysctl -w vm.max_map_count=262144 12//重新启动容器docker start 容器[id] ③ 测试 三、ElasticSearch 基本语法请参考官方文档进行学习 简单示例演示：使用工具: Postman 发送成功： 注意：如果 put 出现 503 错误，需要在配置elasticsearch.yml文件中添加 1node.name: node-1 查询： 四、整合 ElasticSearch ​ springBoot 2.3.0 版本及以后版本不支持 es 查询工具 jestClient 自动注入 ① Jest2.2 版本 1.引入 jest12345&lt;dependency&gt; &lt;groupId&gt;io.searchbox&lt;/groupId&gt; &lt;artifactId&gt;jest&lt;/artifactId&gt; &lt;version&gt;6.3.1&lt;/version&gt;&lt;/dependency&gt; 2. application.yml 配置1spring.elasticsearch.jest.uris=http://192.168.64.129:9200 3.创建 bean12345678910public class Article &#123; @JestId private Integer id; private String author; private String title; private String content;// get、set省略。。。。&#125; 4.测试1234567891011121314151617181920@Autowiredprivate JestClient jestClient;@Testvoid contextLoads() &#123; Article article = new Article(); article.setId(1); article.setTitle(&quot;三国演义&quot;); article.setAuthor(&quot;罗贯中&quot;); article.setContent(&quot;Hello World&quot;); Object source; Index index = new Index.Builder(article).index(&quot;sanguo&quot;).type(&quot;news&quot;).build(); try &#123; jestClient.execute(index); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 2.3 版本 由于 springboot 2.3.0 以后版本不支持自动注入 JestClient，如下图我们在 yml 文件中配置 JestClient 时会出现划掉的线提示。我们采取手动配置的方式 1.引入 jest12345&lt;dependency&gt; &lt;groupId&gt;io.searchbox&lt;/groupId&gt; &lt;artifactId&gt;jest&lt;/artifactId&gt; &lt;version&gt;6.3.1&lt;/version&gt;&lt;/dependency&gt; 2.创建 bean12345678910public class Article &#123; @JestId private Integer id; private String author; private String title; private String content;// get、set省略。。。。&#125; 3.手动注入和测试【jestClient.java】 1234567891011@Repositorypublic class jestClient &#123; public JestClient getJestCline()&#123; JestClientFactory factory = new JestClientFactory(); factory.setHttpClientConfig(new HttpClientConfig .Builder(&quot;http://192.168.64.129:9200&quot;) .multiThreaded(true) .build()); return factory.getObject(); &#125;&#125; 123456789101112131415@Testvoid contextLoads() &#123; Article article = new Article(); article.setId(1); article.setTitle(&quot;西游记&quot;); article.setAuthor(&quot;吴承恩&quot;); article.setContent(&quot;Hello World&quot;); Index index = new Index.Builder(article).index(&quot;xiyou&quot;).type(&quot;news&quot;).build(); try &#123; jestClient.getJestCline().execute(index); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 4.表达式测试搜索(2.2 和 2.3)更多操作：https://github.com/searchbox-io/Jest/tree/master/jest 123456789101112131415161718192021222324// 测试搜索@Testpublic void search()&#123; // 查询表达式 String json =&quot;&#123;\\n&quot; + &quot; \\&quot;query\\&quot; : &#123;\\n&quot; + &quot; \\&quot;match\\&quot; : &#123;\\n&quot; + &quot; \\&quot;content\\&quot; : \\&quot;hello\\&quot;\\n&quot; + &quot; &#125;\\n&quot; + &quot; &#125;\\n&quot; + &quot;&#125;&quot;; // 构建搜索功能 Search search = new Search.Builder(json).addIndex(&quot;xiyou&quot;).addType(&quot;news&quot;).build(); // 执行 try &#123; // 2.2 版本： SearchResult result = jestClient.execute(search); // 以下是2.3版本 SearchResult result = jestClient.getJestCline().execute(search); System.out.println(result); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; ② springDataElasticSearch2.2 版本1.application.yml 配置12spring.data.elasticsearch.cluster-name=elasticsearchspring.data.elasticsearch.cluster-nodes=118.24.44.169:9301 其他的不过多的赘述了，不在向上面分版本，其他的参考 2.3 版本，可自行百度。 2.3 版本1.引入 spring-boot-starter-data-elasticsearch1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-elasticsearch&lt;/artifactId&gt;&lt;/dependency&gt; 2.安装 Spring Data 对应版本的 ElasticSearch 版本适配说明：https://github.com/spring-projects/spring-data-elasticsearch 如果版本不适配： 1）、升级 SpringBoot 版本 2）、安装对应版本的 ES 3.手动配置 Client 现在 spring 官方推荐我们用High Level REST Client来配置 手动配置如下： 12345678910111213141516171819@Configurationpublic class ElasticSearchConfig extends AbstractElasticsearchConfiguration &#123; @Override public RestHighLevelClient elasticsearchClient() &#123; ClientConfiguration configuration = ClientConfiguration.builder( ) .connectedTo(&quot;192.168.64.129:9200&quot;) //.withConnectTimeout(Duration.ofSeconds(5)) //.withSocketTimeout(Duration.ofSeconds(3)) //.useSsl() //.withDefaultHeaders(defaultHeaders) //.withBasicAuth(username, password) // ... other options .build(); RestHighLevelClient client = RestClients.create(configuration).rest(); return client; &#125;&#125; 4.创建 bean123456789//6.0版本后，一个index只有一个type了,这里type也被移除。ES默认type为“_doc”@Document(indexName = &quot;at&quot;)public class Book &#123; private Integer id; private String bookname; private String author; //get set 构造函数，toString的得写上，这里太长就删了先&#125; 5.操作 ES 有两大类 Elasticsearch Repositories Elasticsearch Operations Elasticsearch Repositories 先用Elasticsearch Repositories，注意接口与接口的关系是 extends 12345@Repositorypublic interface Bookrepository extends ElasticsearchRepository&lt;Book,Integer&gt; &#123; //ElasticsearchCrudRepository 已经过时 List&lt;Book&gt; findBookById(int i);&#125; Elasticsearch Repositories提供了许多关键字，来帮助我们实现方法。我们只需要写抽象方法即可，Elasticsearch Repositories会根据方法名自动我们为我们实现，比如上面find和By就是关键字。我们需要在 springboot 主配置类上加上注解@EnableElasticsearchRepositories可以使用 Elasticsearch 提供的的关键字（方法）列表,常用关键字如下 然后测试一下 123456789101112131415161718192021@SpringBootTestclass ElasticsearchApplicationTests &#123; @Autowired Bookrepository bookrepository; @Test void contextLoads() &#123; Book book=new Book(1,&quot;西游记&quot;,&quot;吴承恩&quot;); bookrepository.save(book); &#125; @Test void testRepositories()&#123; //查询 //Elasticsearch Repositories提供and,by等一大堆关键字来连接JAVABEAN属性，我们写接口，他自动变成为实现类。 List&lt;Book&gt; bookById = bookrepository.findBookById(1); System.out.println(bookById.get(0)); &#125;&#125; 结果 Elasticsearch Operations ElasticsearchTemplate 是基于Transport client的,Transport client将会再 ES8.0 中被弃用,用谁不用我多说了吧。使用 Elasticsearch Operations 我们需要修改上面的配置类，需要继承AbstractElasticsearchConfiguration，因为基类AbstractElasticsearchConfiguration已经提供了ElasticsearchRestTemplate这个bean 12345678910111213141516171819@Configurationpublic class RestClientConfig extends AbstractElasticsearchConfiguration &#123; @Override public RestHighLevelClient elasticsearchClient() &#123; ClientConfiguration configuration = ClientConfiguration.builder( ) .connectedTo(&quot;192.168.100.126:9200&quot;)//9300会报错 //.withConnectTimeout(Duration.ofSeconds(5)) //.withSocketTimeout(Duration.ofSeconds(3)) //.useSsl() //.withDefaultHeaders(defaultHeaders) //.withBasicAuth(username, password) // ... other options .build(); RestHighLevelClient client = RestClients.create(configuration).rest(); return client; &#125;&#125; 使用方法 12345678910111213141516171819202122232425@SpringBootTestclass ElasticsearchApplicationTests &#123; @Autowired ElasticsearchOperations elasticsearchOperations; @Test void testSaveByOperations()&#123; Book book=new Book(2,&quot;西游记2&quot;,&quot;吴承恩二世&quot;); IndexQuery indexQuery= new IndexQueryBuilder() .withId(book.getId().toString()) .withObject(book) .build(); String documentId = elasticsearchOperations.index(indexQuery, IndexCoordinates.of(&quot;at&quot;));//返回_id(并非javabean中的ID，而是hits中的) System.out.println(documentId); &#125; @Test void testFindByOperations()&#123; Book book = elasticsearchOperations.get(&quot;2&quot;,Book.class,IndexCoordinates.of(&quot;at&quot;));//IndexCoordinates的参数为Index System.out.println(book); &#125;&#125; 结果","categories":[{"name":"JavaEE框架","slug":"JavaEE框架","permalink":"http://blog.oy6090.top/categories/JavaEE%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"java","slug":"java","permalink":"http://blog.oy6090.top/tags/java/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://blog.oy6090.top/tags/SpringBoot/"}]},{"title":"SpringBoot与消息","slug":"SpringBoot与消息","date":"2020-09-30T16:00:00.000Z","updated":"2020-10-25T02:31:03.746Z","comments":true,"path":"posts/1634411798.html","link":"","permalink":"http://blog.oy6090.top/posts/1634411798.html","excerpt":"","text":"一、概述 消息服务中两个中重要的概念：消息代理 和 目的地 消息队列主要由两种形式的目的地 队列： 点对点消息通信 主题： 发布/订阅 消息通信 异步处理： 应用解耦： 流量削峰： 点对点式： 消息发送者发送消息，消息代理将其放入一个队列中，消息接收者从队列中获取消息内容，消息读取后被移出队列 。 消息只有唯一的发送者和接受者，但并不是说只能有一个接收者 发布订阅式： 发送者（发布者）发送消息到主题，多个接受者（订阅者）监听（订阅） 这个主题，那么就会发布到达同时收到消息。 JMS (Java Message Service ) JAVA 消息服务 基于 JVM 消息代理的规范。 ActiveMQ、 HornetMQ 是 JMS 实现 AMQP（Advanced Message Queuing Protocol） 高级消息队列协议，也是一个消息代理的规范，兼容 JMS RabbitMQ 是 AMQP 的实现 Spring 支持 spring-jms 提供了对 JMS 的支持 spring-rabbit 提供了对 AMQP 的支持 需要 ConnectionFactory 的实现来连接消息代理 提供 JmsTemplate、RebbitTemplate 来发送消息 @JmsListener（JMS）、 @RabbitListener（AMQP）注解在方法上监听消息代理发布的消息 @EnableJms、@EnableRebbit 开启支持 SpringBoot 自动配置 JmsAutoConfiguration RabbitAutoConfiguration 二、RabbitMQ 简介 核心概念 Message 消息 Publisher 消息的生产者，也是一个向交换器发布消息的客户端应用程序。 Exchange 交换器，用来接收生产者发送的消息并将这些消息路由给服务器中的队列。 Queue 消息队列，用来保存消息直到发送给消费者。 Binding 绑定，用于消息队列和交换器之间的关联。 Connection 网络连接，比如一个 TCP 连接。 Channel 信道，多路复用连接中的一条独立的双向数据流通道。 Consumer 消息的消费者，表示一个从消息队列中取得消息的客户端应用程序。 Virtual Host 虚拟主机，表示一批交换器、消息队列和相关对象。 Broker 表示消息队列服务器实体 图示: 三、RabbitMQ 运行机制① AMQP 中的消息路由AMQP 中消息的路由过程和 Java 开发者熟悉的 JMS 存在一些差别， AMQP 中增加了Exchange 和 Binding 的角色。生产者把消息发布到 Exchange 上，消息最终到达队列并被消费者接收，而 Binding 决定交换器的消息应该发送到那个队列。 ② Exchange 类型Exchange 分发消息时根据类型的不同分发策略有区别，目前共四种类型：direct、 fanout、 topic、 headers 。 headers 匹配 AMQP 消息的 header 而不是路由键， headers 交换器和 direct 交换器完全一致，但性能差很多，目前几乎用不到了，所以直接看另外三种类型： Direct Exchange 消息中的路由键（routing key）如果和 Binding 中的 binding key 一致， 交换器就将消息发到对应的队列中。路由键与队列名完全匹配，如果一个队列绑定到交换机要求路由键为“dog”，则只转发 routing key 标记为“dog”的消息，不会发“dog.puppy”，也不会转发“dog.guard”等等。它是完全匹配、单播的模式。 Fanout Exchange 每个发到 fanout 类型交换器的消息都会分到所有绑定的队列上去。 fanout 交换器不处理路由键，只是简单的将队列绑定到交换器上，每个发送到交换器的消息都会被转发到与该交换器绑定的所有队列上。很像子网广播，每台子网内的主机都获得了一份复制的消息。 fanout 类型转发消息是最快的 。 Topic Echange topic 交换器通过模式匹配分配消息的路由键属性，将路由键和某个模式进行匹配，此时队列需要绑定到一个模式上。它将路由键和绑定键的字符串切分成单词，这些单词之间用点隔开。它同样也会识别两个通配符：符号“#”和符号“*” 。 #匹配 0 个或多个单词， *匹配一个单词。 四、RabbitMQ 安装启动① 环境准备 Linux CentOS7 docker 容器 ② 安装步骤 在 docker hub 中找到 rebbitMQ 镜像 下载镜像，docker 安装 12// 选择3-mansgement 带web管理界面docker pull rabbitmq:3-management 启动 rebbitMQ 容器 1docker run -d -p 5672:5672 -p 15672:15672 --name mybebbitmq rabbitmq:3-management 访问 前提：保证 linux 防火墙暂时关闭，才能给外网访问。 初始用户和密码： guest 五、RabbitMQ 整合idea 创建工程 ① 引入 spring-boot-starter-amqp1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;&lt;/dependency&gt; ② application.yml 配置123spring.rabbitmq.host=192.168.64.129spring.rabbitmq.username=guestspring.rabbitmq.password=guest ③ 测试 RabbitMQ1. AmqpAdmin：管理组件12345678910111213141516@Autowiredprivate AmqpAdmin amqpAdmin;@Testvoid createExchange() &#123; // 创建exchange amqpAdmin.declareExchange(new DirectExchange(&quot;amqpadmin.exchange&quot;)); System.out.println(&quot;创建完成&quot;); // 创建Queue amqpAdmin.declareQueue(new Queue(&quot;amqpadmin.queue&quot;, true)); // 创建绑定规则 amqpAdmin.declareBinding(new Binding(&quot;amqpadmin.queue&quot;, Binding.DestinationType.QUEUE, &quot;amqpadmin.exchange&quot;, &quot;amqpadmin.queue&quot;, null));&#125; 2.RabbitTemplate: 消息发送处理文件点对点发送： 1234567891011@Autowiredprivate RabbitTemplate rabbitTemplate;@Testpublic void test1()&#123; // Message 需要自己构建一个；定义消息体内容和消息头// rabbitTemplate.send(exchange,routeKey, message); // object默认当成消息体，只需要传入要发送的消息，自动序列化发送给rabbitmq;// rabbitTemplate.convertAndSend(exchange, object); rabbitTemplate.convertAndSend(&quot;amqpadmin.exchange&quot;,&quot;amqpadmin.queue&quot;,&quot;测试:test.msg&quot;);&#125; 接收： 12345678// 接收数据@Testpublic void receive()&#123; Object o = rabbitTemplate.receiveAndConvert(&quot;amqpadmin.queue&quot;); System.out.println(o.getClass()); System.out.println(o);&#125; 第二种发送，以 Json 方式 1234567891011// 第二种发送，以Json方式@Testpublic void test1()&#123; // 以Json 数据格式发送 HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;msg&quot;,&quot;这是第一条消息&quot;); map.put(&quot;data&quot;,Arrays.asList(&quot;helloworld&quot;,123,true)); rabbitTemplate.convertAndSend(&quot;amqpadmin.exchange&quot;,&quot;amqpadmin.queue&quot;, map); // rabbitTemplate.convertAndSend(&quot;amqpadmin.exchange&quot;,&quot;amqpadmin.queue&quot;,new Book(&quot;西游记&quot;,&quot;吴承恩&quot;));&#125; 发送的 Json 数据被序列化，没有显示正常的 json 数据格式，解决方式：自定义序列方式采用 JSON 123456789@Configurationpublic class MyAMQConfig &#123; // 自定义序列的为Json 格式 @Bean public MessageConverter messageConverter()&#123; return new Jackson2JsonMessageConverter(); &#125;&#125; 广播12345678910// 先创建ExchangeamqpAdmin.declareExchange(new FanoutExchange(&quot;amqpadmin.fanout&quot;));// 绑定Binding.DestinationType.QUEUE,&quot;amqpadmin.fanout&quot;,&quot;amqpadmin.queue&quot;,null));@Testpublic void sendMsg()&#123; rabbitTemplate.convertAndSend(&quot;amqpadmin.fanout&quot;,&quot;&quot;,new Book(&quot;红楼梦&quot;,&quot;曹雪芹&quot;));&#125; 监听器1234567891011121314@Servicepublic class BookService &#123; @RabbitListener(queues = &quot;amqpadmin.queue&quot;) public void receive(Book book)&#123; System.out.println(&quot;收到消息:&quot; + book); &#125; @RabbitListener(queues = &quot;amqpadmin.queue&quot;) public void receive2(Message message)&#123; System.out.println(message.getBody()); System.out.println(message.getMessageProperties()); &#125;&#125;","categories":[{"name":"JavaEE框架","slug":"JavaEE框架","permalink":"http://blog.oy6090.top/categories/JavaEE%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"java","slug":"java","permalink":"http://blog.oy6090.top/tags/java/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://blog.oy6090.top/tags/SpringBoot/"}]},{"title":"LayUI快速入门","slug":"LayUI快速入门","date":"2020-09-16T16:00:00.000Z","updated":"2020-12-28T00:30:44.127Z","comments":true,"path":"posts/3956353174.html","link":"","permalink":"http://blog.oy6090.top/posts/3956353174.html","excerpt":"","text":"[TOC] 一、引言1.1 介绍 官网：https://www.layui.com/ 在官网首页，可以很方便的下载 LayUI 二、环境搭建2.1 下载 在官网下载即可完成 下载的 LayUI 解压后，将其中的 layUI 目录导入项目中 将 layui 目录放到 webapp 目录下 在 JSP 中导入 layui 依赖 12&lt;link rel=&quot;stylesheet&quot; href=&quot;$&#123;pageContext.servletContext.contextPath&#125;/layui/css/layui.css&quot;&gt;&lt;script src=&quot;$&#123;pageContext.servletContext.contextPath&#125;&quot;&gt;&lt;/script&gt; 或 12&lt;link rel=&quot;stylesheet&quot; href=&quot;$&#123;pageContext.request.contextPath&#125;/layui/css/layui.css&quot;&gt;&lt;script src=&quot;$&#123;pageContext.request.contextPath&#125;/layui/layui.js&quot;&gt;&lt;/script&gt; 三、页面元素3.1 布局 响应式栅格布局，每行分 12 等分 123456789101112131415161718192021222324252627&lt;!--layui-container居中显示有固定的尺寸： layui-fiuid 占满行宽--&gt;&lt;!--&lt;div class=&quot;layui-container&quot;&gt;--&gt;&lt;div class=&quot;layui-fluid&quot;&gt; &lt;div class=&quot;layui-row&quot;&gt; &lt;div class=&quot;layui-col-md9 layui-col-lg6 layui-bg-orange&quot;&gt;你的内容 9/12&lt;/div&gt; &lt;div class=&quot;layui-col-md3 layui-col-lg6 layui-bg-gray&quot;&gt;你的内容 3/12&lt;/div&gt; &lt;/div&gt; &lt;%--移动设备、平板、桌面端的不同表现：--%&gt; &lt;div class=&quot;layui-row&quot;&gt; &lt;div class=&quot;layui-col-xs6 layui-col-sm6 layui-col-md4 layui-col-lg3&quot;&gt; 移动：6/12 | 平板：6/12 | 桌面：4/12; &lt;/div&gt; &lt;div class=&quot;layui-col-xs6 layui-col-sm6 layui-col-md4 layui-col-lg3&quot;&gt; 移动：6/12 | 平板：6/12 | 桌面：4/12; &lt;/div&gt; &lt;div class=&quot;layui-col-xs4 layui-col-sm12 layui-col-md4 layui-col-lg3&quot;&gt; 移动：4/12 | 平板：12/12 | 桌面：4/12; &lt;/div&gt; &lt;div class=&quot;layui-col-xs4 layui-col-sm7 layui-col-md8 layui-col-lg3&quot;&gt; 移动：4/12 | 平板：7/12 | 桌面：8/12; &lt;/div&gt; &lt;div class=&quot;layui-col-xs4 layui-col-sm5 layui-col-md4 layui-col-lg3&quot;&gt; 移动：4/12 | 平板：5/12 | 桌面：4/12; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 3.2 字体图标 class=”layui-icon 具体的图标样式” 12345&lt;i class=&quot;layui-icon layui-icon-heart-fill&quot;&gt;&lt;/i&gt;&lt;i class=&quot;layui-icon layui-icon-light&quot; style=&quot;font-size: 30px; color: #1E9FFF;&quot;&gt;&lt;/i&gt; 3.3 按钮 class=”layui-btn 主题 样式” 1234567891011121314151617181920212223&lt;button type=&quot;button&quot; class=&quot;layui-btn&quot;&gt;标准的按钮&lt;/button&gt;&lt;a href=&quot;http://www.layui.com&quot; class=&quot;layui-btn&quot;&gt;可跳转的按钮&lt;/a&gt;&lt;a href=&quot;http://www.layui.com&quot; class=&quot;layui-btn layui-btn-primary&quot; &gt;主题的按钮&lt;/a&gt;&lt;a href=&quot;http://www.layui.com&quot; class=&quot;layui-btn layui-btn-primary layui-btn-sm&quot; &gt;主题的按钮&lt;/a&gt;&lt;a href=&quot;http://www.layui.com&quot; class=&quot;layui-btn layui-btn-primary layui-btn-radius &quot; &gt;圆角的按钮&lt;/a&gt;&lt;a href=&quot;http://www.layui.com&quot; class=&quot;layui-btn layui-btn-primary layui-btn-sm layui-btn-radius &quot;&gt; &lt;i class=&quot;layui-icon layui-icon-heart-fill&quot; style=&quot;font-size: 30px; color: #1E9FFF;&quot; &gt;&lt;/i&gt; 带图标的按钮&lt;/a&gt; 3.4 表单 class=”layui-from” 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697&lt;form class=&quot;layui-form&quot; action=&quot;&quot;&gt; &lt;div class=&quot;layui-form-item&quot;&gt; &lt;label class=&quot;layui-form-label&quot;&gt;输入框&lt;/label&gt; &lt;div class=&quot;layui-input-block&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;title&quot; required lay-verify=&quot;required&quot; placeholder=&quot;请输入标题&quot; autocomplete=&quot;off&quot; class=&quot;layui-input&quot; /&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;layui-form-item&quot;&gt; &lt;label class=&quot;layui-form-label&quot;&gt;密码框&lt;/label&gt; &lt;div class=&quot;layui-input-inline&quot;&gt; &lt;input type=&quot;password&quot; name=&quot;password&quot; required lay-verify=&quot;required&quot; placeholder=&quot;请输入密码&quot; autocomplete=&quot;off&quot; class=&quot;layui-input&quot; /&gt; &lt;/div&gt; &lt;div class=&quot;layui-form-mid layui-word-aux&quot;&gt;辅助文字&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;layui-form-item&quot;&gt; &lt;label class=&quot;layui-form-label&quot;&gt;选择框&lt;/label&gt; &lt;div class=&quot;layui-input-block&quot;&gt; &lt;select name=&quot;city&quot; lay-verify=&quot;required&quot;&gt; &lt;option value=&quot;&quot;&gt;请选择城市&lt;/option&gt; &lt;option value=&quot;0&quot;&gt;北京&lt;/option&gt; &lt;option value=&quot;1&quot;&gt;上海&lt;/option&gt; &lt;option value=&quot;2&quot;&gt;广州&lt;/option&gt; &lt;option value=&quot;3&quot;&gt;深圳&lt;/option&gt; &lt;option value=&quot;4&quot;&gt;杭州&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;layui-form-item&quot;&gt; &lt;label class=&quot;layui-form-label&quot;&gt;复选框&lt;/label&gt; &lt;div class=&quot;layui-input-block&quot;&gt; &lt;input type=&quot;checkbox&quot; name=&quot;like[write]&quot; title=&quot;写作&quot; /&gt; &lt;input type=&quot;checkbox&quot; name=&quot;like[read]&quot; title=&quot;阅读&quot; checked /&gt; &lt;input type=&quot;checkbox&quot; name=&quot;like[dai]&quot; title=&quot;发呆&quot; /&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;layui-form-item&quot;&gt; &lt;label class=&quot;layui-form-label&quot;&gt;开关&lt;/label&gt; &lt;div class=&quot;layui-input-block&quot;&gt; &lt;input type=&quot;checkbox&quot; name=&quot;switch&quot; lay-skin=&quot;switch&quot; /&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;layui-form-item&quot;&gt; &lt;label class=&quot;layui-form-label&quot;&gt;单选框&lt;/label&gt; &lt;div class=&quot;layui-input-block&quot;&gt; &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;男&quot; title=&quot;男&quot; /&gt; &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;女&quot; title=&quot;女&quot; checked /&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;layui-form-item layui-form-text&quot;&gt; &lt;label class=&quot;layui-form-label&quot;&gt;文本域&lt;/label&gt; &lt;div class=&quot;layui-input-block&quot;&gt; &lt;textarea name=&quot;desc&quot; placeholder=&quot;请输入内容&quot; class=&quot;layui-textarea&quot; &gt;&lt;/textarea&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;layui-form-item&quot;&gt; &lt;div class=&quot;layui-input-block&quot;&gt; &lt;button class=&quot;layui-btn layui-btn-lg&quot; lay-submit lay-filter=&quot;formDemo&quot;&gt; 立即提交 &lt;/button&gt; &lt;button type=&quot;button&quot; class=&quot;layui-btn&quot; id=&quot;test1&quot;&gt; &lt;i class=&quot;layui-icon&quot;&gt;&amp;#xe67c;&lt;/i&gt;上传图片 &lt;/button&gt; &lt;/div&gt; &lt;/div&gt;&lt;/form&gt;&lt;script&gt; // 必须要导入form模块，才能保证表单正常渲染 layui.use(&quot;form&quot;, function () &#123; var form = layui.form; //监听提交 form.on(&quot;submit(formDemo)&quot;, function (data) &#123; // data就是表单中的所有数据 layer.msg(JSON.stringify(data.field)); return false; &#125;); &#125;);&lt;/script&gt; 3.5 数据表格3.5.1 动态表格 动态表格 12345678910111213141516171819202122232425&lt;table id=&quot;demo&quot; lay-filter=&quot;test&quot;&gt;&lt;/table&gt;&lt;script&gt; // 必须要导入 table模块 layui.use(&#x27;table&#x27;,...) layui.use(&quot;table&quot;, function () &#123; var table = layui.table; // 为表格填充数据 table.render(&#123; elem: &quot;#demo&quot;, height: 312, url: &quot;$&#123;pageContext.request.contextPath&#125;/data.jsp&quot;, //获取数据 page: true, // 开启分页 cols: [ [ //表头 &#123; field: &quot;id&quot;, title: &quot;ID&quot;, sort: true &#125;, &#123; field: &quot;username&quot;, width: 80, title: &quot;用户名&quot; &#125;, &#123; field: &quot;sex&quot;, width: 80, title: &quot;性别&quot;, sort: true &#125;, &#123; field: &quot;city&quot;, title: &quot;城市&quot; &#125;, //没定义宽度则占满剩余所有宽度，都不定义则所有列均分 &#123; field: &quot;score&quot;, width: 80, title: &quot;评分&quot;, sort: true &#125;, &#123; field: &quot;right&quot;, title: &quot;操作&quot;, toolbar: &quot;#barDemo&quot; &#125;, ], ], &#125;); &#125;);&lt;/script&gt; 数据格式如下： code: 0 代表查询成功， 为 1 是， 会显示 msg 中的内容 count 是为了分页准备的，共有多少条数据 1234567891011121314151617181920212223// 格式如下：&#123; &quot;msg&quot;: &quot;no data&quot;, &quot;code&quot;: 0, &quot;data&quot;: [ &#123; &quot;id&quot;: 1, &quot;username&quot;: &quot;shine1&quot;, &quot;sex&quot;: &quot;男&quot;, &quot;city&quot;: &quot;保定&quot;, &quot;score&quot;: 100 &#125;, &#123; &quot;id&quot;: 2, &quot;username&quot;: &quot;shine2&quot;, &quot;sex&quot;: &quot;女&quot;, &quot;city&quot;: &quot;石家庄&quot;, &quot;score&quot;: 100 &#125;, &#123; &quot;id&quot;: 3, &quot;username&quot;: &quot;shine3&quot;, &quot;sex&quot;: &quot;男&quot;, &quot;city&quot;: &quot;邢台&quot;, &quot;score&quot;: 100 &#125; ], &quot;count&quot;: 100&#125; 3.5.2 分页参数 分页条细节定制 12345678910111213141516171819202122&lt;table id=&quot;demo&quot; lay-filter=&quot;test&quot;&gt;&lt;/table&gt;&lt;script&gt; // 必须要导入 table模块 layui.use(&#x27;table&#x27;,...) layui.use(&#x27;table&#x27;, function()&#123; var table = layui.table; // 为表格填充数据 table.render(&#123; elem: &#x27;#demo&#x27; ,height: 312 ,url: &#x27;$&#123;pageContext.request.contextPath&#125;/data.jsp&#x27; //获取数据 ,page: &#123;limit:1//每页显示1条 ,limits:[1,2,3] //可选每页条数 ,first: &#x27;首页&#x27; //首页显示文字，默认显示页号 ,last: &#x27;尾页&#x27; ,prev: &#x27;&lt;em&gt;←&lt;/em&gt;&#x27; //上一页显示内容，默认显示 &gt; &lt; ,next: &#x27;&lt;i class=&quot;layui-icon layui-icon-next&quot;&gt;&lt;/i&gt;&#x27; ,layout:[&#x27;prev&#x27;, &#x27;page&#x27;, &#x27;next&#x27;,&#x27;count&#x27;,&#x27;limit&#x27;,&#x27;skip&#x27;,&#x27;refresh&#x27;] //自定义分页布局 &#125; //开启分页 ,cols: [[.....]] &#125;); &#125;);&lt;/script&gt; 3.5.3 显示工具栏 右上角工具按钮 toolbar:true 123456789101112131415&lt;script&gt; // 必须要导入 table模块 layui.use(&#x27;table&#x27;,...) layui.use(&#x27;table&#x27;, function()&#123; var table = layui.table; // 为表格填充数据 table.render(&#123; elem: &#x27;#demo&#x27; ,height: 312 ,toolbar:true ,url: &#x27;$&#123;pageContext.request.contextPath&#125;/data.jsp&#x27; //获取数据 ,page: &#123;...&#125; //开启分页 ,cols: [[...]] &#125;); &#125;);&lt;/script&gt; 3.5.4 操作按钮 为每行增加操作按钮 123456789101112131415161718192021222324252627282930&lt;table id=&quot;demo&quot; lay-filter=&quot;test&quot;&gt;&lt;/table&gt;&lt;script&gt; // 必须要导入 table模块 layui.use(&#x27;table&#x27;,...) layui.use(&quot;table&quot;, function () &#123; var table = layui.table; // 为表格填充数据 table.render(&#123; elem: &quot;#demo&quot;, height: 312, toolbar: true, url: &quot;$&#123;pageContext.request.contextPath&#125;/data.jsp&quot;, //获取数据 cols: [ [ //表头 &#123; field: &quot;id&quot;, title: &quot;ID&quot;, sort: true &#125;, &#123; field: &quot;username&quot;, width: 80, title: &quot;用户名&quot; &#125;, &#123; field: &quot;sex&quot;, width: 80, title: &quot;性别&quot;, sort: true &#125;, &#123; field: &quot;city&quot;, title: &quot;城市&quot; &#125;, //没定义宽度则占满剩余所有宽度，都不定义则所有列均分 &#123; field: &quot;score&quot;, width: 80, title: &quot;评分&quot;, sort: true &#125;, &#123; field: &quot;right&quot;, title: &quot;操作&quot;, toolbar: &quot;#barDemo&quot; &#125;, ], ], &#125;); &#125;);&lt;/script&gt;&lt;!-- 如下script可以定义在页面的任何位置 --&gt;&lt;script type=&quot;text/html&quot; id=&quot;barDemo&quot;&gt; &lt;a class=&quot;layui-btn layui-btn-xs&quot; lay-event=&quot;edit&quot;&gt;编辑&lt;/a&gt; &lt;a class=&quot;layui-btn layui-btn-danger layui-btn-xs&quot; lay-event=&quot;del&quot;&gt;删除&lt;/a&gt;&lt;/script&gt; 3.5.5 操作按钮回调 按钮的单击事件 1234567891011121314151617181920212223242526// 事件注册table.on(&quot;tool(test)&quot;, function (obj) &#123; var data = obj.data; //获得当前行数据 //获得 lay-event 对应的值（也可以是表头的 event 参数对应的值） var layEvent = obj.event; var tr = obj.tr; //获得当前行 tr 的 DOM 对象（如果有的话） if (layEvent === &quot;del&quot;) &#123; //删除 layer.confirm(&quot;真的删除行么&quot;, function (index) &#123; // 向服务端发送删除请求 // 此处可以发送ajax obj.del(); //删除对应行（tr）的DOM结构 layer.close(index); &#125;); &#125; else if (layEvent === &quot;edit&quot;) &#123; //编辑 // 向服务端发送更新请求 // 同步更新缓存对应的值 obj.update(&#123; username: &quot;shine001&quot;, city: &quot;北京&quot;, sex: &quot;女&quot;, score: 99, &#125;); &#125;&#125;); 3.6 导航 导航条 class = “layui-nav” 水平导航条 class=”layui-nav layui-tree” 垂直导航条 12345678910111213141516171819&lt;ul class=&quot;layui-nav&quot; lay-filter=&quot;&quot;&gt; &lt;li class=&quot;layui-nav-item&quot;&gt;&lt;a href=&quot;&quot;&gt;最新活动&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;layui-nav-item layui-this&quot;&gt;&lt;a href=&quot;&quot;&gt;产品&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;layui-nav-item&quot;&gt;&lt;a href=&quot;&quot;&gt;大数据&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;layui-nav-item&quot;&gt; &lt;a href=&quot;javascript:;&quot;&gt;解决方案&lt;/a&gt; &lt;dl class=&quot;layui-nav-child&quot;&gt; &lt;!-- 二级菜单 --&gt; &lt;dd&gt;&lt;a href=&quot;&quot;&gt;移动模块&lt;/a&gt;&lt;/dd&gt; &lt;dd&gt;&lt;a href=&quot;&quot;&gt;后台模版&lt;/a&gt;&lt;/dd&gt; &lt;dd&gt;&lt;a href=&quot;&quot;&gt;电商平台&lt;/a&gt;&lt;/dd&gt; &lt;/dl&gt; &lt;/li&gt; &lt;li class=&quot;layui-nav-item&quot;&gt;&lt;a href=&quot;&quot;&gt;社区&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;script&gt; //注意：导航 依赖 element 模块，否则无法进行功能性操作 layui.use(&quot;element&quot;, function () &#123;&#125;);&lt;/script&gt; 3.7 动画 LayUI 提供动画支持 样式表 描述 layui-anim-up 从最底层往上滑入 layui-anim-upbit 微微往上滑入 layui-anim-scale 平滑放大 layui-anim-scaleSpring 弹簧式放大 layui-anim-fadein 渐现 layui-anim-fadeout 渐隐 layui-anim-rotate 360 度旋转 追加：layui-anim-loop 循环动画 123456789&lt;!-- 整个div会在页面显示时，以特定动画显示出来 --&gt;&lt;div class=&quot;layui-anim layui-anim-up&quot; style=&quot;height: 100px&quot;&gt;aa&lt;/div&gt;&lt;!-- 额外添加样式类：layui-anim-loop 使得动画循环运行 --&gt;&lt;div class=&quot;layui-anim layui-anim-rotate layui-anim-loop&quot; style=&quot;text-align:center;line-height: 100px;margin-left:50px;height: 100px;width:100px&quot;&gt; bb&lt;/div&gt; 四、内置模块4.1 layer4.1.1 弹窗方法 弹窗 msg()、alert()、confirm() 12345678910&lt;script&gt; // 导入 layer模块 layui.use([&quot;layer&quot;],function()&#123; var layer = layui.layer; layer.msg(&quot;hello world!!&quot;); layer.msg(&quot;确定吗？&quot;,&#123;btn:[&quot;确定！&quot;,&quot;放弃！&quot;], yes:function(i)&#123;layer.close(i);layer.msg(&quot;yes!!!&quot;)&#125;, btn2:function(i)&#123;layer.close(i);layer.msg(&quot;no!!!&quot;)&#125;&#125; );&lt;/script&gt; 123456789101112&lt;script&gt; // 导入 layer模块 layui.use([&quot;layer&quot;],function()&#123; var layer = layui.layer; //0-6 7种图标 0:warning 1:success 2:error 3:question 4:lock 5:哭脸 6：笑脸 layer.alert(&quot;alert弹框蓝&quot;, &#123;title:&#x27;alert&#x27;,icon:6 &#125;, function()&#123;//点击“确定”按钮时的回调 layer.msg(&quot;好滴&quot;); &#125; );&lt;/script&gt; 12345678910&lt;script&gt; // 导入 layer模块 layui.use([&quot;layer&quot;],function()&#123; var layer = layui.layer; layer.confirm(&quot;你确定要删除吗?&quot;, &#123;shade:false,icon:3,btn:[&quot;好滴&quot;,&quot;不行&quot;]&#125;, function()&#123;layer.msg(&quot;好滴！&quot;);&#125;, function()&#123;layer.msg(&quot;不行！&quot;)&#125; );&lt;/script&gt; 4.1.2 弹窗属性 type 弹窗类型，可选值 0-4 title 弹窗标题， 可选值 text/array content 弹窗内容， 可选值 text/html/dom 123456789101112131415161718192021222324&lt;script&gt; // 导入 layer模块 layui.use([&quot;layer&quot;], function () &#123; var layer = layui.layer; layer.open(&#123; type: 1, // 消息框，没有确定按钮 title: [&quot;hello&quot;, &quot;padding-left:5px&quot;], // 标题，及标题样式 content: layui.$(&quot;#testmain&quot;), // dom格式 offset: &quot;rb&quot;, //可以在右下角显示 shade: false, //是否遮罩 &#125;); layer.open(&#123; type: 2, // iframe加载，需要一个url content: &quot;$&#123;pageContext.request.contextPath&#125;/XX&quot;, &#125;); &#125;);&lt;/script&gt;&lt;div id=&quot;testmain&quot; style=&quot;display:none;padding:10px; height: 173px; width: 275px;&quot;&gt; hello world!&lt;/div&gt; 4.2 layDate 日期框 1234567891011121314151617181920212223242526272829303132&lt;form class=&quot;layui-form layui-form-pane&quot; action=&quot;&quot; method=&quot;post&quot;&gt; &lt;!-- layui-form-item 一个输入项--&gt; &lt;div class=&quot;layui-form-item&quot;&gt; &lt;label class=&quot;layui-form-label&quot;&gt;生日&lt;/label&gt; &lt;!-- layui-input-block 输入框会占满除文字外的整行 --&gt; &lt;div class=&quot;layui-input-block&quot;&gt; &lt;input readonly id=&quot;birth&quot; type=&quot;text&quot; name=&quot;birth&quot; placeholder=&quot;请选择生日日期&quot; autocomplete=&quot;off&quot; class=&quot;layui-input&quot; /&gt; &lt;/div&gt; &lt;/div&gt;&lt;/form&gt;&lt;script&gt; layui.use([&quot;laydate&quot;, &quot;form&quot;], function () &#123; var laydate = layui.laydate; var upload = layui.upload; var layer = layui.layer; //执行一个laydate实例 laydate.render(&#123; elem: &quot;#birth&quot;, //指定元素 format: &quot;yyyy/MM/dd&quot;, value: &quot;2012/12/12&quot;, //默认值 // value:new Date() //默认值 &#125;); &#125;);&lt;/script&gt; 4.3 upload 上传按钮 12345678910111213141516171819202122232425262728293031323334353637383940&lt;form class=&quot;layui-form layui-form-pane&quot; action=&quot;&quot; method=&quot;post&quot;&gt; &lt;div class=&quot;layui-form-item&quot;&gt; &lt;div class=&quot;layui-input-block&quot;&gt; &lt;button class=&quot;layui-btn layui-btn-lg&quot; lay-submit lay-filter=&quot;formDemo&quot;&gt; 立即提交 &lt;/button&gt; &lt;button type=&quot;button&quot; class=&quot;layui-btn&quot; id=&quot;test1&quot;&gt; &lt;i class=&quot;layui-icon&quot;&gt;&amp;#xe67c;&lt;/i&gt;上传图片 &lt;/button&gt; &lt;/div&gt; &lt;/div&gt;&lt;/form&gt;&lt;script&gt; layui.use([&quot;upload&quot;, &quot;layer&quot;], function () &#123; var upload = layui.upload; var layer = layui.layer; //执行一个laydate实例 laydate.render(&#123; elem: &quot;#birth&quot;, //指定元素 format: &quot;yyyy/MM/dd&quot;, value: &quot;2012/12/12&quot;, //默认值 // value:new Date() //默认值 &#125;); //执行实例 var uploadInst = upload.render(&#123; elem: &quot;#test1&quot;, //绑定元素 url: &quot;/data.jsp&quot;, //上传接口 //,accept:&#x27;images&#x27; // file代表所有文件，默认是images代表图片 size: 100, // 文件最大100kb done: function (res) &#123; //上传完毕回调 layer.msg(&quot;ok&quot;); &#125;, error: function () &#123; //请求异常回调 layer.msg(&quot;error&quot;); &#125;, &#125;); &#125;);&lt;/script&gt; 4.4 carousel 轮播图 1234567891011121314151617181920&lt;div class=&quot;layui-carousel&quot; id=&quot;test1&quot;&gt; &lt;div carousel-item style=&quot;text-align: center;line-height: 280px&quot;&gt; &lt;div&gt;条目1&lt;/div&gt; &lt;div&gt;条目2&lt;/div&gt; &lt;div&gt;条目3&lt;/div&gt; &lt;div&gt;条目4&lt;/div&gt; &lt;div&gt;条目5&lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt; layui.use([&quot;carousel&quot;], function () &#123; var carousel = layui.carousel; //建造实例 carousel.render(&#123; elem: &quot;#test1&quot;, width: &quot;100%&quot;, //设置容器宽度 arrow: &quot;always&quot;, //始终显示箭头 &#125;); &#125;);&lt;/script&gt; 其他的请参考官方文档","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://blog.oy6090.top/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"layui","slug":"layui","permalink":"http://blog.oy6090.top/tags/layui/"}]},{"title":"SpringBoot 启动配置原理","slug":"springBoot 启动配置原理","date":"2020-09-14T16:00:00.000Z","updated":"2020-10-25T02:31:41.049Z","comments":true,"path":"posts/2781775372.html","link":"","permalink":"http://blog.oy6090.top/posts/2781775372.html","excerpt":"","text":"springBoot 启动配置原理 springBoot 几个重要的事件回调机制 配置在 META_INF/spring.factories ApplicationContextInitializer SpringApplicationRunListener 只需要放在 ioc 容器中 ApplicationRunner CommanLineRunner 启动流程： 一、 创建 SpringApplication 对象（1.x 版本）123456789101112131415initialize(sources);private void initialize(Object[] sources) &#123; // 保存主配置类 if (sources != null &amp;&amp; sources.length &gt; 0) &#123; this.sources.addAll(Arrays.asList(sources)); &#125; // 判断当前是否一个web应用 this.webEnvironment = deduceWebEnvironment(); // 从类的路径下找到META-INF/spring.factories配置的所有ApplicationContextInitializer；然后保存起来 setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class)); // 从类路径下找到META-INF/spring.factories配置的所有ApplicationListener setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class)); // 从多个配置类中找到有main方法的主配置类 this.mainApplicationClass = deduceMainApplicationClass();&#125; 二、 运行 run 方法(1.x 和 2.x)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public ConfigurableApplicationContext run(String... args) &#123; StopWatch stopWatch = new StopWatch(); stopWatch.start(); ConfigurableApplicationContext context = null; Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = new ArrayList(); this.configureHeadlessProperty(); // 获取SpringApplicationRunListeners; 从类路径下META-INF/spring.factories SpringApplicationRunListeners listeners = this.getRunListeners(args); // 回调所有的获取SpringApplicationApplicationRunListener.starting()方法 listeners.starting(); Collection exceptionReporters; try &#123; //封装命令行参数 ApplicationArguments applicationArguments = new DefaultApplicationArguments(args); // 准备环境 ConfigurableEnvironment environment = this.prepareEnvironment(listeners, applicationArguments); this.configureIgnoreBeanInfo(environment); // 创建环境完成后回调SpringApplicationRunListener.environmentPrepared();表示环境准备完成 Banner printedBanner = this.printBanner(environment); // 创建ApplicationContext; 决定创建web的ioc还是普通的ioc context = this.createApplicationContext(); exceptionReporters = this.getSpringFactoriesInstances(SpringBootExceptionReporter.class, new Class[]&#123;ConfigurableApplicationContext.class&#125;, context); // 准备上下文环境；将environment保存到ioc中；而且applyInitalizers(); // applyInitalizers(): 回调之前保存的所有的ApplicationContextInitalizer的initze的方法 // 回调所有的SpringApplicationRunListener的contextPrepared() this.prepareContext(context, environment, listeners, applicationArguments, printedBanner); // propareContext运行完成之后回调所有的SpringApplicationRunLitsener的contextLocaded(); // 刷新容器； ioc容器初始化（如果是web应用还会创建嵌入式的Tomcat）; // 扫描,创建,加载所有组件的地方 this.refreshContext(context); // 从ioc容器中获取所有的ApplicationRunner和CommandLineRunner进行回调 // 所有的Application先回调，CommandLineRunner在回调 this.afterRefresh(context, applicationArguments); stopWatch.stop(); if (this.logStartupInfo) &#123; (new StartupInfoLogger(this.mainApplicationClass)).logStarted(this.getApplicationLog(), stopWatch); &#125; // 所有的SpringApplicationRunListener回调started方法 listeners.started(context); this.callRunners(context, applicationArguments); &#125; catch (Throwable var10) &#123; this.handleRunFailure(context, var10, exceptionReporters, listeners); throw new IllegalStateException(var10); &#125; try &#123; listeners.running(context); // 整个SpringBoot应用启动完成以后返回启动的ioc容器 return context; &#125; catch (Throwable var9) &#123; this.handleRunFailure(context, var9, exceptionReporters, (SpringApplicationRunListeners)null); throw new IllegalStateException(var9); &#125;&#125; 三、事件监听机制配置在 META-INF/spring.factories ApplicationContextInitalizer 1234567public class HelloApplicationContextInitializer implements ApplicationContextInitializer &#123; @Override public void initialize(ConfigurableApplicationContext configurableApplicationContext) &#123; System.out.println(&quot;ApplicationContextInitializer...initialize...&quot;+configurableApplicationContext); &#125;&#125; SpringApplicationRunListener 123456789101112131415161718192021222324252627282930313233public class HelloSpringApplicationRunListener implements SpringApplicationRunListener &#123; // 必须要有构造器 public HelloSpringApplicationRunListener(SpringApplication application, String[] args)&#123; &#125; @Override public void environmentPrepared(ConfigurableEnvironment environment) &#123; Object o = environment.getSystemProperties().get(&quot;os.name&quot;); System.out.println(&quot;SpringApplicationRunListener...environmentPrepared..&quot;+o); &#125; @Override public void contextPrepared(ConfigurableApplicationContext context) &#123; System.out.println(&quot;SpringApplicationRunListener...contextPrepared...&quot;); &#125; @Override public void contextLoaded(ConfigurableApplicationContext context) &#123; System.out.println(&quot;SpringApplicationRunListener...contextLoaded...&quot;); &#125; @Override public void started(ConfigurableApplicationContext context) &#123; System.out.println(&quot;SpringApplicationRunListener...starting...&quot;); &#125; @Override public void failed(ConfigurableApplicationContext context, Throwable exception) &#123; System.out.println(&quot;SpringApplicationRunListener...finished...&quot;); &#125;&#125; 配置（META-INFO/spring.factories） 12345org.springframework.context.ApplicationContextInitializer=\\com.oy.springboot.listener.HelloApplicationContextInitializerorg.springframework.boot.SpringApplicationRunListener=\\com.oy.springboot.listener.HelloSpringApplicationRunListener 只需要放在 ioc 容器中 ApplicationRunner 1234567@Componentpublic class HelloApplicationRunner implements ApplicationRunner &#123; @Override public void run(ApplicationArguments args) throws Exception &#123; System.out.println(&quot;ApplicationRunner...run....&quot;); &#125;&#125; CommandLineRunner 1234567@Componentpublic class HelloCommandLineRunner implements CommandLineRunner &#123; @Override public void run(String... args) throws Exception &#123; System.out.println(&quot;CommandLineRunner...run...&quot;+ Arrays.asList(args)); &#125;&#125; 测试： 自定义 starterstarter: ​ 1.编写自动配置 12345678910111213@Configuration //指定这个类是一个配置类@ConditionalOnXXX //在指定条件成立的情况下自动配置类生效@AutoConfigureAfter // 指定自动配置类的顺序@Bean // 给容器中添加组件@ConfigurationPropertie // 结合相关xxxProperties类来绑定相关的配置@EnableConfigurationProperties // 让xxxProperties生效加入到容器中自动配置类要能加载将需要启动就能加载的自动配置类，配置在META-INF/spring.factoriesorg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\\org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\\ 模式： 启动器只用来做依赖导入： 专门来写一个自动配置模块； 启动器依赖自动配置；别人只需要引入启动器（starter） eg: mybatis-spring-boot-starter; 自定义启动器名-spring-boot-starter 演示步骤（参考）： 项目结构 先创建一个空项目，然后 oy-spring-boot-starter（用 maven 创建）和 oy-spring-boot-starter-autoconfigurer（spring Initializr 创建） 【oy-spring-boot-starter】 pom.xml 配置 123456&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.oy.starter&lt;/groupId&gt; &lt;artifactId&gt;oy-spring-boot-starter-autoconfigurer&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;&lt;/dependencies&gt; 【oy-spring-boot-starter-autoconfigurer】 pom.xml 配置 12345678910111213141516171819202122232425262728&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.3.3.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.oy.starter&lt;/groupId&gt; &lt;artifactId&gt;oy-spring-boot-starter-autoconfigurer&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;oy-spring-boot-starter-autoconfigurer&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 【HelloProperties】 123456789101112131415161718192021@ConfigurationProperties(prefix = &quot;oy.hello&quot;)public class HelloProperties &#123; private String prefix; private String suffix; public String getPrefix() &#123; return prefix; &#125; public void setPrefix(String prefix) &#123; this.prefix = prefix; &#125; public String getSuffix() &#123; return suffix; &#125; public void setSuffix(String suffix) &#123; this.suffix = suffix; &#125;&#125; 【HelloService】 123456789101112131415public class HelloService &#123; HelloProperties helloProperties; public HelloProperties getHelloProperties() &#123; return helloProperties; &#125; public void setHelloProperties(HelloProperties helloProperties) &#123; this.helloProperties = helloProperties; &#125; public String sayHellAtguigu(String name)&#123; return helloProperties.getPrefix()+&quot;-&quot; +name + helloProperties.getSuffix(); &#125; 【HelloServiceAutoConfiguration】 123456789101112131415@Configuration@ConditionalOnWebApplication // Web应用才生效@EnableConfigurationProperties(HelloProperties.class)public class HelloServiceAutoConfiguration &#123; @Autowired HelloProperties helloProperties; @Bean public HelloService helloService()&#123; HelloService service = new HelloService(); service.setHelloProperties(helloProperties); return service; &#125;&#125; 【spring.factories】 12org.springframework.boot.autoconfigure.EnableAutoConfiguration=\\com.oy.starter.HelloServiceAutoConfiguration 测试： **spring-boot-08-starter-test **项目结构 【pom.xml】 12345&lt;dependency&gt; &lt;groupId&gt;com.oy.stater&lt;/groupId&gt; &lt;artifactId&gt;oy-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;/dependency&gt; 【HelloController.java】 1234567891011@RestControllerpublic class HelloController &#123; @Autowired HelloService helloService; @GetMapping(&quot;/hello&quot;) public String hello()&#123; return helloService.sayHellAtguigu(&quot;haha&quot;); &#125;&#125;","categories":[{"name":"JavaEE框架","slug":"JavaEE框架","permalink":"http://blog.oy6090.top/categories/JavaEE%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"java","slug":"java","permalink":"http://blog.oy6090.top/tags/java/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://blog.oy6090.top/tags/SpringBoot/"}]},{"title":"SpringBoot与缓存","slug":"SpringBoot与缓存","date":"2020-09-14T16:00:00.000Z","updated":"2020-10-25T02:31:32.507Z","comments":true,"path":"posts/3830795892.html","link":"","permalink":"http://blog.oy6090.top/posts/3830795892.html","excerpt":"","text":"Spring Boot 与缓存创建项目结构 集成开发工具 IDEA 2020.2 ， 使用 spring 项目搭建向导创建 一、搭建基本环境 导入数据库文件，创建出department 和 employee表 1234567891011121314151617create database springboot_cache;CREATE TABLE `department` ( `id` int(11) NOT NULL AUTO_INCREMENT, `departmentName` varchar(255) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;CREATE TABLE `employee` ( `id` int(11) NOT NULL AUTO_INCREMENT, `lastName` varchar(255) DEFAULT NULL, `email` varchar(255) DEFAULT NULL, `gender` int(2) DEFAULT NULL, `d_id` int(11) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; 创建 javaBean 封装数据 【Department.java】 1234567891011121314151617181920212223242526272829303132public class Department &#123; private Integer id; private String departmentName; public Department() &#123; super(); // TODO Auto-generated constructor stub &#125; public Department(Integer id, String departmentName) &#123; super(); this.id = id; this.departmentName = departmentName; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getDepartmentName() &#123; return departmentName; &#125; public void setDepartmentName(String departmentName) &#123; this.departmentName = departmentName; &#125; @Override public String toString() &#123; return &quot;Department [id=&quot; + id + &quot;, departmentName=&quot; + departmentName + &quot;]&quot;; &#125;&#125; 【Employee.java】 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class Employee &#123; private Integer id; private String lastName; private String email; private Integer gender; //性别 1男 0女 private Integer dId; public Employee() &#123; super(); &#125; public Employee(Integer id, String lastName, String email, Integer gender, Integer dId) &#123; super(); this.id = id; this.lastName = lastName; this.email = email; this.gender = gender; this.dId = dId; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getLastName() &#123; return lastName; &#125; public void setLastName(String lastName) &#123; this.lastName = lastName; &#125; public String getEmail() &#123; return email; &#125; public void setEmail(String email) &#123; this.email = email; &#125; public Integer getGender() &#123; return gender; &#125; public void setGender(Integer gender) &#123; this.gender = gender; &#125; public Integer getdId() &#123; return dId; &#125; public void setdId(Integer dId) &#123; this.dId = dId; &#125; @Override public String toString() &#123; return &quot;Employee [id=&quot; + id + &quot;, lastName=&quot; + lastName + &quot;, email=&quot; + email + &quot;, gender=&quot; + gender + &quot;, dId=&quot; + dId + &quot;]&quot;; &#125;&#125; 整合 MyBatis 操作数据库 1）、配置数据源信息 12345678910spring.datasource.url=jdbc:mysql://localhost:3306/springboot_cache?serverTimezone=GMT%2B8spring.datasource.username=rootspring.datasource.password=1234spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver#配置mybatis驼峰命名法规则mybatis.configuration.map-underscore-to-camel-case=true#开启缓存logging.level.com.oy.springboot.mapper=debug ​ 2)、使用注解版的 Mybatis: @MapperScan 指定需要扫描的 mapper 接口所在的包 12345678@MapperScan(&quot;com.oy.springboot.mapper&quot;)@SpringBootApplicationpublic class SpringBoot01CacheApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringBoot01CacheApplication.class, args); &#125;&#125; 二、快速体验缓存==步骤：== ① 开启基于注解的缓存 @EnableCaching12345678910@MapperScan(&quot;com.oy.springboot.mapper&quot;)@SpringBootApplication@EnableCaching // 开启注解public class SpringBoot01CacheApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringBoot01CacheApplication.class, args); &#125;&#125; ② 标注缓存注解即可 @Cacheable @CacheEvict @CachePut 【EmployeeMapper】 12345678910111213141516@Mapperpublic interface EmployeeMapper &#123; @Select(&quot;select * from employee where id =#&#123;id&#125;&quot;) public Employee getEmpById(Integer id); @Update(&quot;update employee set lastName=#&#123;lastName&#125;,email=#&#123;email&#125;, gender=#&#123;gender&#125;, d_id=#&#123;dId&#125; where id=#&#123;id&#125;&quot;) public void updateEmp(Employee employee); @Delete(&quot;delete from employee where id=#&#123;id&#125;&quot;) public void insertEmpById(Integer id); @Insert(&quot;insert into employee(lastName, email, gender, d_id) values(#&#123;lastName&#125;, #&#123;email&#125;, #&#123;gender&#125;,#&#123;dId&#125;)&quot;) public void insertEmployee(Employee employee);&#125; 【EmployeeService】 12345678910111213@Servicepublic class EmployeeService &#123; @Autowired EmployeeMapper employeeMapper; @Cacheable(value = &#123;&quot;emp&quot;&#125;) public Employee getEmp(Integer id)&#123; System.out.println(&quot;查询&quot;+id + &quot;号员工&quot;); Employee emp = employeeMapper.getEmpById(id); return emp; &#125;&#125; 【EmployeeController】 123456789101112@RestControllerpublic class EmployeeController &#123; @Autowired EmployeeService employeeService; @GetMapping(&quot;emp/&#123;id&#125;&quot;) public Employee getEmployee(@PathVariable(&quot;id&quot;) Integer id)&#123; Employee emp = employeeService.getEmp(id); return emp; &#125;&#125; 测试： 第一次发送请求： 控制台输出 发送第二次请求，查看控制台没有发生改变（说明缓存生效） 三、缓存原理① 重要的概念&amp;缓存注解 注解 描述 Cache 缓存接口，定义缓存的操作。实现有：RedisCache、EhCacheCache、ConcurrentMapCache 等 CacheManager 缓存管理器，管理各种缓存（Cache ）组件 @Cacheable 主要针对方法配置，能根据方法的请求参数对其结果进行缓存 @CacheEvict 清空缓存 @CachePut 保证方法被调用，又希望结构别缓存 @EnableCaching 开启基于注解的缓存 keyGenerator 缓存数据时 key 生成策略 serialize 缓存数据时 value 序列化策略 ② CacheManager 将方法的运行结果进行缓存：以后再要相同的数据，直接从缓存中获取，不在调用方法： CacheManager 管理多个 Cache 组件的，对缓存的真正 CRUD(增删查改)操作在 Cache 组件中，每一个缓存组件有自己的唯一一个名字。 原理： 自动配置类：CacheAutoConfiguration 缓存的配置类： 1234567891011org.springframework.boot.autoconfigure.cache.GenericCacheConfigurationorg.springframework.boot.autoconfigure.cache.JCacheCacheConfigurationorg.springframework.boot.autoconfigure.cache.EhCacheCacheConfigurationorg.springframework.boot.autoconfigure.cache.HazelcastCacheConfigurationorg.springframework.boot.autoconfigure.cache.InfinispanCacheConfigurationorg.springframework.boot.autoconfigure.cache.CouchbaseCacheConfigurationorg.springframework.boot.autoconfigure.cache.RedisCacheConfigurationorg.springframework.boot.autoconfigure.cache.CaffeineCacheConfigurationorg.springframework.boot.autoconfigure.cache.GuavaCacheConfigurationorg.springframework.boot.autoconfigure.cache.SimpleCacheConfiguration【默认】org.springframework.boot.autoconfigure.cache.NoOpCacheConfiguration SimpleCacheConfiguration 配置类默认生效 在【application.properties】配置 1debug=true 控制台输出日志： 给容器中注册一个 CacheManager: ConcurrentMaCacheManager: 可以获取和创建 ConcurrentMapCache 类型的缓存组件；它的作用将数据保存砸 ConcurrentMap 中。 ③ @Cacheble运行流程： 方法运行之前，先去查看 Cache（缓存组件），按照 cacheName 指定的名字获取;(CacheManager 先获取相对应的缓存)，第一次获取缓存如果没有 Cache 组件会自动创建。 去 Cache 中查找缓存的内容，使用一个 key，默认一个 key，默认就是方法的参数； key 是按照某种策略生成的，默认是使用 keyGenerator 生成的 key： SimpleKeyGenerator 生成 key 的默认策略： ​ 如果没有参数； key=new SimpleKey() ​ 如果一个参数： key=参数的值 ​ 如果有多个参数： key=new SimpleKey(params); 没有查到缓存就调用目标方法： 将目标方法返回的结果，放进缓存中 @Cacheable 标注的方法执行之前先来检查缓存中有没有这个数据，默认按照参数的值作为 key 去查询缓存，如果没有就运行方法并将结果放入缓存；以后再来调用就可以直接使用缓存中的数据。 核心： 使用 CacheManager【ConcurrentMapCacheManager】按照名字得到 Cache【ConcurrentMapCache】组件 key 使用 keyGenerator 生成的，默认是 SimpleKeyGenerator 属性： CacheNames/value: 指定缓存组件的名字；将方法的返回结果放在哪个缓冲区，是数组的方式，可以指定多个缓存： key: 缓存数据使用 key： 可以用它来指定，默认是使用方法参数 1-方法的返回值 编写 SqEL: #id; 参数 id 的值 #a0 #p0 #root.args[0] getEmp[2] keyGenerator: key 的生成器：可以自己指定 key 的生成器的组件 id key / keyGenerator: 二选一使用 cacheManager: 指定的缓存管理器： 或者 cacheResolver 指定获取解析器 condition: 指定符号条件的情况下才缓存： eg: condition = “#a0 &gt;1” : 第一个参数的值 &gt; 1 的时候才会被缓存； 可以获取到结果进行判断 unless: 否定缓存： 当 unless 指定的条件为 true， 方法的返回值就不会被缓存；可以获取到结果进行判断 unless = “#result == null” unless = “#a0 ==2”: 如果第一个参数的值为 2，结果不缓存； sync: 是否使用异步模式 示例： 123456@Cacheable(value = &#123;&quot;emp&quot;&#125;,keyGenerator = &quot;myKeyGenerator&quot;,condition = &quot;#a0&gt;1&quot;,unless = &quot;#a0==2&quot;)public Employee getEmp(Integer id)&#123; System.out.println(&quot;查询&quot;+id+&quot;号员工&quot;); Employee emp = employeeMapper.getEmpById(id); return emp;&#125; 注意使用keyGenerator需要自行配置（参考）： 【keyGenerator】以 getEmp[2] 为例 1234567891011121314@Configurationpublic class MyCacheConfig &#123; @Bean(&quot;myKeyGenerator&quot;) public KeyGenerator keyGenerator()&#123; return new KeyGenerator()&#123; @Override public Object generate(Object o, Method method, Object... objects) &#123; // 拼接getEmp[2] 作为keyGenerator return method.getName() + &quot;[&quot;+ Arrays.asList(objects).toString()+&quot;]&quot;; &#125; &#125;; &#125;&#125; ④ @CachePut 即调用目标的方法，有更新缓存数据；同步更新缓存 修改了数据库的某个数据，同时更新缓存； 运行机制： 先调用目标方法 将目标方法的结果缓存起来 测试步骤： 查询 1 号员工： 查到的结果会放在缓存中： 更新 1 号员工：【lastName: AAA; gender:0】 在次查询 1 号员工（缓存没有更新） 解决方式： 123456@CachePut(value = &quot;emp&quot;, key = &quot;#result.id&quot;)public Employee updateEmp(Employee employee)&#123; System.out.println(&quot;updateEmp:&quot;+ employee); employeeMapper.updateEmp(employee); return employee;&#125; 可设置参数约束条件： key : 传入的 employee 对象 值： 返回的 employee 对象 key = “#employee.id”: 使用返回后的 id key =”#result.id”: 使用返回后的 id ==注意：@Cacheable 的 key 是不能用#result== ⑤ @CacheEvict 缓存清除 key: 指定要清除的数据 beforeInvocaion = false: 缓存的清除是否在方法之前执行 ​ 默认代表缓存清除的操作是在方法执行之后；如果出现异常缓存就不会清除 beforeInvocation = true: 代表清除缓存操作在方法运行之前执行，无论方法是否出现异常，缓存都要清除。 12345678@CacheEvict(value = &quot;emp&quot;, key = &quot;#id&quot;)public void deleteEmp(Integer id) &#123; System.out.println(&quot;deleteEmp:&quot; + id); //employeeMapper.deleteEmp(id); //模拟异常 //int i = 10/0;&#125; ⑥ @Caching 定义复杂的缓存规则 123456789101112@Caching( cacheable = &#123; @Cacheable(/*value=&quot;emp&quot;,*/key = &quot;#lastName&quot;) &#125;, put = &#123; @CachePut(/*value=&quot;emp&quot;,*/key = &quot;#result.id&quot;), @CachePut(/*value=&quot;emp&quot;,*/key = &quot;#result.email&quot;) &#125;)public Employee getEmpByLastName(String lastName)&#123; return employeeMapper.getEmpByLastName(lastName);&#125; ⑦ CacheConfig 抽取缓存的公共配置 123@CacheConfig(cacheNames=&quot;emp&quot;/*,cacheManager = &quot;employeeCacheManager&quot;*/)@Servicepublic class EmployeeService &#123; 四、整合 Redis 作为缓存 Redis 是一个开源（BSD 许可）的，内存中的数据结构存储系统，它可以作数据库、缓存和消息中间件。 安装 redis: 使用 Docker 1docker pull redis 引入 redis 的 starter 1docker run -d -p 6379:6379 --name myredis redis 配置 redis (下载软件 RedisDesktopManager) 4、Redis 常见 的五大数据类型 String（字符串）、List(列表)、Set(集合)、Hash(散列)、Zset（有序集合） stringRedisTemplate.opsForList()[List（列表）] stringRedisTemplate.opsForSet()[Set（集合）] stringRedisTemplate.opsForHash()[Hash（散列）] stringRedisTemplate.opsForZSet()[ZSet（有序集合）] 5、测试缓存 原理：CacheManager === Cache 缓存组件来实际缓存中存取数据 ① 引入 redis 的 starter，容器中保存的是 RedisCacheManager； 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt; ​ 在配置文件中配置 1spring.redis.host=192.168.64.129 ② RedisCacheManager 帮我们创建 RedisCache 来作为缓存组件；RedisCache 通过操作 redis 缓存数据的 123456789101112131415@AutowiredStringRedisTemplate stringRedisTemplate; // 操作k-v都是字符串的@AutowiredRedisTemplate redisTemplate;// k-v都是对象的@Testpublic void test1()&#123; // 给redis中保存数据 stringRedisTemplate.opsForValue().append(&quot;msg&quot;,&quot;hello&quot;); String msg = stringRedisTemplate.opsForValue().get(&quot;msg&quot;); System.out.println(msg); stringRedisTemplate.opsForList().leftPush(&quot;mylist&quot;,&quot;1&quot;); stringRedisTemplate.opsForList().leftPush(&quot;mylist&quot;,&quot;2&quot;);&#125; ③ 默认保存数据 k-v 都是 Object; 利用序列化保存； ​ 1）引入了 redis 的 starter， cacheManager 变为 RedisChacheManager; 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt; ​ 2) 默认创建的 RedisCacheManager 操作 redis 的时候使用的是 RedisTemplate&lt;Object, Object&gt; 123456789101112131415@AutowiredEmployeeMapper employeeMapper;@AutowiredStringRedisTemplate stringRedisTemplate; // 操作k-v都是字符串的@AutowiredRedisTemplate redisTemplate;// k-v都是对象的// 测试保存对象@Testpublic void test02()&#123; Employee empById = employeeMapper.getEmpById(1); redisTemplate.opsForValue().set(&quot;emp-01&quot;,empById);&#125; ​ 3) RedisTemplate&lt;Object, Object&gt; 是默认使用 jdk 的序列化机制 【MyRedisTemplateConfig】 123456789101112@Configurationpublic class MyRedisTemplateConfig &#123; @Bean public RedisTemplate&lt;Object, Employee&gt; employeeRedisTemplate(RedisConnectionFactory redisConnectionFactory)&#123; RedisTemplate&lt;Object, Employee&gt; template = new RedisTemplate&lt;&gt;(); template.setConnectionFactory(redisConnectionFactory); Jackson2JsonRedisSerializer&lt;Employee&gt; ser = new Jackson2JsonRedisSerializer&lt;&gt;(Employee.class); template.setDefaultSerializer(ser); return template; &#125;&#125; 测试： 123456789@ResourceRedisTemplate&lt;Object, Employee&gt; employeeRedisTemplate;@Testpublic void test02()&#123; Employee empById = employeeMapper.getEmpById(1); // 1.将数据以 JSON的方式保存 // 2. redisTemplate默认的序列化规则，改变默认的序列化规则 employeeRedisTemplate.opsForValue().set(&quot;emp-01&quot;,empById);&#125; ① 自定义 CacheManager1、 SpringBoot 1.x 版本的 RedisCacheManager 配置12345678910111213141516//自定义CacheManager @Bean public RedisCacheManager empCacheManager(RedisTemplate&lt;Object, Employee&gt; empRedisTemplate) &#123; //将我们自定义的RedisTemplate作为参数，Spring会自动为我们注入 RedisCacheManager cacheManager = new RedisCacheManager(empRedisTemplate); //使用前缀，默认会将CacheName作为key的前缀，最好设置为true，因为缓存可能有很多类 cacheManager.setUsePrefix(true); return cacheManager; &#125;&#125; 但是如果我们仅仅自定义这一个 CacheManager 则只能操作 Employee 这一种类型的数据，因为这个 CacheMananger 只实现了 Employee 的泛型，操作其他类型就会报错(可以正常缓存其他类型的数据，但是从缓存中查询出的数据在反序列化时会报错)。这时我们就需要自定义多个 CacheManager，比如增加一个可以缓存 Department 类型的 CacheMananger： 12345678910@Bean public RedisCacheManager deptCacheManager(RedisTemplate&lt;Object, Department&gt; deptRedisTemplate) &#123; RedisCacheManager cacheManager = new RedisCacheManager(deptRedisTemplate); //使用前缀，默认会将CacheName作为key的前缀 cacheManager.setUsePrefix(true); return cacheManager; &#125; 当容器中有多个 RedisCacheManager 的时候，需要使用@Primary 指定一个默认的 2、SpringBoot 2.x 版本的 RedisCacheManager 配置123456789101112@Beanpublic CacheManager cacheManager(RedisConnectionFactory redisConnectionFactory) &#123; RedisCacheConfiguration cacheConfiguration = RedisCacheConfiguration.defaultCacheConfig() // 设置缓存过期时间为一天 .entryTtl(Duration.ofDays(1)) .disableCachingNullValues() // 禁用缓存空值，不缓存null校验 .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(new GenericJackson2JsonRedisSerializer()));// 设置CacheManager的值序列化方式为json序列化，可加入@Class属性 // 设置默认的cache组件 return RedisCacheManager.builder(redisConnectionFactory).cacheDefaults(cacheConfiguration).build();&#125; 3、测试123456@Cacheable(cacheNames = &quot;dept&quot;,cacheManager =&quot;cacheManager&quot;)public Department getDeptById(Integer id) &#123; System.out.println(&quot;查询部门：&quot; + id); Department department = deptMapper.getDeptById(id); return department;&#125;","categories":[{"name":"JavaEE框架","slug":"JavaEE框架","permalink":"http://blog.oy6090.top/categories/JavaEE%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"java","slug":"java","permalink":"http://blog.oy6090.top/tags/java/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://blog.oy6090.top/tags/SpringBoot/"}]},{"title":"SpringBoot与数据访问","slug":"SpringBoot与数据访问","date":"2020-09-13T16:00:00.000Z","updated":"2020-10-25T02:31:53.272Z","comments":true,"path":"posts/2130149512.html","link":"","permalink":"http://blog.oy6090.top/posts/2130149512.html","excerpt":"","text":"SpringBoot 与数据访问一、JDBC 使用 Idea 集成开发工具搭建 pom.xml 123456789&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt; 使用 yml 配置文件进行配置 123456789spring: datasource: username: root password: 1234 url: jdbc:mysql://192.168.64.129:3307/jdbc?characterEncoding=UTF-8&amp;serverTimezone=UTC #如果使用mysql 8.0.20及以上需要指定时区 使用com.mysql.cj.jdbc.Driver，低版本的只需要把cj去掉即可 driver-class-name: com.mysql.cj.jdbc.Driver #指定使用哪个数据源,结合自己的情况而定 #type: com.alibaba.druid.pool.DruidDataSource 效果： ​ 1. 默认使用 com.zaxxer.hikari.HikariDataSource 作为数据源(springBoot 的版本为：2.3.3)； 123456789//查看DataSourceAutoConfiguration中的方法 @Configuration @Conditional(PooledDataSourceCondition.class) @ConditionalOnMissingBean(&#123; DataSource.class, XADataSource.class &#125;) @Import(&#123; DataSourceConfiguration.Hikari.class, DataSourceConfiguration.Tomcat.class, DataSourceConfiguration.Dbcp2.class, DataSourceConfiguration.Generic.class, DataSourceJmxConfiguration.class &#125;) protected static class PooledDataSourceConfiguration &#123; &#125; springboot 1.5.10版本 默认是使用 org.apache.tomcat.jdbc.pool.DataSource 作为数据源； 配置源的相关配置都在 DataSourceProperties 里面； 自动配置原理： org.springframework.boot.autoconfigure.jdbc ; 参考 DataSurceConfiguration，根据配置创建数据源，默认使用 Tomcat 连接池；可以使用 spring.datasource.type 指定自定义的数据源类型‘ 2）SpringBoot 默认可以支持： 1org.apache.tomcat.jdbc.pool.DataSource、HikariDataSource、BasicDataSource 自定义数据源类型 123456789101112/*** Generic DataSource configuration.*/@ConditionalOnMissingBean(DataSource.class)@ConditionalOnProperty(name = &quot;spring.datasource.type&quot;)static class Generic &#123; @Bean public DataSource dataSource(DataSourceProperties properties) &#123; //使用DataSourceBuilder创建数据源，利用反射创建响应type的数据源，并且绑定相关属性 return properties.initializeDataSourceBuilder().build(); &#125;&#125; 4） DataSourceInitialzer： ApplicationListener： 作用 ： ​ ① runSchemaScripts(); 运行建表语句； ​ ② runDataScripts()：运行插入的 sql 语句； 默认只需要将文件命名为： 123456schema-*.sql、data-*.sql默认规则： schema.sql , schema-all.sql可是使用 schema： - classpath:department.sql 指定位置 ==注意：SpringBoot 2.x 及以需要配置== 具体的参考我这篇博客详细介绍了 12spring.datasource.initialization-mode=always 否则不会自动创建 sql 语句 5）操作数据库：自动配置 jdbcTemplate 操作数据库 二、整合 Driuid 数据源​ pom.xml 导入依赖 12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.21&lt;/version&gt;&lt;/dependency&gt; ① 添加基本配置​ 不使用默认的配置，使用自己的配置 12345678910111213141516initialSize: 5 minIdle: 5 maxActive: 20 maxWait: 60000 timeBetweenEvictionRunsMillis: 60000 minEvictableIdleTimeMillis: 300000 validationQuery: SELECT 1 FROM DUAL testWhileIdle: true testOnBorrow: false testOnReturn: false poolPreparedStatements: true # 配置监控统计拦截的filters，去掉后监控界面sql无法统计，&#x27;wall&#x27;用于防火墙 filters: stat,wall,log4j maxPoolPreparedStatementPerConnectionSize: 20 useGlobalDataSourceStat: true connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500 【DruidConfig.java】 123456789@Configurationpublic class DruidConfig &#123; @ConfigurationProperties(prefix = &quot;spring.datasource&quot;) @Bean public DataSource druid()&#123; return new DruidDataSource(); &#125;&#125; 使用在测试类中启动 DegBug 启动 1234567891011121314151617@SpringBootTestclass SpringBoot06DateJdbcApplicationTests &#123; @Autowired DataSource dataSource; @Test void contextLoads() throws SQLException &#123; // com.zaxxer.hikari.HikariDataSource System.out.println(dataSource.getClass()); System.out.println(&quot;*********************&quot;); Connection conn = dataSource.getConnection(); System.out.println(conn); conn.close(); &#125;&#125; 启动： ​ Debug 启动出现异常，原因分析：应该在运行中缺少 log4j 的依赖，导致无法启动。 解决方法： 123456// 在pom.xml 文件中导入log4j的依赖&lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt;&lt;/dependency&gt; 启动配置生效 ② 整合 Druid 数据源【DruidConfig.java】 1234567891011121314151617181920212223242526272829303132333435// 配置Druid的监控/** * 1、 配置一个管理后台的Servlet * */@Beanpublic ServletRegistrationBean staViewServlet()&#123; ServletRegistrationBean bean = new ServletRegistrationBean(new StatViewServlet(), &quot;/druid/*&quot;); Map&lt;String, String&gt; initParams = new HashMap&lt;&gt;(); initParams.put(&quot;loginUsername&quot;,&quot;admin&quot;); initParams.put(&quot;loginPassword&quot;,&quot;12345&quot;); // 默认就是允许所有的访问 initParams.put(&quot;allow&quot;,&quot;&quot;); initParams.put(&quot;deny&quot;,&quot;192.168.64.129&quot;); bean.setInitParameters(initParams); return bean;&#125;/** * 配置一个web监控的filter * */@Beanpublic FilterRegistrationBean webStratFilert()&#123; FilterRegistrationBean bean = new FilterRegistrationBean(); bean.setFilter(new WebStatFilter()); Map&lt;String, String&gt; initParams = new HashMap&lt;&gt;(); initParams.put(&quot;exclusions&quot;,&quot;*.js, *.css, /druid/*&quot;); bean.setInitParameters(initParams); bean.setUrlPatterns(Arrays.asList(&quot;/*&quot;)); return bean;&#125; 【HelloController.java】 12345678910111213@Controllerpublic class HelloController &#123; @Autowired JdbcTemplate jdbcTemplate; @ResponseBody @GetMapping(value = &quot;/query&quot;) public Map&lt;String, Object&gt; map()&#123; List&lt;Map&lt;String, Object&gt;&gt; list = jdbcTemplate.queryForList(&quot;select * FROM department&quot;); return list.get(0); &#125;&#125; 测试： 三、 整合 Mybatis12345&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.3&lt;/version&gt;&lt;/dependency&gt; 准备步骤： 配置数据源相关属性 123456789101112131415161718192021222324252627spring: datasource: # 数据源基本配置 username: root password: 6090 driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://192.168.64.129:3307/mybatis type: com.alibaba.druid.pool.DruidDataSource # 数据源其他配置 initialSize: 5 minIdle: 5 maxActive: 20 maxWait: 60000 timeBetweenEvictionRunsMillis: 60000 minEvictableIdleTimeMillis: 300000 validationQuery: SELECT 1 FROM DUAL testWhileIdle: true testOnBorrow: false testOnReturn: false poolPreparedStatements: true # 配置监控统计拦截的filters，去掉后监控界面sql无法统计，&#x27;wall&#x27;用于防火墙 filters: stat,wall,log4j maxPoolPreparedStatementPerConnectionSize: 20 useGlobalDataSourceStat: true connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500 # 配置自动执行sql语句 initialization-mode: always 给数据库建表 在 yml 配置文件中添加 123schema: - classpath:sql/department.sql - classpath:sql/employee.sql 创建 javabean 123456789101112131415public class Employee &#123; private Integer id; private String lastName; private Integer gender; private String email; private Integer dId; //生成相应的get、set方法&#125;public class Department &#123; private Integer id; private String departmenName; // 生成相应的get、set方法&#125; ① 注解版【DepartmentMapper.java】 1234567891011121314@Mapperpublic interface DepartmentMapper &#123; @Select(&quot;select * from department where id = #&#123;id&#125;&quot;) @Delete(&quot;delete from department where id=#&#123;id&#125;&quot;) public int deleteDeptById(Integer id); @Insert(&quot;insert department(department_name) values(#&#123;departmentName&#125;)&quot;) public int insertDept(Department department); @Update(&quot;update departments set department_name=#&#123;departmentName&#125; where id=#&#123;id&#125;&quot;) public int updateDept(Department department);&#125; 【DeptController.java】 1234567891011121314151617@RestControllerpublic class DeptController &#123; @Autowired DepartmentMapper departmentMapper; @GetMapping(value = &quot;/dept/&#123;id&#125;&quot;) public Department getdepartment(@PathVariable(&quot;id&quot;) Integer id)&#123; return departmentMapper.getDeptById(id); &#125; @GetMapping(value = &quot;/dept&quot;) public Department insertDept(Department department)&#123; departmentMapper.insertDept(department); return department; &#125;&#125; 测试： ​ 出现异常，获取值不完整，原因分析 departmentName 这个属性名跟数据库的字段不一致，可以自定义增加驼峰命名来解决这个问题 1234567891011121314151617@Configurationpublic class MybatisConfig &#123; /** * 自定义配置驼峰命名规则 * @return */ @Bean public ConfigurationCustomizer configurationCustomizer()&#123; return new ConfigurationCustomizer() &#123; @Override public void customize(org.apache.ibatis.session.Configuration configuration) &#123; configuration.setMapUnderscoreToCamelCase(true); &#125; &#125;; &#125;&#125; 补充：使用 MapperScan 批量扫描所有的 Mapper 接口 12345678@MapperScan(value = &quot;com.oy.springboot06.Mapper&quot;)@SpringBootApplicationpublic class SpringBoot06DataMybatisApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringBoot06DataMybatisApplication.class, args); &#125;&#125; ② 配置文件版 在配置 yml 文件中配置 123mybatis: config-location: classpath:mybatis/mybatis-config.xml 指定全局配置文件的位置 mapper-locations: classpath:mybatis/mapper/*.xml 指定sql映射文件位置 【EmployeeMapper.class】 1234567@Mapperpublic interface EmployeeMapper &#123; public Employee getEmpById(Integer id); public void insertEmp(Employee employee);&#125; 【DeptController.java】 123456789101112@RestControllerpublic class DeptController &#123; @Autowired EmployeeMapper employeeMapper; @GetMapping(&quot;/emp/&#123;id&#125;&quot;) public Employee getEmp(@PathVariable(&quot;id&quot;) Integer id)&#123; return employeeMapper.getEmpById(id); &#125;&#125; 结构图 【mybatis-config.xml】配置驼峰命名规则 12345&lt;configuration&gt; &lt;settings&gt; &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt; &lt;/settings&gt;&lt;/configuration&gt; 测试： 更多使用参照：http://mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure/ 四、整合 SpringData JPA① SpringData 简介 ② 整合 SpringData JPA JPA ： ORM（Object Relational Mapping） 编写一个实体类(bean)和数据表进行映射，并且配置好映射关系； 12345678910111213141516171819202122/***@Description 使用JPA注解配置映射关系*@Author OY*@Date 2020/9/15*@Time 9:55*/@Entity // 告诉JPA这是一个实体类(和数据表映射的类)@Table(name = &quot;tbl_user&quot;) //@Table来指定和那个数据表对应；如果省略默认表民就是userpublic class User &#123; @Id // 这是一个主键 @GeneratedValue(strategy = GenerationType.IDENTITY)// 自增主键 private Integer id; @Column(name = &quot;last_name&quot;, length = 50) // 这是和数据表对应的一个列 private String lastName; @Column // 省略默认的列名就是属性名 private String email; // 省略get.set方法。。。。&#125; 编写一个 Dao 接口来操作实体类对应的数据表（Repository） 12345678/***@Description 继承JpaRepository来完成对数据库的操作*@Author OY*@Date 2020/9/15*@Time 10:12*/public interface UserRepository extends JpaRepository&lt;User, Integer&gt; &#123;&#125; 基本配置 JpaProperties(yml 中) 12345678910111213spring: datasource: username: root password: 123456 url: jdbc:mysql://192.168.64.129:3307/jpa driver-class-name: com.mysql.cj.jdbc.Driver initialization-mode: always jpa: hibernate: # 更新或者创建数据表结构 ddl-auto: update # 控制台显示SQL show-sql: true 4.测试 【UserController.java】 12345678910111213141516171819202122232425262728@RestControllerpublic class UserController &#123; @Autowired UserRepository userRepository; @GetMapping(&quot;/user/&#123;id&#125;&quot;) public User getUser(@PathVariable(&quot;id&quot;) Integer id)&#123; User user = new User(); user.setId(id); Example&lt;User&gt; example = Example.of(user); Optional&lt;User&gt; one = userRepository.findOne(example); return one.get(); &#125; @GetMapping(&quot;/user&quot;) public User insertUser(User user)&#123; User save = userRepository.save(user); return save; &#125; @GetMapping(&quot;/user/all&quot;) public List&lt;User&gt; getAll()&#123; List&lt;User&gt; all = userRepository.findAll(); return all; &#125;&#125;","categories":[{"name":"JavaEE框架","slug":"JavaEE框架","permalink":"http://blog.oy6090.top/categories/JavaEE%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"java","slug":"java","permalink":"http://blog.oy6090.top/tags/java/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://blog.oy6090.top/tags/SpringBoot/"}]},{"title":"SpringBoot之Docker","slug":"SpringBoot之Docker","date":"2020-09-09T16:00:00.000Z","updated":"2020-10-25T02:26:25.429Z","comments":true,"path":"posts/658751968.html","link":"","permalink":"http://blog.oy6090.top/posts/658751968.html","excerpt":"","text":"一、简介Docker 是一个开源的应用容器引擎；是一个轻量级容器技术； Docker 支持将软件编译成一个镜像；然后砸镜像中各种软件做好配置，将镜像发布出去，其实使用者可以直接使用这个镜像； 运行中的这个镜像称为容器，容器启动是非常快速的。 二、核心概念docker 主机(Host): 安装了 Docker 程序的机器（Docker 直接安装在操作系统之上）； docker 客户端（Client）: 连接 docker 主机进行操作； docker 仓库（Registry）: 用来保存各种打包好的软件镜像； docker 镜像(Images): 软件打包好的镜像；放在 docker 仓库中； docker 容器（Container）: 镜像启动后的实例就是一个容器；容器是独立的运行的一个或一组应用 使用 Docker 的步骤： 安装 Docker 去 Docker 仓库找到这个软件找到这个软件对应的镜像； 使用 Docker 运行这个镜像，这个镜像就会生成一个 Docker 容器； 对容器的启动停止就是对软件的启动停止； 三、安装 Docker① 安装 Linux 虚拟机​ 百度搜索关键字：安装linux CentOS 7 结合 xshell 软件使用 ② 在 Linux 虚拟机上安装 docker==步骤：== 检查内核版本，必须是 3.10 及以上 1uname -r 安装 docker 1yum install docker 输入 y 确定安装 启动 docker 12[root@localhost ~]# systemctl start docker[root@localhost ~]# docker -v 开机启动 docker 1[root@localhost ~]# systemctl enable docker 停止 docker 1[root@localhost ~]# systemctl stop docke ③ Docker 常用命令&amp;操作1、镜像操作 操作 命令 说明 检索 docker search 关键字 eg: docker search mysql 我们经常去 docker hub 上检索镜像的详细信息，如镜像的 TAG 拉取 docker pull 镜像名:tag :tag 是可选的，tag 表示标签，多为软件的版本，默认是 lastest 列表 docker images 查看所有的本地镜像 删除 docker rmi image-id 删除指定的本地镜像 2、容器操作软件镜像(QQ 安装程序) – 运行镜像 – 产生一个容器（正在运行的软件，运行的 QQ） 步骤（Tomcat 示例）： 搜索镜像 1docker search tomcat 拉取镜像 1docker pull tomcat 根据镜像启动容器 1docker run --name mytomcat -d tomcat:latest 查看运行中的容器 1docker ps 停止运行中的容器 1docker stop 容器的id 查看所有容器 1docker ps -a 启动容器 1docker start 容器id 删除一个容器 1docker rm 容器id 启动一个做了端口映射的 tomcat 12[root@localhost ~]# docker run ‐d ‐p 8888:8080 tomcat[root@localhost ~]# docker run --name tomcat01 ‐d ‐p 8888:8080 tomcat:tags -d: 后台运行 -p : 将主机的端口映射到容器的一个端口 主机端口：容器内部的端口 docker run ‐d ‐p 映射端口:主机端口 tomcat 如果成功映射之后无法访问，请参考这篇博客 必须关闭 Linux 的防火墙 12service firewalld status； 查看防护墙状态service firewalld stop: 关闭防火墙 查看容器的日志 12docker logs container-name/container-ideg: docker logs 30a1b4a13697 更多命令参看 https://docs.docker.com/engine/reference/commandline/docker/ 可以参考每一个镜像的文档 3、安装 MySQL 示例1docker pull mysql 启动： 1docker run --name mysql01 -e MYSQL_ROOT_PASSWORD=123456 -d mysql 1docker ps -a 做端口映射 1docker run -p 3309:3306 --name mysql03 -e MYSQL_ROOT_PASSWORD=1234 -d mysql 其他的高级操作 1docker run ‐‐name mysql03 ‐v /conf/mysql:/etc/mysql/conf.d ‐e MYSQL_ROOT_PASSWORD=my‐secret‐pw ‐d mysql:tag ​ 把主机的/conf/mysql 文件夹挂载到 mysqldocker 容器的 /etc/mysql/conf.d 文件夹里面，改 mysql 文件的配置文件就只需要把 mysql 配置文件放在自定义的文件夹下（/conf/mysql） 12docker run ‐‐name some‐mysql ‐e MYSQL_ROOT_PASSWORD=my‐secret‐pw ‐d mysql:tag ‐‐character‐set‐server=utf8mb4 ‐‐collation‐server=utf8mb4_unicode_ci ​ 指定 mysql 的一些配置参数","categories":[{"name":"JavaEE框架","slug":"JavaEE框架","permalink":"http://blog.oy6090.top/categories/JavaEE%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"java","slug":"java","permalink":"http://blog.oy6090.top/tags/java/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://blog.oy6090.top/tags/SpringBoot/"}]},{"title":"SpringBoot之Web开发","slug":"SpringBoot之Web 开发","date":"2020-08-29T16:00:00.000Z","updated":"2021-01-22T03:52:45.711Z","comments":true,"path":"posts/11889.html","link":"","permalink":"http://blog.oy6090.top/posts/11889.html","excerpt":"","text":"一、Web 开发自动配置原理： xxxAutoConfiguration: 帮助我们给容器中自动配置组件； xxxProperyties: 配置类来 1、 SpringBoot 对静态资源的映射规则12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061@ConfigurationProperties(prefix = &quot;spring.resources&quot;, ignoreUnknownFields = false)public class ResourceProperties implements ResourceLoaderAware &#123;// 可是设置和静态资源有关的参数，缓存时间等WebMvcAuotConfiguration：@Overridepublic void addResourceHandlers(ResourceHandlerRegistry registry) &#123; if (!this.resourceProperties.isAddMappings()) &#123; logger.debug(&quot;Default resource handling disabled&quot;); return; &#125; Integer cachePeriod = this.resourceProperties.getCachePeriod(); if (!registry.hasMappingForPattern(&quot;/webjars/**&quot;)) &#123; customizeResourceHandlerRegistration( registry.addResourceHandler(&quot;/webjars/**&quot;) .addResourceLocations( &quot;classpath:/META‐INF/resources/webjars/&quot;) .setCachePeriod(cachePeriod)); &#125; String staticPathPattern = this.mvcProperties.getStaticPathPattern(); // 静态资源文件夹的映射 if (!registry.hasMappingForPattern(staticPathPattern)) &#123; customizeResourceHandlerRegistration( registry.addResourceHandler(staticPathPattern) .addResourceLocations( this.resourceProperties.getStaticLocations()) .setCachePeriod(cachePeriod)); &#125;&#125; // 配置欢迎页映射 @Bean public WelcomePageHandlerMapping welcomePageHandlerMapping( ResourceProperties resourceProperties) &#123; return new WelcomePageHandlerMapping(resourceProperties.getWelcomePage(), this.mvcProperties.getStaticPathPattern()); &#125; // 配置喜欢的图标 @Configuration @ConditionalOnProperty(value = &quot;spring.mvc.favicon.enabled&quot;, matchIfMissing = true) public static class FaviconConfiguration &#123; private final ResourceProperties resourceProperties; public FaviconConfiguration(ResourceProperties resourceProperties) &#123; this.resourceProperties = resourceProperties; &#125; @Bean public SimpleUrlHandlerMapping faviconHandlerMapping() &#123; SimpleUrlHandlerMapping mapping = new SimpleUrlHandlerMapping(); mapping.setOrder(Ordered.HIGHEST_PRECEDENCE + 1); //所有 **/favicon.ico mapping.setUrlMap(Collections.singletonMap(&quot;**/favicon.ico&quot;, faviconRequestHandler())); return mapping; &#125; @Bean public ResourceHttpRequestHandler faviconRequestHandler() &#123; ResourceHttpRequestHandler requestHandler = new ResourceHttpRequestHandler(); requestHandler .setLocations(this.resourceProperties.getFaviconLocations()); return requestHandler; &#125;&#125; ==所有的/webjars/**,都去 classpath:/META-INF/resources/web/找资源== webjars ：以 jar 包的方式引入静态资源；http://www.webjars.org/ 导入依赖： 123456&lt;!--引入jquery-webjar 访问的时候只需要写webjars下面的资源名称即可--&gt;&lt;dependency&gt; &lt;groupId&gt;org.webjars.bower&lt;/groupId&gt; &lt;artifactId&gt;jquery&lt;/artifactId&gt; &lt;version&gt;3.3.1&lt;/version&gt;&lt;/dependency&gt; 测试：localhost:8080/webjars/jquery/3.3.1/dist/jquery.js ==”/**“ 访问当前项目的任何资源，都去(静态资源的文件夹)找映射。== “classpath:/META-INF/resources/“ “classpath:/resources/“ “classpath:/static/“ “classpath:/public/“ “/“:当前项目 例如： localhost:8080/abc == 去静态资源文件夹里面找 abc ==欢迎页： 静态资源文件下的所有 index.html 页面；被”/**“映射== ==所有的 **/favicaon.ico 都是在静态资源文件下找== 2、引擎模板 jsp、velocity、Freemarker、Thymeleaf SpringBoot 推荐的 Tymeleaf，语法更简单，功能更强大； ① 引入 thymeleaf12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;version&gt;2.3.1.RELEASE&lt;/version&gt;&lt;/dependency&gt; 测试： 1234@RequestMapping(value = &quot;/success&quot;) public String success()&#123; return &quot;success&quot;;&#125; 切换 thymeleaf 版本 123&lt;thymeleaf.version&gt;3.0.9.RELEASE&lt;/thymeleaf.version&gt;&lt;!-- 布局功能的支持程序 thymeleaf3主程序 layout2以上版本 --&gt;&lt;thymeleaf-layout-dialect.version&gt;2.3.0&lt;/thymeleaf-layout-dialect.version&gt; ==启动报错==： 1234567891011***************************APPLICATION FAILED TO START***************************Description:An attempt was made to call a method that does not exist. The attempt was made from the following location: org.springframework.boot.autoconfigure.thymeleaf.ThymeleafAutoConfiguration$ThymeleafDefaultConfiguration.templateEngine(ThymeleafAutoConfiguration.java:142)The following method did not exist: ==解决方案==： 1234&lt;properties&gt; &lt;springboot-thymeleaf.version&gt;3.0.9.RELEASE&lt;/springboot-thymeleaf.version&gt; &lt;thymeleaf-layout-dialect.version&gt;2.3.0&lt;/thymeleaf-layout-dialect.version&gt;&lt;/properties&gt; 原因分析： ​ 这里用的 org.springframework.boot 下的 spring-boot-starter-thymeleaf,使用&lt;thymeleaf.version&gt;做标签时的可能与 org.thymeleaf 头冲突，导致包获取不正确。 ② Thymeleaf 使用12345678910111213@ConfigurationProperties( prefix = &quot;spring.thymeleaf&quot;)public class ThymeleafProperties &#123; private static final Charset DEFAULT_ENCODING; public static final String DEFAULT_PREFIX = &quot;classpath:/templates/&quot;; public static final String DEFAULT_SUFFIX = &quot;.html&quot;; private boolean checkTemplate = true; private boolean checkTemplateLocation = true; private String prefix = &quot;classpath:/templates/&quot;; private String suffix = &quot;.html&quot;; private String mode = &quot;HTML&quot;; // ​ 只要我们把 HTML 页面的放在 classpath:/templates/, thymeleaf 就能自动渲染。 使用： 导入 thymeleaf 的名称空间 1&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;/html&gt; 使用 thymeleaf 语法 1234567891011&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;success 测试成功&lt;/h1&gt; &lt;div th:text=&quot;$&#123;hello&#125;&quot;&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; ③ 语法规则 th:text： 改变当前元素里面的内容。 th: 任意 html 属性；来替换原生的值。 表达式 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970Simple expression: (表达式语法) Variable Expressions:$&#123;...&#125;: 获取变量值; OGNL; 1)、获取对象的属性、调用方法 2)、使用内置的基本对象： # ctx: the context object. #vars: the context variables. #locale : the context locale. #request : (only in Web Contexts) the HttpServletRequest object. #response : (only in Web Contexts) the HttpServletResponse object. #session : (only in Web Contexts) the HttpSession object. #servletContext : (only in Web Contexts) the ServletContext object. $&#123;session.foo&#125; 3)、内置的一些工具对象 #execInfo : information about the template being processed. #messages : methods for obtaining externalized messages inside variables expressions, in the same way as they would be obtained using #&#123;…&#125; syntax. #uris : methods for escaping parts of URLs/URIs #conversions : methods for executing the configured conversion service (if any). #dates : methods for java.util.Date objects: formatting, component extraction, etc. #calendars : analogous to #dates , but for java.util.Calendar objects. #numbers : methods for formatting numeric objects. #strings : methods for String objects: contains, startsWith, prepending/appending, etc. #objects : methods for objects in general. #bools : methods for boolean evaluation. #arrays : methods for arrays. #lists : methods for lists. #sets : methods for sets. #maps : methods for maps. #aggregates : methods for creating aggregates on arrays or collections. #ids : methods for dealing with id attributes that might be repeated (for example, as a result of an iteration). Selection Variable Expressions: *&#123;.....&#125;： 选择表达式：和$&#123;&#125;在功能上是一样; 补充: 配合 th:object=&quot;$&#123;session.user&#125;&quot; &lt;div th:object=&quot;$&#123;session.user&#125;&quot;&gt; &lt;p&gt;Name: &lt;span th:text=&quot;*&#123;firstName&#125;&quot;&gt;Sebastian&lt;/span&gt;.&lt;/p&gt; &lt;p&gt;Surname: &lt;span th:text=&quot;*&#123;lastName&#125;&quot;&gt;Pepper&lt;/span&gt;.&lt;/p&gt; &lt;p&gt;Nationality: &lt;span th:text=&quot;*&#123;nationality&#125;&quot;&gt;Saturn&lt;/span&gt;.&lt;/p&gt; &lt;/div&gt; Message Expressions: #&#123;...&#125;: 获取国际化内容 Link URL Expressions: @&#123;....&#125;: 定义URL; @&#123;/order/process(execId=$&#123;execId&#125;,execType=&#x27;FAST&#x27;)&#125; Fragment Expressions: ~&#123;...&#125;：片段引用表达式 &lt;div th:insert=&quot;~&#123;commons :: main&#125;&quot;&gt;...&lt;/div&gt;Literals(字面量) Text literals: &#x27;one text&#x27; , &#x27;Another one! Number literals: 0 , 34 , 3.0 , 12.3 ,… Boolean literals: true , false Null literal: null Literal tokens: one , sometext , main ,…Text operations:（文本操作） String concatenation: + Literal substitutions: |The name is $&#123;name&#125;| Arithmetic operations:（数学运算） Binary operators: + , ‐ , * , / , % Minus sign (unary operator): ‐Boolean operations:（布尔运算） Binary operators: and , or Boolean negation (unary operator): ! , notComparisons and equality:（比较运算） Comparators: &gt; , &lt; , &gt;= , &lt;= ( gt , lt , ge , le ) Equality operators: == , != ( eq , ne )Conditional operators:条件运算（三元运算符） If‐then: (if) ? (then) If‐then‐else: (if) ? (then) : (else) Default: (value) ?: (defaultvalue)Special tokens: No‐Operation: _ 3、SpringMVC 自动配置​ 可以参考文档：https://docs.spring.io/spring-boot/docs/1.5.10.RELEASE/reference/htmlsingle/#boot-features-developingweb-applications ① Spring MVC auto-configurationSpring Boot 自动配置好了 SpringMVC 以下是 SpringBoot 对 SpringMVC 的默认配置：==（WebMvcAutoConfiguration）== Inclusion of ContentNegotiatingViewResolver and BeanNameViewResolver beans. 自动配置 ViewResource(视图解析器：根据方法的返回值得视图对象的（View）, 视图对象决定如何渲染（转发？重定向？）) ContextNegotiatingViewResolver: 组合所有的视图解析器的； ==如何定制：我们可以给自己容器中添加一个视图解析器；自动的将其组合进来；== Support for serving static resources, including support for WebJars (see below). 静态资源文件夹路径，webjars Static index.html support。静态首页的访问 Custom Favicon support (see below). favicon.ico 自动注册 of Converter , GenericConverter, Formatter bean Converter: 转换器；public String hello(User user): 类型转换使用 Converter Formatter 格式化器： 2020.8.29 == Date； 123456@Bean@ConditionalOnProperty(prefix = &quot;spring.mvc&quot;, name = &quot;date‐format&quot;)//在文件中配置日期格式化的规则public Formatter&lt;Date&gt; dateFormatter() &#123; return new DateFormatter(this.mvcProperties.getDateFormat());//日期格式化组件&#125; ==自己添加的格式化器转换器，我们只需要放在容器中即可== Support for HttpMessageConverters (see below) HttpMessageConverter: SpringMVC 用来转换 Http 请求和响应的 ：User—json； HttpMessageConverters 是从容器中确定；获取所有的 HttpMessageConverter; 给自己的容器中添加 HttpMessageConverter,只需要将自己的组件注册容器中（@Bean, @Component） Automatic registration of MessageCodesResolver (see below). 定义错误的代码生成规则 Automatic use of a ConfigurableWebBindingInitializer bean (see below). ==我们可以配置一个 ConfigurableWebBindingInitialzer 来替换默认的：（添加到容器）== 12初始化WebDataBinder；请求数据=====JavaBean； org.springframework.boot.autoconfigure.web 的所有的自动场景； If you want to keep Spring Boot MVC features, and you just want to add additional ==MVC configuration==(interceptors, formatters, view controllers etc.) you can add your own @Configuration class of type WebMvcConfigurerAdapter , but without @EnableWebMvc . If you wish to provide custom instances of RequestMappingHandlerMapping , RequestMappingHandlerAdapter or ExceptionHandlerExceptionResolver you can declare a WebMvcRegistrationsAdapter instance providing such components. If you want to take complete control of Spring MVC, you can add your own @Configuration annotated with @EnableWebMvc . ② 扩展 SpringMVC1234567&lt;mvc:view-controller path=&quot;/hello&quot; view-name=&quot;success&quot;/&gt;&lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path=&quot;/hello&quot;/&gt; &lt;bean&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; ==编写一个配置类（@Configuration）,是 WebMvcConfigAdapter 类型；不能标注@EnableWebMVC== 既保留所有的自动配置，也能用我们扩展的配置； 注：WebMvcConfigurerAdapter该方法在 spring boot 2.0，Spring 5.0 之后，已经被废弃 12345678910// 使用WebMvcConfigurer可以来扩展SpringMVC的功能@Configurationpublic class MyMvcConfig implements WebMvcConfigurer&#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; // super.addViewControllers(registry); // 浏览器发送 /oy 请求到 success registry.addViewController(&quot;/oy&quot;).setViewName(&quot;success&quot;); &#125;&#125; 测试： 原理： 1. WebMvcAutoConfiguration是SpringMVC的自动配置类 在做其他的自动配置时会导入：@Import（EnableWebMvcConfiguration.class） 123456789101112131415@Configurationpublic static class EnableWebMvcConfiguration extends DelegatingWebMvcConfiguration &#123; private final WebMvcConfigurerComposite configurers = new WebMvcConfigurerComposite(); // 从容器中获取所有的WebmvcConfigurer @Autowired(required = false) public void setConfigurers(List&lt;WebMvcConfigurer&gt; configurers) &#123; if (!CollectionUtils.isEmpty(configurers)) &#123; this.configurers.addWebMvcConfigurers(configurers); //一个参考实现；将所有的WebMvcConfigurer相关配置都来一起调用； @Override // public void addViewControllers(ViewControllerRegistry registry) &#123; // for (WebMvcConfigurer delegate : this.delegates) &#123; // delegate.addViewControllers(registry); // &#125;&#125; 容器中所有的 WebMvcConfigurer 都会一起起作用 我们的配置类也会被调用； 效果：SpringMVC 的自动配置和我们的扩展配置都会起作用； ③、全面接管 SpringMVC；SpringBoot 对 SpringMVC 的自动配置不需要了，所有都是我们自己配置；所有的 SpringMVC 的自动配置都失效了 我们需要在配置类中添加@EnableWebMvc 即可； 1234567891011// 使用WebMvcConfigurer可以来扩展SpringMVC的功能@Configuration@EnableWebMvcpublic class MyMvcConfig implements WebMvcConfigurer &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; /* super.addViewControllers(registry);*/ // 浏览器 /oy 请求来到 success registry.addViewController(&quot;/oy&quot;).setViewName(&quot;success&quot;); &#125;&#125; 原理：（为什么@EnableWebMvc 自动配置就失效了） @EnableWebMvc 的核心 12@Import(DelegatingWebMvcConfiguration.class)public @interface EnableWebMvc &#123; 2. 12@Configurationpublic class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport &#123; 3. 12345678@Configuration@ConditionalOnWebApplication@ConditionalOnClass(&#123; Servlet.class, DispatcherServlet.class,WebMvcConfigurerAdapter.class &#125;)//容器中没有这个组件的时候，这个自动配置类才生效@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)@AutoConfigureAfter(&#123; DispatcherServletAutoConfiguration.class,ValidationAutoConfiguration.class &#125;)public class WebMvcAutoConfiguration &#123; @EnableWebMvc 将 WebMvcConfiguationSupport 组件导入进来 导入的 WebMvcConfiguration 只是 SpringMVC 最基本功能； 5、如何修改 SpringBoot 的默认设置模式： SpringBoot 在自动配置很多组件的时候，先看容器中有没有自己配置的（@Bean、@Component）如果有就用户自己配置，如果没有，才自动配置和自己默认组合起来； 在 SpringBoot 中国会有非常多的 xxxConfigurer 帮助我们进行扩展配置 在 SpringBoot 中会有很多的 xxxCustomize 帮助我们进行定制配置 6、RestfulCRUD配置 pom 配置文件： 12345678910111213 &lt;properties&gt; &lt;!-- 布局功能的支持程序 thymeleaf3主程序 layout2以上版本 --&gt; &lt;springboot-thymeleaf.version&gt;3.0.9.RELEASE&lt;/springboot-thymeleaf.version&gt; &lt;thymeleaf-layout-dialect.version&gt;2.3.0&lt;/thymeleaf-layout-dialect.version&gt;&lt;/properties&gt;&lt;!--配置thymeleaf模板--&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;version&gt;2.3.1.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; ① 默认访问首页​ 方式一：(不推荐) 12345// 在Controller中配置 @RequestMapping(&#123;&quot;/&quot;,&quot;/index.html&quot;&#125;) public String index()&#123; return &quot;index&quot;; &#125; ​ 方式二：(推荐) 123456789101112131415161718192021222324// 使用WebConfigurerAdapter可以来扩展SpringMVC的功能// 使用@EnableWebMvc 不要接管SpringMVC@Configurationpublic class MyMvcConfig implements WebMvcConfigurer &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123;// super.addViewControllers(registry); //浏览器发送得 /oy 请求来到 success registry.addViewController(&quot;/oy&quot;).setViewName(&quot;success&quot;); &#125; // 所有的webMvcConfigAdapter组件都会一起起作用 @Bean // 将组件注册在容器 public MyMvcConfig MyMvcConfig1()&#123; MyMvcConfig config = new MyMvcConfig()&#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; registry.addViewController(&quot;/&quot;).setViewName(&quot;login&quot;); registry.addViewController(&quot;/index.html&quot;).setViewName(&quot;login&quot;); &#125; &#125;; return config; &#125;&#125; 【application.properties】 1server.servlet.context-path=/curd 测试： 提前在 POM.xml 文件中引入 bootstrap 依赖（后面需要） 123456&lt;!--引入bootstrap--&gt;&lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;bootstrap&lt;/artifactId&gt; &lt;version&gt;4.0.0&lt;/version&gt;&lt;/dependency&gt; ② 国际化 编写国际化配置文件： SpringBoot 自动配置好了管理国际化资源文件的组件（2.x 版本）： 1234567891011121314151617181920212223242526272829@Bean @ConfigurationProperties( prefix = &quot;spring.messages&quot; ) public MessageSourceProperties messageSourceProperties() &#123; return new MessageSourceProperties(); &#125; @Bean public MessageSource messageSource(MessageSourceProperties properties) &#123; ResourceBundleMessageSource messageSource = new ResourceBundleMessageSource(); if (StringUtils.hasText(properties.getBasename())) &#123; // 设置国际化资源文件的基础名（去掉语言国家代码的） messageSource.setBasenames(StringUtils.commaDelimitedListToStringArray(StringUtils.trimAllWhitespace(properties.getBasename()))); &#125; if (properties.getEncoding() != null) &#123; messageSource.setDefaultEncoding(properties.getEncoding().name()); &#125; messageSource.setFallbackToSystemLocale(properties.isFallbackToSystemLocale()); Duration cacheDuration = properties.getCacheDuration(); if (cacheDuration != null) &#123; messageSource.setCacheMillis(cacheDuration.toMillis()); &#125; messageSource.setAlwaysUseMessageFormat(properties.isAlwaysUseMessageFormat()); messageSource.setUseCodeAsDefaultMessage(properties.isUseCodeAsDefaultMessage()); return messageSource; &#125; 1.x 版本： 1234567891011121314151617181920212223242526@ConfigurationProperties(prefix = &quot;spring.messages&quot;)public class MessageSourceAutoConfiguration &#123; /** * Comma‐separated list of basenames (essentially a fully‐qualified classpath * location), each following the ResourceBundle convention with relaxed support for * slash based locations. If it doesn&#x27;t contain a package qualifier (such as * &quot;org.mypackage&quot;), it will be resolved from the classpath root. */ private String basename = &quot;messages&quot;; //我们的配置文件可以直接放在类路径下叫messages.properties； @Bean public MessageSource messageSource() &#123; ResourceBundleMessageSource messageSource = new ResourceBundleMessageSource(); if (StringUtils.hasText(this.basename)) &#123; //设置国际化资源文件的基础名（去掉语言国家代码的） messageSource.setBasenames(StringUtils.commaDelimitedListToStringArray( StringUtils.trimAllWhitespace(this.basename))); &#125; if (this.encoding != null) &#123; messageSource.setDefaultEncoding(this.encoding.name()); &#125; messageSource.setFallbackToSystemLocale(this.fallbackToSystemLocale); messageSource.setCacheSeconds(this.cacheSeconds); messageSource.setAlwaysUseMessageFormat(this.alwaysUseMessageFormat); return messageSource;&#125; 在application.properties 文件中配置： 12#指定管理国际化资源文件spring.messages.basename=i18n.login 去页面获取的国际化的值、 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, shrink-to-fit=no&quot; /&gt; &lt;meta name=&quot;description&quot; content=&quot;&quot; /&gt; &lt;meta name=&quot;author&quot; content=&quot;&quot; /&gt; &lt;title&gt;Signin Template for Bootstrap&lt;/title&gt; &lt;!-- Bootstrap core CSS --&gt; &lt;link href=&quot;asserts/css/bootstrap.min.css&quot; th:href=&quot;@&#123;/webjars/bootstrap/4.0.0/css/bootstrap.css&#125;&quot; rel=&quot;stylesheet&quot; /&gt; &lt;!-- Custom styles for this template --&gt; &lt;link href=&quot;asserts/css/signin.css&quot; th:href=&quot;@&#123;/asserts/css/signin.css&#125;&quot; rel=&quot;stylesheet&quot; /&gt; &lt;/head&gt; &lt;body class=&quot;text-center&quot;&gt; &lt;form class=&quot;form-signin&quot; action=&quot;dashboard.html&quot;&gt; &lt;img class=&quot;mb-4&quot; src=&quot;asserts/img/bootstrap-solid.svg&quot; th:src=&quot;@&#123;/asserts/img/bootstrap-solid.svg&#125;&quot; alt=&quot;&quot; width=&quot;72&quot; height=&quot;72&quot; /&gt; &lt;h1 class=&quot;h3 mb-3 font-weight-normal&quot; th:text=&quot;#&#123;login.tip&#125;&quot;&gt; Please sign in &lt;/h1&gt; &lt;label class=&quot;sr-only&quot; th:text=&quot;#&#123;login.username&#125;&quot;&gt;Username&lt;/label&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;Username&quot; th:placeholder=&quot;#&#123;login.username&#125;&quot; required=&quot;&quot; autofocus=&quot;&quot; /&gt; &lt;label class=&quot;sr-only&quot; th:text=&quot;#&#123;login.password&#125;&quot;&gt;Password&lt;/label&gt; &lt;input type=&quot;password&quot; class=&quot;form-control&quot; placeholder=&quot;Password&quot; th:placeholder=&quot;#&#123;login.password&#125;&quot; required=&quot;&quot; /&gt; &lt;div class=&quot;checkbox mb-3&quot;&gt; &lt;label&gt; &lt;input type=&quot;checkbox&quot; value=&quot;remember-me&quot; /&gt; [[#&#123;login.remember&#125;]] &lt;/label&gt; &lt;/div&gt; &lt;button class=&quot;btn btn-lg btn-primary btn-block&quot; type=&quot;submit&quot; th:text=&quot;#&#123;login.btn&#125;&quot; &gt; Sign in &lt;/button&gt; &lt;p class=&quot;mt-5 mb-3 text-muted&quot;&gt;© 2017-2018&lt;/p&gt; &lt;a class=&quot;btn btn-sm&quot;&gt;中文&lt;/a&gt; &lt;a class=&quot;btn btn-sm&quot;&gt;English&lt;/a&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 测试：（更改浏览器语言） 原理： 国际化 Locale（区域信息对象）； LocaleResolver（获取区域信息对象） 12345678910111213@Bean@ConditionalOnMissingBean@ConditionalOnProperty(prefix = &quot;spring.mvc&quot;, name = &quot;locale&quot;)public LocaleResolver localeResolver() &#123; if (this.mvcProperties .getLocaleResolver() == WebMvcProperties.LocaleResolver.FIXED) &#123; return new FixedLocaleResolver(this.mvcProperties.getLocale()); &#125; AcceptHeaderLocaleResolver localeResolver = new AcceptHeaderLocaleResolver(); localeResolver.setDefaultLocale(this.mvcProperties.getLocale()); return localeResolver;&#125;默认的就是根据请求头带来的区域信息Localhost进行国际化 点击切换国际化 【MyLocaleResolver.calss】 123456789101112131415161718// 可以在连接上携带区域的信息public class MyLocaleResolver implements LocaleResolver&#123; @Override public Locale resolveLocale(HttpServletRequest httpServletRequest) &#123; String l = httpServletRequest.getParameter(&quot;l&quot;); Locale locale = Locale.getDefault(); if(!StringUtils.isEmpty(&quot;_&quot;))&#123; String[] split = l.split(&quot;_&quot;); locale = new Locale(split[0], split[1]); &#125; return locale; &#125; @Override public void setLocale(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Locale locale) &#123; &#125;&#125; 【MyMvcConfig.class】 1234@Beanpublic LocaleResolver localeResolver()&#123; return new MyLocaleResolver();&#125; 【login.html】 12&lt;a class=&quot;btn btn-sm&quot; th:href=&quot;@&#123;/index.html(l=&#x27;zh_CN&#x27;)&#125;&quot;&gt;中文&lt;/a&gt;&lt;a class=&quot;btn btn-sm&quot; th:href=&quot;@&#123;/index.html(l=&#x27;en_US&#x27;)&#125;&quot;&gt;English&lt;/a&gt; ③ 登录开发期间模板的引擎页面修改以后，要实时生效 禁用模板引擎的缓存 12# 禁用缓存spring.thymeleaf.cache=false 页面修改完成完成以后 ctrl +f9 : 重新编译； 【MyLocaleResolver.class】 1234567891011121314151617public class MyLocaleResolver implements LocaleResolver&#123; @Override public Locale resolveLocale(HttpServletRequest httpServletRequest) &#123; String l = httpServletRequest.getParameter(&quot;l&quot;); Locale locale = Locale.getDefault(); if(!StringUtils.isEmpty(l))&#123; String[] split = l.split(&quot;_&quot;); locale = new Locale(split[0], split[1]); &#125; return locale; &#125; @Override public void setLocale(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Locale locale) &#123; &#125;&#125; 【LonginController.class】 12345678910111213141516@Controllerpublic class LonginController &#123; @PostMapping(value = &quot;/user/login&quot;) public String login(@RequestParam(&quot;username&quot;) String username, @RequestParam(&quot;password&quot;) String passsword, Map&lt;String , Object&gt; map, HttpSession session)&#123; if(!StringUtils.isEmpty(username) &amp;&amp; &quot;123456&quot;.equals(passsword))&#123; // 登陆成功，防止表单重复提交，可以重定向到主页 session.setAttribute(&quot;loginUser&quot;,username); return &quot;redirect:/main.html&quot;; &#125;else&#123; // 登录失败 map.put(&quot;msg&quot;,&quot;用户名密码错误&quot;); return &quot;login&quot;; &#125; &#125;&#125; 【MyMvcConfig.class】 123456789101112@Bean public MyMvcConfig MyMvcConfig1()&#123; MyMvcConfig config = new MyMvcConfig()&#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; registry.addViewController(&quot;/&quot;).setViewName(&quot;login&quot;); registry.addViewController(&quot;/index.html&quot;).setViewName(&quot;login&quot;); registry.addViewController(&quot;/main.html&quot;).setViewName(&quot;dashboard&quot;); &#125; &#125;; return config; &#125; 登录错误提示消息 【login.html】 1&lt;p style=&quot;color: red&quot; th:text=&quot;$&#123;msg&#125;&quot; th:if=&quot;$&#123;not #strings.isEmpty(msg)&#125;&quot;&gt;&lt;/p&gt; ④ 拦截器进行登陆检查拦截器： 1234567891011121314151617181920212223242526272829303132/***@Description 登录检查*@Author OY*@Date 2020/9/3*@Time 16:07*/public class LoginHandlerInterceptor implements HandlerInterceptor &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; Object user = request.getSession().getAttribute(&quot;loginUser&quot;); if(user == null)&#123; // 未登入，返回登录界面 request.setAttribute(&quot;msg&quot;,&quot;没有权限请先登陆&quot;); request.getRequestDispatcher(&quot;/index.html&quot;).forward(request,response); return false; &#125;else&#123; // 以登录,放行请求 return true; &#125; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; &#125;&#125; 注册拦截器：【MyMvcConfig.class】 注: 拦截器必须配置不拦截 css 样式，不然页面的 css 样式会失效 12345678910111213141516171819202122232425262728// 所有的webMvcConfig组件都会一起起作用 @Bean // 将组件注册在容器 public MyMvcConfig MyMvcConfig1()&#123; MyMvcConfig config = new MyMvcConfig()&#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; registry.addViewController(&quot;/&quot;).setViewName(&quot;login&quot;); registry.addViewController(&quot;/index.html&quot;).setViewName(&quot;login&quot;); registry.addViewController(&quot;/main.html&quot;).setViewName(&quot;dashboard&quot;); &#125; // 注册拦截器 @Override public void addInterceptors(InterceptorRegistry registry) &#123; // 静态资源： *.css , *.js // SpringBoot已经做好了静态资源映射/* registry.addInterceptor(new LoginHandlerInterceptor()).addPathPatterns(&quot;/&quot;) .excludePathPatterns(&quot;/index.html&quot;,&quot;/&quot;,&quot;/user/login&quot;,&quot;/asset/**&quot;,&quot;/webjars/**&quot;);*/ registry.addInterceptor(new LoginHandlerInterceptor()).addPathPatterns(&quot;/**&quot;) .excludePathPatterns(&quot;/index.html&quot;, &quot;/&quot;, &quot;/user/login&quot;,&quot;/static/**&quot;, &quot;/webjars/**&quot;);// &#125; &#125;; return config; &#125; ⑤ CRUD-员工列表实验要求： RestfulCURD: CURD 满足 Rest 风格； URL：/ 资源名称 / 资源标识 HTTP 请求的方式区分对资源 CRUD 操作 普通 CURD(uri 来区分操作) RestfulCRUD 查询 getEmp emp—GET 添加 addEmp?xxx emp—POST 修改 updateEmp?id=xxx&amp;xxx=xx emp/{id}—PUT 删除 deleteEmp?id=1 emp/{id}—DELETE 实验的请求架构： 实验功能 请求 URL 请求方式 查询所有员工 emps GET 查询某个员工(来到修改页面) emp/1 GET 来到添加页面 emp GET 添加员工 emps POST 来到修改页面（查出员工进行信息回显） emp/1 GET 修改员工 emp PUT 删除员工 emp/1 DELETE 员工列表 thymeleaf 公共页面元素的抽取 1、抽取公共片段 &lt;div th:fragment=”copy”&gt;&copy; 2011 The Good Thymes Virtual Grocery&lt;/div&gt; 2、引入公共片段 &lt;div th:insert=”~{footer:: copy}”&gt; ~{templatename :: selector} : 模板名 :: 选择器 ~{templatename :: fragmentname} : 模板名 :: 片段名 3、默认效果 insert 的公共片段在 div 标签中 如果使用 th:insert 等属性进行引入，可以不用写~{}； 行内写法可加上 ：[[{}]]; [[{}]] 三种引入片段的 th 属性： th: insert: 将公共整个片段插入到声明引入的元素中 th:replace： 将声明引入的元素换为公共的片段 th:include: 将被引入的片段的内容包含进这个标签中 1234567891011&lt;footer th:fragment=&quot;copy&quot;&gt;&amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/footer&gt;引入方式&lt;div th:insert=&quot;footer :: copy&quot;&gt;&lt;/div&gt;&lt;div th:replace=&quot;footer :: copy&quot;&gt;&lt;/div&gt;&lt;div th:include=&quot;footer :: copy&quot;&gt;&lt;/div&gt;效果&lt;div&gt; &lt;footer&gt;&amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/footer&gt;&lt;/div&gt;&lt;footer&gt;&amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/footer&gt;&lt;div&gt;&amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/div&gt; 抽取出公共的页面【bar.html】： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364 &lt;!--topbar--&gt; &lt;nav class=&quot;navbar navbar-dark sticky-top bg-dark flex-md-nowrap p-0&quot; th:fragment=&quot;topbar&quot;&gt; &lt;a class=&quot;navbar-brand col-sm-3 col-md-2 mr-0&quot; href=&quot;http://getbootstrap.com/docs/4.0/examples/dashboard/#&quot;&gt;[[$&#123;session.loginUser&#125;]]&lt;/a&gt; &lt;input class=&quot;form-control form-control-dark w-100&quot; type=&quot;text&quot; placeholder=&quot;Search&quot; aria-label=&quot;Search&quot;&gt; &lt;ul class=&quot;navbar-nav px-3&quot;&gt; &lt;li class=&quot;nav-item text-nowrap&quot;&gt; &lt;a class=&quot;nav-link&quot; href=&quot;http://getbootstrap.com/docs/4.0/examples/dashboard/#&quot;&gt;Sign out&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt;&lt;nav class=&quot;col-md-2 d-none d-md-block bg-light sidebar&quot; id=&quot;sidebar&quot;&gt; &lt;div class=&quot;sidebar-sticky&quot;&gt; &lt;ul class=&quot;nav flex-column&quot;&gt; &lt;li class=&quot;nav-item&quot;&gt; &lt;a class=&quot;nav-link active&quot; href=&quot;#&quot; th:href=&quot;@&#123;/main.html&#125;&quot; th:class=&quot;$&#123;activeUri==&#x27;main.html&#x27;?&#x27;nav-link active&#x27;:&#x27;nav-link&#x27;&#125;&quot;&gt; &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;24&quot; height=&quot;24&quot; viewBox=&quot;0 0 24 24&quot; fill=&quot;none&quot; stroke=&quot;currentColor&quot; stroke-width=&quot;2&quot; stroke-linecap=&quot;round&quot; stroke-linejoin=&quot;round&quot; class=&quot;feather feather-home&quot;&gt; &lt;path d=&quot;M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z&quot;&gt;&lt;/path&gt; &lt;polyline points=&quot;9 22 9 12 15 12 15 22&quot;&gt;&lt;/polyline&gt; &lt;/svg&gt; Dashboard &lt;span class=&quot;sr-only&quot;&gt;(current)&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;nav-item&quot;&gt; &lt;a class=&quot;nav-link&quot; href=&quot;http://getbootstrap.com/docs/4.0/examples/dashboard/#&quot;&gt; &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;24&quot; height=&quot;24&quot; viewBox=&quot;0 0 24 24&quot; fill=&quot;none&quot; stroke=&quot;currentColor&quot; stroke-width=&quot;2&quot; stroke-linecap=&quot;round&quot; stroke-linejoin=&quot;round&quot; class=&quot;feather feather-file&quot;&gt; &lt;path d=&quot;M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z&quot;&gt;&lt;/path&gt; &lt;polyline points=&quot;13 2 13 9 20 9&quot;&gt;&lt;/polyline&gt; &lt;/svg&gt; Orders &lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;nav-item&quot;&gt; &lt;a class=&quot;nav-link&quot; href=&quot;http://getbootstrap.com/docs/4.0/examples/dashboard/#&quot;&gt; &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;24&quot; height=&quot;24&quot; viewBox=&quot;0 0 24 24&quot; fill=&quot;none&quot; stroke=&quot;currentColor&quot; stroke-width=&quot;2&quot; stroke-linecap=&quot;round&quot; stroke-linejoin=&quot;round&quot; class=&quot;feather feather-shopping-cart&quot;&gt; &lt;circle cx=&quot;9&quot; cy=&quot;21&quot; r=&quot;1&quot;&gt;&lt;/circle&gt; &lt;circle cx=&quot;20&quot; cy=&quot;21&quot; r=&quot;1&quot;&gt;&lt;/circle&gt; &lt;path d=&quot;M1 1h4l2.68 13.39a2 2 0 0 0 2 1.61h9.72a2 2 0 0 0 2-1.61L23 6H6&quot;&gt;&lt;/path&gt; &lt;/svg&gt; Products &lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;nav-item&quot;&gt; &lt;a class=&quot;nav-link active&quot; href=&quot;#&quot; th:href=&quot;@&#123;/emps&#125;&quot; th:class=&quot;$&#123;activeUri==&#x27;emps&#x27;?&#x27;nav-link active&#x27;:&#x27;nav-link&#x27;&#125;&quot;&gt; &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;24&quot; height=&quot;24&quot; viewBox=&quot;0 0 24 24&quot; fill=&quot;none&quot; stroke=&quot;currentColor&quot; stroke-width=&quot;2&quot; stroke-linecap=&quot;round&quot; stroke-linejoin=&quot;round&quot; class=&quot;feather feather-users&quot;&gt; &lt;path d=&quot;M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2&quot;&gt;&lt;/path&gt; &lt;circle cx=&quot;9&quot; cy=&quot;7&quot; r=&quot;4&quot;&gt;&lt;/circle&gt; &lt;path d=&quot;M23 21v-2a4 4 0 0 0-3-3.87&quot;&gt;&lt;/path&gt; &lt;path d=&quot;M16 3.13a4 4 0 0 1 0 7.75&quot;&gt;&lt;/path&gt; &lt;/svg&gt; 员工管理 &lt;/a&gt; &lt;/li&gt; ......... &lt;/nva&gt; 引入(选择高亮)： 123456&lt;!--引入抽取的topbar--&gt;&lt;!--模板名: 会使用thymeleaf的前后缀的配置规则进行解析--&gt;&lt;div th:replace=&quot;commons/bar :: topbar&quot;&gt;&lt;/div&gt;&lt;!--引入sidebar--&gt;&lt;div th:replace=&quot;commons/bar :: #sidebar(activeUri=&#x27;main.html&#x27;)&quot;&gt;&lt;/div&gt; 【EmployeeController.java】 12345678910111213141516@AutowiredEmployeeDao employeeDao;/** * 查询所有的员工列列表页面 * @return */@GetMapping(value = &quot;/emps&quot;)public String list(Map&lt;String, Object&gt; map)&#123; Collection&lt;Employee&gt; employees = employeeDao.getAll(); //放在请求域中 map.put(&quot;emps&quot;, employees); // thymeleaf 默认就会拼串 // classpath:/templates/xxxx.html return &quot;emp/list&quot;;&#125; 使用 thymeleaf 模板列出所有的员工信息【list.html】 1234567891011121314151617181920212223242526// 修改这个两处地方&lt;thead&gt; &lt;tr&gt; &lt;th&gt;id&lt;/th&gt; &lt;th&gt;lastName&lt;/th&gt; &lt;th&gt;email&lt;/th&gt; &lt;th&gt;gender&lt;/th&gt; &lt;th&gt;department&lt;/th&gt; &lt;th&gt;birth&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt; &lt;tr th:each=&quot;emp:$&#123;emps&#125;&quot;&gt; &lt;td th:text=&quot;$&#123;emp.id&#125;&quot;&gt;&lt;/td&gt; &lt;td th:text=&quot;$&#123;emp.lastName&#125;&quot;&gt;&lt;/td&gt; &lt;td th:text=&quot;$&#123;emp.email&#125;&quot;&gt;&lt;/td&gt; &lt;td th:text=&quot;$&#123;emp.gender&#125;&quot;&gt;&lt;/td&gt; &lt;td th:text=&quot;$&#123;emp.department.departmentName&#125;&quot;&gt;&lt;/td&gt; &lt;td th:text=&quot;$&#123;#dates.format(emp.birth, &#x27;yyyy-MM-dd HH:mm&#x27;)&#125;&quot;&gt;&lt;/td&gt; &lt;td&gt; &lt;a class=&quot;btn btn-sm btn-primary&quot; href=&quot;#&quot;&gt;编辑&lt;/a&gt; &lt;button class=&quot;btn btn-danger&quot;&gt;删除&lt;/button&gt; &lt;/td&gt; &lt;/tr&gt;&lt;/tbody&gt; ⑥ CRUD-员工添加将【list.html】替换为： 123456替换前：&lt;h2&gt;Section title&lt;/h2&gt;替换后：&lt;h2&gt; &lt;a class=&quot;btn btn-sm btn-success&quot; href=&quot;#&quot; th:href=&quot;@&#123;/emp&#125;&quot;&gt;员工添加&lt;/a&gt;&lt;/h2&gt; 【EmployeeController.java】 12345678910 @Autowired DepartmentDao departmentDao;@GetMapping(&quot;/emp&quot;)public String toAddPage(Map&lt;String, Object&gt; map)&#123; // 来到添加页面，查出所有的部门 Collection&lt;Department&gt; departments = departmentDao.getDepartments(); map.put(&quot;depts&quot;,departments); return &quot;emp/add&quot;;&#125; 在 templates/emp 新建页面【add.html】： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071// 复制list.html 进行细微的修改,删除原&lt;main&gt; 标签中的元素替换为以下的内容 &lt;main role=&quot;main&quot; class=&quot;col-md-9 ml-sm-auto col-lg-10 pt-3 px-4&quot;&gt; &lt;form th:action=&quot;@&#123;/emp&#125;&quot; method=&quot;post&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label&gt;LastName&lt;/label&gt; &lt;input name=&quot;lastName&quot; type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;zhangsan&quot; /&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label&gt;Email&lt;/label&gt; &lt;input name=&quot;email&quot; type=&quot;email&quot; class=&quot;form-control&quot; placeholder=&quot;zhangsan@atguigu.com&quot; /&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label&gt;Gender&lt;/label&gt;&lt;br /&gt; &lt;div class=&quot;form-check form-check-inline&quot;&gt; &lt;input class=&quot;form-check-input&quot; type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;1&quot; /&gt; &lt;label class=&quot;form-check-label&quot;&gt;男&lt;/label&gt; &lt;/div&gt; &lt;div class=&quot;form-check form-check-inline&quot;&gt; &lt;input class=&quot;form-check-input&quot; type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;0&quot; /&gt; &lt;label class=&quot;form-check-label&quot;&gt;女&lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label&gt;department&lt;/label&gt; &lt;!--提交的是部门的id--&gt; &lt;select class=&quot;form-control&quot; name=&quot;department.id&quot;&gt; &lt;option th:value=&quot;$&#123;dept.id&#125;&quot; th:each=&quot;dept:$&#123;depts&#125;&quot; th:text=&quot;$&#123;dept.departmentName&#125;&quot; &gt; 1 &lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label&gt;Birth&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;birth&quot; class=&quot;form-control&quot; placeholder=&quot;zhangsan&quot; /&gt; &lt;/div&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-primary&quot;&gt;添加&lt;/button&gt; &lt;/form&gt; &lt;/main&gt;&lt;/main&gt; 【application.properties】 12# 格式化时间spring.mvc.format.date=yyyy-MM-dd 日期的格式化： SpringMVC 将页面的提交的值需要转换为指定的类型； 例如：2017-12-12—-Date； 类型转换，格式化； 默认日期的按照/的方式 【EmployeeController.java】 123456789101112/** * 获取添加页面的信息 */@PostMapping(value = &quot;/emp&quot;)public String addEmp(Employee employee)&#123; System.out.println(&quot;保存到员工信息:&quot; + employee); // 保存员工信息 employeeDao.save(employee); // redirect: 重定向一个到地址 / 代表当前项目的路径 // forward: 表示转发一个地址 return &quot;redirect:/emps&quot;;&#125; 修改【list.html】中的 gender 1&lt;td th:text=&quot;$&#123;emp.gender&#125;==0?&#x27;女&#x27;:&#x27;男&#x27;&quot;&gt;&lt;/td&gt; 效果： ⑦ 员工修改先通过 id 查询修改员工的信息【EmployeeController.java】 12345678910111213/** * 来到修改页面，查询员工信息，回显 */@GetMapping(value = &quot;/emp/&#123;id&#125;&quot;)public String toEditPage(@PathVariable(&quot;id&quot;) Integer id, Map&lt;String, Object&gt; map)&#123; Employee employee = employeeDao.get(id); map.put(&quot;emp&quot;,employee); // 页面要显示所有部门的信息 Collection&lt;Department&gt; departments = departmentDao.getDepartments(); map.put(&quot;depts&quot;,departments); return &quot;emp/add&quot;;&#125; 修改添加二合一表单【list.html】 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103&lt;!--引入抽取的topbar--&gt;&lt;!--模板名: 会使用thymeleaf的前后缀的配置规则进行解析--&gt;&lt;div th:replace=&quot;commons/bar::topbar&quot;&gt;&lt;/div&gt;&lt;div class=&quot;container-fluid&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;!--引入sidebar--&gt; &lt;div th:replace=&quot;commons/bar::#sidebar(activeUri=&#x27;emps&#x27;)&quot;&gt;&lt;/div&gt; &lt;main role=&quot;main&quot; class=&quot;col-md-9 ml-sm-auto col-lg-10 pt-3 px-4&quot;&gt; &lt;!--需要区分是员工修改还是添加；--&gt; &lt;form th:action=&quot;@&#123;/emp&#125;&quot; method=&quot;post&quot;&gt; &lt;!--发送put请求修改员工数据--&gt; &lt;!-- 1.SpringMVC中配置HiddenHttpMethodFiler;(SpringBoot自动配置好的) 2.页面创建一个post表单 3.创建input项,name=&quot;_method&quot;;值就是我们指定的请求方式 --&gt; &lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;put&quot; th:if=&quot;$&#123;emp!=null&#125;&quot; /&gt; &lt;input type=&quot;hidden&quot; name=&quot;id&quot; th:value=&quot;$&#123;emp.id&#125;&quot; th:if=&quot;$&#123;emp != null&#125;&quot; /&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label&gt;LastName&lt;/label&gt; &lt;input name=&quot;lastName&quot; type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;zhangsan&quot; th:value=&quot;$&#123;emp!= null&#125;?$&#123;emp.lastName&#125;&quot; /&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label&gt;Email&lt;/label&gt; &lt;input name=&quot;email&quot; type=&quot;email&quot; class=&quot;form-control&quot; placeholder=&quot;zhangsan@atguigu.com&quot; th:value=&quot;$&#123;emp!=null&#125;?$&#123;emp.email&#125;&quot; /&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label&gt;Gender&lt;/label&gt;&lt;br /&gt; &lt;div class=&quot;form-check form-check-inline&quot;&gt; &lt;input class=&quot;form-check-input&quot; type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;1&quot; th:checked=&quot;$&#123;emp!=null&#125;?$&#123;emp.gender==1&#125;&quot; /&gt; &lt;label class=&quot;form-check-label&quot;&gt;男&lt;/label&gt; &lt;/div&gt; &lt;div class=&quot;form-check form-check-inline&quot;&gt; &lt;input class=&quot;form-check-input&quot; type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;0&quot; th:checked=&quot;$&#123;emp!= null&#125;?$&#123;emp.gender==0&#125;&quot; /&gt; &lt;label class=&quot;form-check-label&quot;&gt;女&lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label&gt;department&lt;/label&gt; &lt;!--提交的是部门的id--&gt; &lt;select class=&quot;form-control&quot; name=&quot;department.id&quot;&gt; &lt;option th:selected=&quot;$&#123;emp!=null&#125;?$&#123;dept.id==emp.department.id&#125;&quot; th:value=&quot;$&#123;dept.id&#125;&quot; th:each=&quot;dept:$&#123;depts&#125;&quot; th:text=&quot;$&#123;dept.departmentName&#125;&quot; &gt; 1 &lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label&gt;Birth&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;birth&quot; class=&quot;form-control&quot; placeholder=&quot;zhangsan&quot; th:value=&quot;$&#123;emp!= null&#125;?$&#123;#dates.format(emp.birth, &#x27;yyyy-MM-dd HH:mm&#x27;)&#125;&quot; /&gt; &lt;/div&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-primary&quot; th:text=&quot;$&#123;emp!=null&#125;?&#x27;修改&#x27;:&#x27;添加&#x27;&quot; &gt; 添加 &lt;/button&gt; &lt;/form&gt; &lt;/main&gt; &lt;/div&gt;&lt;/div&gt; 获取修改的数据，后台进行处理【EmployeeController.class】 1234567891011/** * 修改员工的信息，需要提交员工的id * @param employee * @return */@PutMapping(value = &quot;/emp&quot;)public String updateEmployees(Employee employee)&#123; System.out.println(&quot;员工修改信息为:&quot;+employee); employeeDao.save(employee); return &quot;redirect:/emps&quot;;&#125; ⑧ 员工删除【EmployeeController.java】 1234567891011/** * 员工删除 * @param id * @return */@DeleteMapping(&quot;/emp/&#123;id&#125;&quot;)public String deleteEmployee(@PathVariable(&quot;id&quot;) Integer id)&#123; System.out.println(&quot;需要删除员工的Id为:&quot;+ id); employeeDao.delete(id); return &quot;redirect:/emps&quot;;&#125; 【list.html】 修改 button 添加属性 123456&lt;button th:attr=&quot;del_uri=@&#123;/emp/&#125;+$&#123;emp.id&#125;&quot; class=&quot;btn btn-sm btn-danger deleteBtn&quot;&gt; 删除&lt;/button&gt; 添加 form 表单 123&lt;form id=&quot;deleteEmpForm&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;delete&quot; /&gt;&lt;/form&gt; 用 jquery 来处理用户删除 1234567891011121314151617181920212223// 添加th:src 防止js、bootstrat等无法获取资源&lt;script type=&quot;text/javascript&quot; src=&quot;asserts/js/jquery-3.2.1.slim.min.js&quot; th:src=&quot;@&#123;/webjars/jquery/3.2.1/dist/jquery.js&#125;&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;asserts/js/popper.min.js&quot; th:src=&quot;@&#123;/webjars/popper.js/1.11.1/dist/popper.js&#125;&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;asserts/js/bootstrap.min.js&quot; th:src=&quot;@&#123;/webjars/bootstrap/4.0.0/js/bootstrap.js&#125;&quot;&gt;&lt;/script&gt;&lt;!-- Icons --&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;asserts/js/feather.min.js&quot; th:src=&quot;@&#123;/asserts/js/feather.min.js&#125;&quot;&gt;&lt;/script&gt; 12345678910111213&lt;script&gt; $(&quot;.deleteBtn&quot;).click(function () &#123; var $tr = $(this).parent().parent(); var name = $tr.children(&quot;:first&quot;).html(); // 删除员工,并进行友好提示 if (confirm(&quot;确定要用户ID为【&quot; + name + &quot;】删除吗？&quot;)) &#123; $(&quot;#deleteEmpForm&quot;).attr(&quot;action&quot;, $(this).attr(&quot;del_uri&quot;)).submit(); // 取消元素的默认行为 return false; &#125; return false; &#125;);&lt;/script&gt; 异常处理（delete 请求被拦截） There was an unexpected error (type=Method Not Allowed, status=405) 解决方法：在 SpringBoot 配置文件中【application.properties】中配置 12# 取消delete请求拦截spring.mvc.hiddenmethod.filter.enabled=true 7、错误处理机制① SpringBoot 默认的错误处理机制默认效果： 浏览器，返回一个默认的错误页面 浏览器发送的请求的请求头： 如果是其他客户端，默认响应一个 josn 数据 原理：可以参照 ErrorMvcAutoConfiguration； 错误处理的自动配置； 给容器中添加一下组件 . DefaultErrorAttributes; 1234567891011帮助我们在页面共享信息; @Override public Map&lt;String, Object&gt; getErrorAttributes(RequestAttributes requestAttributes,boolean includeStackTrace)&#123; Map&lt;String, Object&gt; errorAttributes = new LinkedHashMap&lt;String, Object&gt;(); errorAttributes.put(&quot;timestamp&quot;, new Date()); addStatus(errorAttributes, requestAttributes); addErrorDetails(errorAttributes, requestAttributes,includeStackTrace); addPath(errorAttributes, requestAttributes); return errorAttributes;&#125; .BasicErrorController: 处理默认的/error 请求 12345678910111213141516171819202122@Controller@RequestMapping(&quot;$&#123;server.error.path:$&#123;error.path:/error&#125;&#125;&quot;)public class BasicErrorController extends AbstractErrorController &#123; @RequestMapping(produces = &quot;text/html&quot;)// 产生html类型的数据；浏览器发送的请求来到这个方法处理 public ModelAndView errorHtml(HttpServletRequest request,HttpServletResponse response) &#123; HttpStatus status = getStatus(request); Map&lt;String, Object&gt; model = Collections.unmodifiableMap(getErrorAttributes( request, isIncludeStackTrace(request, MediaType.TEXT_HTML))); response.setStatus(status.value()); //去哪个页面作为错误页面；包含页面地址和页面内容 ModelAndView modelAndView = resolveErrorView(request, response, status, model); return (modelAndView == null ? new ModelAndView(&quot;error&quot;, model) : modelAndView); &#125; @RequestMapping @ResponseBody // 产生json数据，其他客户端来这个方法处理 public ResponseEntity&lt;Map&lt;String, Object&gt;&gt; error(HttpServletRequest request) &#123; Map&lt;String, Object&gt; body = getErrorAttributes(request, isIncludeStackTrace(request, MediaType.ALL)); HttpStatus status = getStatus(request); return new ResponseEntity&lt;Map&lt;String, Object&gt;&gt;(body, status); &#125; 3）.ErrorPageCustomizer： 12@Value(&quot;$&#123;error.path:/error&#125;&quot;)private String path = &quot;/error&quot;; 系统出现错误以后来到error请求进行处理；(web.xml注册的错误页面规则) 4）. DefaultErroViewResolver： 1234567891011121314151617181920@Overridepublic ModelAndView resolveErrorView(HttpServletRequest request, HttpStatus status,Map&lt;String, Object&gt; model) &#123;ModelAndView modelAndView = resolve(String.valueOf(status), model); if (modelAndView == null &amp;&amp;SERIES_VIEWS.containsKey(status.series())) &#123; modelAndView = resolve(SERIES_VIEWS.get(status.series()), model); &#125; return modelAndView;&#125;private ModelAndView resolve(String viewName, Map&lt;String, Object&gt; model) &#123; //默认的SpringBoot可以去找到一个页面 error/404 String errorViewName = &quot;error/&quot; + viewName; //模板引擎可以解析这个页面地址就用模板引擎解析 TemplateAvailabilityProvider provider =this.templateAvailabilityProviders.getProvider(errorViewName, this.applicationContext); if (provider != null) &#123; //模模板引擎可用的情况下返回errorViewName指定的试图地址 return new ModelAndView(errorViewName, model); &#125; //模板引擎不可用，就在静态资源文件只夹下找errorView对应的页面 error/404.html return resolveResource(errorViewName, model);&#125; 步骤：一旦系统出现 4xx 或者 5xx 之类的错误；ErrorPageCustmizer 就会生效（定制错误的响应规则）；就会来到/error 请求；就会BasicErrorController处理； 响应页面；去哪个页面的 DefaultErrorViewResolver 解析得到的； 1234567891011protected ModelAndView resolveErrorView(HttpServletRequest request,HttpServletResponse response, HttpStatus status, Map&lt;String, Object&gt; model) &#123;//所有的ErrorViewResolver得到ModelAndViewfor (ErrorViewResolver resolver : this.errorViewResolvers) &#123; ModelAndView modelAndView = resolver.resolveErrorView(request,status, model); if (modelAndView != null) &#123; return modelAndView; &#125; &#125; return null;&#125; ② 如果定制错误响应:1). 如何定制错误的页面 ​ 1. 有模板引擎的情况下：error/状态码;【将错误页面命名为 错误状态码.html 放在模板引擎文件夹里面的 error 文件下】，发生此状态码的错误就会来到对应的页面； ​ 我们可以使用 4xx 和 5xx 作为错误的文件名来匹配这种类型的所有的错误，精确优先（优先寻找精确的状态码.html）; 页面能获取的信息： timestamp： 时间戳 staus: 状态码 error： 错误提示 exception: 异常对象 mesage: 异常消息 errors: JSR303 数据校验的错误都在这里 123456&lt;main role=&quot;main&quot; class=&quot;col-md-9 ml-sm-auto col-lg-10 pt-3 px-4&quot;&gt; &lt;h1&gt;404&lt;/h1&gt; &lt;h2&gt;timestamp:[[$&#123;timestamp&#125;]]&lt;/h2&gt; &lt;h2&gt;status:[[$&#123;status&#125;]]&lt;/h2&gt; &lt;h2&gt;error:[[$&#123;error&#125;]]&lt;/h2&gt;&lt;/main&gt; 没有模板引擎（模板引擎找不到这个错误的页面），静态资源文件夹下找； 以上都都没有错误页面，就是默认来到 SpringBoot 默认的错误提示页面； 2).如何定制错误的 json 数据； 自定义异常处理&amp;返回定制的 json 数据； 123456789@ResponseBody@ExceptionHandler(UserNotExistException.class)public Map&lt;String, Object&gt; handleException(Exception e)&#123; Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;code&quot;,&quot;user.notexist&quot;); map.put(&quot;message&quot;,e.getMessage()); return map;&#125;// 没有自适应效果 转到到/error 进行自适应想响应的效果处理 123456789public String handException(Exception e, HttpServletRequest request)&#123; Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); // 传入我们自己的错误状态码 4xx 5xx，否则就不会进入定制错误页面的解析流程 request.setAttribute(&quot;javax.servlet.error.status_code&quot;,500); map.put(&quot;code&quot;,&quot;user.notexist&quot;); map.put(&quot;message&quot;,e.getMessage()); // 转发到/error return &quot;forward:/error&quot;;&#125; 3）.将我们的定制数据携带出去； ​ 出现错误以后，会来到/error 请求，会被 BasicErrorController 处理，响应出去可以获取的数据是由 getErrorAttributes 得到的（是 AbstractErrorController(ErrorController)规定的方法）； 完全来编写一个 ErrorController 的实现类【或者编写 AbstractErrorController 的子类】，放在容器中； 页面上能用的数据，或者是 Json 返回的能用的数据都是通过 errAttributes.getErrorAttributes 得到，容器中 DefaultErrorAttrutes.getErrorAttributes()；默认进行数据处理的； 自定义 ErrorAttributes 12345678910111213// 给容器中加入我们自己的定义的ErrorAttributes@Componentpublic class MyErrorAttributes extends DefaultErrorAttributes &#123; //返回值的map就是页面和json能获取的所有字段 @Override public Map&lt;String, Object&gt; getErrorAttributes(WebRequest webRequest, boolean includeStackTrace) &#123; Map&lt;String, Object&gt; map = super.getErrorAttributes(webRequest, includeStackTrace); map.put(&quot;company&quot;,&quot;oy&quot;); return map; &#125;&#125; 最终效果：响应是自适应的，可以通过定制 ErrorAttributes 改变需要返回的内容， 8、配置嵌入式 Servle 容器SpringBoot 默认使用 Tomcat 作为嵌入式的 Servlet 容器； ① 定制和修改 Servlet 容器的相关配置； 修改和 Servlet 有关的配置（ServletProperties【也是 EmbeddedServletContainerCustomizer】）; 123456789server.port=8081server.context-path=/curdserver.tomcat.uri-encoding=UTF-8// 通用的Servlet容器设置server.xxx// Tomcat的设置server.tomcat 编写一个 EmbeddedServerContainerCustomizer(2.x 以上已经不支持)，使用ConfigurableServletWebServerFactory：嵌入式的 Servlet 容器的定制器；来修改 Servlet 容器的配置 123456789@Configurationpublic class MySeverConfig &#123; @Bean // 一定要将这个定制器加入到容器中 public ConfigurableServletWebServerFactory webServerFactory()&#123; TomcatServletWebServerFactory factory = new TomcatServletWebServerFactory(); factory.setPort(8083); return factory; &#125;&#125; ② 注册 Servlet 三大组件【Servlet、Filter、Listener】​ 由于 SpringBoot 默认是以 jar 包的的方式启动嵌入式的 Servlet 容器来启动 SpringBoot 的 web 应用，没有 web.xml 文件 注册三大组件用以下的方式 ServletRegistrationBean 123456@Beanpublic ServletRegistrationBean myServlet()&#123; ServletRegistrationBean registrationBean = new ServletRegistrationBean(new MyServlet(),&quot;/myServlet&quot;); registrationBean.setLoadOnStartup(1); return registrationBean;&#125; FilterRegistrationBean 1234567@Beanpublic FilterRegistrationBean myListener()&#123; FilterRegistrationBean registrationBean = new FilterRegistrationBean(); registrationBean.setFilter(new MyFilter()); registrationBean.setUrlPatterns(Arrays.asList(&quot;/hello&quot;,&quot;/myServlet&quot;)); return registrationBean;&#125; ServletListenerRegistrationBean 12345@Beanpublic ServletListenerRegistrationBean mylistener()&#123; ServletListenerRegistrationBean registrationBean = new ServletListenerRegistrationBean(new MyListener()); return registrationBean;&#125; SpringBoot 帮我们自动 SpringMVC 的时候，自动注册 SpringMVC 的前端控制器；DispartcherServlet; DispatcherServletAutoConfiguration 中： 1234567891011121314@Bean(name = DEFAULT_DISPATCHER_SERVLET_REGISTRATION_BEAN_NAME)@ConditionalOnBean(value = DispatcherServlet.class, name =DEFAULT_DISPATCHER_SERVLET_BEAN_NAME)public ServletRegistrationBean dispatcherServletRegistration(DispatcherServlet dispatcherServlet) &#123; ServletRegistrationBean registration = new ServletRegistrationBean(dispatcherServlet, this.serverProperties.getServletMapping()); //默认拦截： / 所有请求；包静态资源，但是不拦截jsp请求； /*会拦截jsp //可以通过server.servletPath来修改SpringMVC前端控制器默认拦截的请求路径 registration.setName(DEFAULT_DISPATCHER_SERVLET_BEAN_NAME); registration.setLoadOnStartup(this.webMvcProperties.getServlet().getLoadOnStartup()); if (this.multipartConfig != null) &#123; registration.setMultipartConfig(this.multipartConfig); &#125; return registration;&#125; ③ 替换为其他嵌入式 Servlet 容器 默认支持： ==Tomcat==（默认使用） 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; 引入web模块就是使用嵌入式的Tomcat作为Server容器&lt;/dependency&gt; ==Jetty== 1234567891011121314151617&lt;!--引入web模块--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;!--引入其他的Servlet容器--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt;&lt;/dependency&gt; ==Undertow== 1234567891011121314151617&lt;!--引入web模块--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;!--引入其他的Servlet容器--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-undertow&lt;/artifactId&gt;&lt;/dependency&gt; ④ 嵌入式 Servlet 容器自动配置原理(1.x 版本)12345678910111213141516171819202122232425262728293031323334353637383940414243444546@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE)@Configuration@ConditionalOnWebApplication@Import(BeanPostProcessorsRegistrar.class)// 导入BeanPostProcessorsRegister : 给容器中导入一些主件// 导入了EmbeddedServletContainnerCustomizerBeanPostcessor:// 后置处理器：Bean初始化后（创建完对象，还没赋值)执行初始化工作@Configuration@ConditionalOnClass(&#123; Servlet.class, Tomcat.class &#125;)//判断当前是否引入了Tomcat依赖@ConditionalOnMissingBean(value = EmbeddedServletContainerFactory.class, search =SearchStrategy.CURRENT)// 判断当前容器没有用户自定定义EmbedddServerContainerFactory: 嵌入式的Server容器工厂； 作用： 创建嵌入式的Server容器public class EmbeddedServletContainerAutoConfiguration &#123; public static class EmbeddedTomcat &#123; @Bean public TomcatEmbeddedServletContainerFactory tomcatEmbeddedServletContainerFactory() &#123; return new TomcatEmbeddedServletContainerFactory(); &#125; &#125; /** * Nested configuration if Jetty is being used. */ @Configuration @ConditionalOnClass(&#123; Servlet.class, Server.class, Loader.class,WebAppContext.class &#125;) @ConditionalOnMissingBean(value = EmbeddedServletContainerFactory.class,searchSearchStrategy.CURRENT) public static class EmbeddedJetty &#123; @Bean public JettyEmbeddedServletContainerFactory jettyEmbeddedServletContainerFactory() &#123; return new JettyEmbeddedServletContainerFactory(); &#125; &#125;&#125; 、/*** Nested configuration if Undertow is being used.*/@Configuration@ConditionalOnClass(&#123; Servlet.class, Undertow.class, SslClientAuthMode.class &#125;)@ConditionalOnMissingBean(value = EmbeddedServletContainerFactory.class, search =SearchStrategy.CURRENT)public static class EmbeddedUndertow &#123; @Bean public UndertowEmbeddedServletContainerFactory undertowEmbeddedServletContainerFactory() &#123; return new UndertowEmbeddedServletContainerFactory(); &#125;&#125; EmbeddedServletContainerFactory（嵌入式 Servlet 容器工厂） 12345public interface EmbeddedServletContainerFactory &#123; //获取嵌入式的Servlet容器 EmbeddedServletContainer getEmbeddedServletContainer( ServletContextInitializer... initializers);&#125; EmbeddedServerContainer:(嵌入式的 Servlet 容器) 以 TomcatEmbeddedServletContainerFactory 为例 123456789101112131415161718192021@Overridepublic EmbeddedServletContainer getEmbeddedServletContainer(ServletContextInitializer... initializers) &#123; //创建一个Tomcat Tomcat tomcat = new Tomcat(); //配置Tomcat的基本环节 File baseDir = (this.baseDirectory != null ? this.baseDirectory: createTempDir(&quot;tomcat&quot;)); tomcat.setBaseDir(baseDir.getAbsolutePath()); Connector connector = new Connector(this.protocol); tomcat.getService().addConnector(connector); customizeConnector(connector); tomcat.setConnector(connector); tomcat.getHost().setAutoDeploy(false); configureEngine(tomcat.getEngine()); for (Connector additionalConnector : this.additionalTomcatConnectors) &#123; tomcat.getService().addConnector(additionalConnector); &#125; prepareContext(tomcat.getHost(), initializers); // 将配置好的Tomcat传入进入，返回一个EmbeddedServerContainer;并启动Tomcat服务器 return getTomcatEmbeddedServletContainer(tomcat);&#125; 我们对嵌入式容器的配置修改是怎么生效的 ServerProperties、EmbeddedServleContainerCustomizer 5.容器中导入了 EmbeddedServletContainerCustomizerBeanPostProcessor 123456789101112131415161718192021222324252627282930313233343536373839//初始化之前@Overridepublic Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123; //如果当前初始化的是一个ConfigurableEmbeddedServletContainer类型的组件 if (bean instanceof ConfigurableEmbeddedServletContainer) &#123; // postProcessBeforeInitialization((ConfigurableEmbeddedServletContainer) bean); &#125; return bean;&#125;private void postProcessBeforeInitialization(ConfigurableEmbeddedServletContainer bean) &#123;//获取所有的定制器，调用每一个定制器的customize方法来给Servlet容器进行属性赋值； for (EmbeddedServletContainerCustomizer customizer : getCustomizers()) &#123; customizer.customize(bean); &#125;&#125;private void postProcessBeforeInitialization(ConfigurableEmbeddedServletContainer bean) &#123; //获取所有的定制器，调用每一个定制器的customize方法来给Servlet容器进行属性赋值； for (EmbeddedServletContainerCustomizer customizer : getCustomizers()) &#123; customizer.customize(bean); &#125;&#125; private Collection&lt;EmbeddedServletContainerCustomizer&gt; getCustomizers() &#123; if (this.customizers == null) &#123; // Look up does not include the parent context this.customizers = new ArrayList&lt;EmbeddedServletContainerCustomizer&gt;( this.beanFactory //从容器中获取所有这葛类型的组件：EmbeddedServletContainerCustomizer //定制Servlet容器，给容器中可以添加一个EmbeddedServletContainerCustomizer类型的组件 .getBeansOfType(EmbeddedServletContainerCustomizer.class,false, false).values()); Collections.sort(this.customizers, AnnotationAwareOrderComparator.INSTANCE); this.customizers = Collections.unmodifiableList(this.customizers); &#125; return this.customizers;&#125;ServerProperties 也是定制器 步骤： SpringBoot 根据导入的依赖情况，给容器中添加相应的 EmbeddedServletContainerFactory【TomcatEmbeddedServletContainerFactroy】 容器中某个组件要创建对象就会惊动后置处理器； EmbeddedServletContainCustomizerBeanPostProcessor; 只要是嵌入式的 Servlet 容器工厂，后置处理器就工作； 后置处理器，从容中获取所有的 EmbeddedServletContainerCustomizer，调用定制器的定制方法 9、 嵌入式 Servlet 容器启动原理获取嵌入式的 Servlet 容器工厂： 1. SpringBoot应用启动运行run方法 refreshContext(context);SpringBoot 刷新 IOC 容器【创建 IOC 容器，并初始化容器，创建容器中的每一个组件】；如果是 web 应用创建AnnotainConfigEmbedderWebApplicationContext;否则；AnnotaionConfigApplicationContext refresh(context); 刷新刚才创建的 ioc 容器； 123456789101112131415161718192021222324252627282930313233343536373839404142434445public void refresh() throws BeansException, IllegalStateException &#123;synchronized (this.startupShutdownMonitor) &#123; // Prepare this context for refreshing. prepareRefresh(); // Tell the subclass to refresh the internal bean factory. ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); // Prepare the bean factory for use in this context. prepareBeanFactory(beanFactory); try &#123; // Allows post‐processing of the bean factory in context subclasses. postProcessBeanFactory(beanFactory); // Invoke factory processors registered as beans in the context. invokeBeanFactoryPostProcessors(beanFactory); // Register bean processors that intercept bean creation. registerBeanPostProcessors(beanFactory); // Initialize message source for this context. initMessageSource(); // Initialize event multicaster for this context. initApplicationEventMulticaster(); // Initialize other special beans in specific context subclasses. onRefresh(); // Check for listener beans and register them. registerListeners(); // Instantiate all remaining (non‐lazy‐init) singletons. finishBeanFactoryInitialization(beanFactory); // Last step: publish corresponding event. finishRefresh(); &#125; catch (BeansException ex) &#123; if (logger.isWarnEnabled()) &#123; logger.warn(&quot;Exception encountered during context initialization ‐ &quot; +&quot;cancelling refresh attempt: &quot; + ex); &#125; // Destroy already created singletons to avoid dangling resources. destroyBeans(); // Reset &#x27;active&#x27; flag. cancelRefresh(ex); // Propagate exception to caller. throw ex; &#125; finally &#123; // Reset common introspection caches in Spring&#x27;s core, since we // might not ever need metadata for singleton beans anymore... resetCommonCaches(); &#125; &#125;&#125; onRefrsh(); web 的 ioc 容器重写 onRefresh 方法 webioc 容器会创建嵌入式的 Servlet 容器； createEmbeddedServletContainer(); 获取嵌入式的 Servlet 容器工厂 EmbeddedServletContionerFactory containerFactory = getEmbeddedServletContianFactory(); 从容器中获取 EmbeddedServletContian 组件；TomcatEmbeddedServletContainerFactory 创建对象，后置处理器一看是这个对象，就能获取所有定制器来定制 Servlet 容器的相关配置； 使用容器工厂获取嵌入式的 Server 容器: ​ this.embeddedServletContainer = containerFactory.getEmbeddedServletContainer(getSelfInitializer()); 嵌入式的 Servlet 容器创建对象并启动 Server 容器； 先启动嵌入式 Servlet 容器，再将 ioc 容器下没有创建出的对象获取出来； IOC 容器启动创建嵌入式的 Servlet 容器 10、使用外置的 Servlet 容器嵌入式 Servle 容器: 应用打成可执行的 jar 优点：简单、便携 缺点：默认不支持 JSP、优先定制比较复杂（使用定制器【ServerProperties、自定义 EmbeddesdServletContianCustizer】, 自己编写嵌入式 Servlet 容器的创建工厂【EmbeddedServletContainerFactory 】） 外置 Servlet 容器：外面安装 Tomcat – 应用 war 包的方式打开； 步骤： 必须创建一个 web 项目； 参考博客：https://blog.csdn.net/qq_45738810/article/details/108509314 建入嵌入式的 Tomcat 指定的 provided; 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 必须编写一个 SpringBootServletInitiallzer 的子类，并调用 configure 方法 12345678public class ServletInitializer extends SpringBootServletInitializer &#123; @Override protected SpringApplicationBuilder configure(SpringApplicationBuilder application) &#123; return application.sources(SpringBoot06WebServletApplication.class); &#125;&#125; 启动服务器就可以使用； ==原理：== jar 包： 执行 SpringBoot 主类的 main 方法，启动 ioc 容器，创建嵌入式的 Servlet 容器； war 包： 启动服务器，服务器启动 SpringBoot 应用【SpringBootServletInitializer】,启动 ioc 容器； 规则： 服务器启动(web 应用启动)会创建当前 web 应用里面每一个 jar 包里面 ServerContainnerInitializer 实例： ServletContainerInitializer 的实现放在 jar 包的 META-INF/servies 文件下，有一个名为 java 还可以使用@HandlesTypes,在应用启动的时候加载配置的类 流程： 启动 Tomcat D:\\RepMaven\\org\\springframework\\spring-web\\5.2.8.RELEASE\\spring-web-5.2.8.RELEASE.jar!\\META-INF\\services\\javax.servlet.ServletContainerInitializer: Spring 的 web 模块里面的这个文件：org.springframework.web.SpringServletContainerInitializer SpringServletContainerInitializer 将@HandlesTypes(WebApplicationInitializer.class )标注的所有这个类型的类都传入 onStratup 方法的 Setup 方法的&lt;Set&gt;; 为这些 WebApplicationInitializer 类型的类创建实例： 每一个 WebApplicaionInitialzer 都调用自己的 onStarup； 相当于我们的 SpringBootServletInitalizer 的创建对象，并执行 onStarup 方法 SpringBootServletInitializer 实例执行 onStartup 的时候会 createRootApplicationContext；创建容器 1234567891011121314151617181920212223242526272829303132protected WebApplicationContext createRootApplicationContext(ServletContext servletContext) &#123; //1、创建SpringApplicationBuilder SpringApplicationBuilder builder = createSpringApplicationBuilder(); StandardServletEnvironment environment = new StandardServletEnvironment(); environment.initPropertySources(servletContext, null); builder.environment(environment); builder.main(getClass()); ApplicationContext parent = getExistingRootWebApplicationContext(servletContext); if (parent != null) &#123; this.logger.info(&quot;Root context already created (using as parent).&quot;); servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, null); builder.initializers(new ParentContextApplicationContextInitializer(parent)); &#125; builder.initializers(new ServletContextApplicationContextInitializer(servletContext)); builder.contextClass(AnnotationConfigEmbeddedWebApplicationContext.class); //调用configure方法，子类重写了这个方法，将SpringBoot的主程序类传入了进来 builder = configure(builder); //使用builder创建一个Spring应用 SpringApplication application = builder.build(); if (application.getSources().isEmpty() &amp;&amp; AnnotationUtils.findAnnotation(getClass(), Configuration.class) != null) &#123; application.getSources().add(getClass()); &#125; Assert.state(!application.getSources().isEmpty(),&quot;No SpringApplication sources have been defined. Either override the &quot;+ &quot;configure method or add an @Configuration annotation&quot;);// Ensure error pages are registered if (this.registerErrorPageFilter) &#123; application.getSources().add(ErrorPageFilterConfiguration.class); &#125; //启动Spring应用 return run(application);&#125; Spring 的应用就启动并且创建 IOC 容器 1234567891011121314151617181920212223242526272829public ConfigurableApplicationContext run(String... args) &#123; StopWatch stopWatch = new StopWatch(); stopWatch.start(); ConfigurableApplicationContext context = null; FailureAnalyzers analyzers = null; configureHeadlessProperty(); SpringApplicationRunListeners listeners = getRunListeners(args); listeners.starting(); try &#123; ApplicationArguments applicationArguments = new DefaultApplicationArguments(args); ConfigurableEnvironment environment = prepareEnvironment(listeners,applicationArguments); Banner printedBanner = printBanner(environment); context = createApplicationContext(); analyzers = new FailureAnalyzers(context); prepareContext(context, environment, listeners, applicationArguments,printedBanner); //刷新IOC容器 refreshContext(context); afterRefresh(context, applicationArguments); listeners.finished(context, null); stopWatch.stop(); if (this.logStartupInfo) &#123; new StartupInfoLogger(this.mainApplicationClass).logStarted(getApplicationLog(), stopWatch); &#125; return context; &#125; catch (Throwable ex) &#123; handleRunFailure(context, listeners, analyzers, ex); throw new IllegalStateException(ex); &#125;&#125; ==启动 Servlet 容器，再启动 SpringBoot 应用==","categories":[{"name":"JavaEE框架","slug":"JavaEE框架","permalink":"http://blog.oy6090.top/categories/JavaEE%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"java","slug":"java","permalink":"http://blog.oy6090.top/tags/java/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://blog.oy6090.top/tags/SpringBoot/"}]},{"title":"SpringBoot之基本配置","slug":"SpringBoot之基本配置","date":"2020-08-26T16:00:00.000Z","updated":"2020-10-25T02:26:48.564Z","comments":true,"path":"posts/3862476156.html","link":"","permalink":"http://blog.oy6090.top/posts/3862476156.html","excerpt":"","text":"SpringBoot 之基本配置知识总结（由于网页解析存在问题，无法上传笔记） 一、日志1、日志框架市面上的日志框架：JUL、JCL、Jbooss-loggin、logback、log4j、log4j2、slf4j…. 日志门面（日志的抽象层） 日志实现 JCL(jakarta Commons Loggin) SLF4j(Simple Loggin Facade For Java) jboss loggin Log4j JUL（java.util.logging） Log4j2 Logback 左边选一个门面（抽象层）、右边来选一个实现； 日志门面： SLF4J； 日志实现：Logback SpringBoot: 底层是 Spring 框架，Spring 框架默认是用JCL; ==SpringBoot 选用 SLF4j 和 Logback;== 2、使用 SLF4j 使用① 如何在系统中使用 SLF4j https://www.slf4j.org​ 以后开发时候，日志记录方法调用，不应该来直接调用日志实现类，而是调用日志抽象层里面的方法； ​ 给系统里面导入 slf4j 的 jar 和 logback 的实现 jar 123456789import org.slf4j.Logger;import org.slf4j.LoggerFactory;public class HelloWorld &#123; public static void main(String[] args) &#123; Logger logger = LoggerFactory.getLogger(HelloWorld.class); logger.info(&quot;Hello World&quot;); &#125;&#125; 图示: 每一个日志的实现框架都有自己的配置文件。使用 slf4j 以后，配置文件还是做成日志实现框架自己本身的配置文件； ② 遗留问题a(slf4j + logback): Spring(commons-loggin)、Hibernate(Jboss-logging)、Mybatis….. 统一日志记录，即使是别的框架和我一起使用 slf4j 进行输出： ==让系统中所有的日志都统一到 slf4j：== 将系统中的其他日志框架先排除出去； 用中间包啦替换原有的日志框架 导入 slf4j 其他的实现 3、SpringBoot 日志关系1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring‐boot‐starter&lt;/artifactId&gt;&lt;/dependency&gt; SpringBoot 使用它来做日志功能： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt;&lt;/dependency&gt; 底层依赖关系 总结： 1. SpringBoot底层也是使用slf4j+ logback的方式进行日志记录； SpringBoot 也是其他的日志都替换成 slf4j； 中间替换包 123456@SuppressWarnings(&quot;rawtypes&quot;)public abstract class LogFactory &#123; static String UNSUPPORTED_OPERATION_IN_JCL_OVER_SLF4J = &quot;http://www.slf4j.org/codes.html#unsupported_operation_in_jcl_over_slf4j&quot;; static LogFactory logFactory = new SLF4JLogFactory(); 如果我们引入其他框架，一定要把这个框架的默认日志依赖移除掉 Spring 框架用的是 commons-logging; 12345678910&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring‐core&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;commons‐logging&lt;/groupId&gt; &lt;artifactId&gt;commons‐logging&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt; ==SpringBoot 能自动依赖所有的日志，而且底层使用 slf4j + logback 的方式记录日志，引入其他框架的时候，只需要把这个框架依赖的日志框架排除掉即可;== 4、日志的使用① SpringBoot 默认帮我们配置好了日志1234567891011121314151617// 记录器Logger logger = LoggerFactory.getLogger(getClass());@Testvoid contextLoads() &#123; // 日志级别 // 由低到高 trace&lt;debug&lt;info&lt;warn&lt;error // 可以调整输出日志的级别；日志的只会在这个级别 logger.trace(&quot;这是trace日志.....&quot;); logger.debug(&quot;这是debug日志.....&quot;); // springBoot默认给我们使用的是info基本的，没有用指定级别就用SpringBoot莫人规定的级别是; root级别 logger.info(&quot;这是info日志.......&quot;); logger.warn(&quot;这里warn日志.......&quot;); logger.error(&quot;这里error日志.....&quot;);&#125; 123456789日志输出格式： %d表示日期时间， %thread表示线程名， %‐5level：级别从左显示5个字符宽度 %logger&#123;50&#125; 表示logger名字最长50个字符，否则按照句点分割。 %msg：日志消息， %n是换行符 ‐‐&gt; %d&#123;yyyy‐MM‐dd HH:mm:ss.SSS&#125; [%thread] %‐5level %logger&#123;50&#125; ‐ %msg%n SpringBoot 修改日志的默认配置 123456789101112131415logging.level.com.oy=trace#loggin.path=# 不指定；路径在当前项目下生成spring.log日志# 可以指定完整的路径#loggin.file=E:/springboot.log#在当前磁盘的根路径上创建spring文件夹里面log文件；使用 spring.log作为默文件logging.path=/springboot.log# 在控制台输出的日志的格式logging.pattern.console=%d&#123;yyyy‐MM‐dd&#125; [%thread] %‐5level %logger&#123;50&#125; ‐ %msg%n# 指定文件日志输出的格式logging.pattern.file=%d&#123;yyyy‐MM‐dd&#125; === [%thread] === %‐5level === %logger&#123;50&#125; ==== %msg%n logging.file logging.path Example Description (none) (none) 只在控制台输出 指定文件名 (none) my.log 输出日志到 my.log 文件 (none) 指定目录 /var/log 输出到指定目录的 spring.log 文件中 ② 指定配置​ 给类路径下放上每个日志框架自己的配置文件即可；SpringBoot 就不使用其他默认的配置了。 Logging System Customization Logback logback-spring.xml , logback-spring.groovy , logback.xml or logback.groovy Log4j2 log4j2-spring.xml or log4j2.xml JDK (Java Util Logging) logging.properties ​ lohback.xml： 直接就被日志框架识别了； ​ logback-spring.xml: 日志框架就不直接加载日志的配置项，由 SpringBoot 解析日志配置，可以使用 SpringBoot 的高级 Profile 功能 1234&lt;springProfile name=&quot;staging&quot;&gt; &lt;!‐‐ configuration to be enabled when the &quot;staging&quot; profile is active ‐‐&gt; 可以指定某段配置只在某个环境下生效&lt;/springProfile&gt; 如： 123456789101112131415161718192021&lt;appender name=&quot;stdout&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt; &lt;!‐‐ 日志输出格式： %d表示日期时间， %thread表示线程名， %‐5level：级别从左显示5个字符宽度 %logger&#123;50&#125; 表示logger名字最长50个字符，否则按照句点分割。 %msg：日志消息， %n是换行符 ‐‐&gt; &lt;layout class=&quot;ch.qos.logback.classic.PatternLayout&quot;&gt; &lt;springProfile name=&quot;dev&quot;&gt; &lt;pattern&gt;%d&#123;yyyy‐MM‐dd HH:mm:ss.SSS&#125; ‐‐‐‐&gt; [%thread] ‐‐‐&gt; %‐5level%logger&#123;50&#125; ‐ %msg%n&lt;/pattern&gt; &lt;/springProfile&gt; &lt;springProfile name=&quot;!dev&quot;&gt; &lt;pattern&gt;%d&#123;yyyy‐MM‐dd HH:mm:ss.SSS&#125; ==== [%thread] ==== %‐5level%logger&#123;50&#125; ‐ %msg%n&lt;/pattern&gt; &lt;/springProfile&gt; &lt;/layout&gt;&lt;/appender&gt; ==如果使用 logback.xml 作为日志配置文件，还要使用 profile 功能，会有以下错误== 5、切换日志框架可以按照 slf4j 的日志适配图，进行相关的切换； slf4j+log4j 的方式； 12345678910111213141516171819&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring‐boot‐starter‐web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;logback‐classic&lt;/artifactId&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;artifactId&gt;log4j‐over‐slf4j&lt;/artifactId&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j‐log4j12&lt;/artifactId&gt;&lt;/dependency&gt; 切换为 log4j2 1234567891011121314&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring‐boot‐starter‐web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring‐boot‐starter‐logging&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring‐boot‐starter‐log4j2&lt;/artifactId&gt;&lt;/dependency&gt;","categories":[{"name":"JavaEE框架","slug":"JavaEE框架","permalink":"http://blog.oy6090.top/categories/JavaEE%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"java","slug":"java","permalink":"http://blog.oy6090.top/tags/java/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://blog.oy6090.top/tags/SpringBoot/"}]},{"title":"Redis基础总结","slug":"Redis基础总结","date":"2020-08-17T16:00:00.000Z","updated":"2020-10-25T02:26:59.641Z","comments":true,"path":"posts/865268903.html","link":"","permalink":"http://blog.oy6090.top/posts/865268903.html","excerpt":"","text":"一、Redis 的 五大数据类型1、key 指令 描述 keys * 查看当前库的所有键 exists&lt;key&gt; 判断某个键是否存在 type&lt;key&gt; 查看键的类型 del&lt;key&gt; 删除某个键 expire&lt;key&gt;&lt;seconds&gt; 为键设置过期的时间，单位秒 ttl&lt;key&gt; 查看还有多久过期，-1 表示永不过期，-2 表示已过期 dbsize 查看当前数据库中的 key 的数量 flushdb 清空当前库 Flushall 通杀全部库 2、String String 是 Redis 最基本的类型。 String 类型是二进制安全的。意味着 Redis 的 string 可以包含任何数据。比如 jpg 图片或者序列化的对象。 String 类型是 Redis 最基本的数据类型，一个 Redis 中字符串 value 最多可以是 512M 常用操作 指令 描述 get&lt;key&gt; 查询对应的键值 set &lt;key&gt;&lt;value&gt; 添加键值对 append&lt;key&gt;&lt;value&gt; 将给定的&lt;value&gt; 追加到原值的末尾 strlen&lt;key&gt; 获取值的长度 setnx&lt;key&gt;&lt;value&gt; 只有在 Key 不存在时设置 key 的值 incr&lt;key&gt; 将 key 中存储的数字值增 1， 只能对数字值的操作，如果为空，新增值为 1。 decr&lt;key&gt; 将 key 中存储的数字值减 1，只能对数字值操作，如果为空，新增值为-1 incrby/ decrby &lt;key&gt;&lt;步长&gt; 将 key 中存储的数字值增减。自定义步长。 mset&lt;key1&gt;&lt;value1&gt;&lt;key2&gt;&lt;value2&gt; 同时设置一个或多个 key-value 对 mget&lt;key1&gt;&lt;key2&gt;&lt;key3&gt; 同时获取一个或多个 key-value 对 msetnx&lt;key1&gt;&lt;value1&gt;&lt;key2&gt;&lt;value2&gt; 同时设置一个或多个 key-value 对，当且仅当所有给定的 key 都不存在 getrange&lt;key&gt;&lt;起始位置&gt;&lt;结束位置&gt; 获取值的范围,类似 java 中的 substring setrange&lt;key&gt; &lt;起始位置&gt; &lt;value&gt; 用&lt;vakue&gt;覆盖&lt;key&gt;所存储的字符串值，从&lt;起始位置&gt;开始 setex&lt;key&gt;&lt;过期时间&gt;&lt;value&gt; 设置键值的同时，设置过去的时间，单位秒 getset&lt;key&gt;&lt;value&gt; 以新换旧，设置了新值的同时获取旧值 incr key 操作的原子性 所谓的原子是指不会被线程的调度机制打断的操作：这种操作一旦开始，就一直运行到结束，中间不会有任何的 context switch (切换到另一个线程)。 在单线程中，能够在单条指令中完成的操作都可以认为是”原子操作”,因为中断只能发生在于指令之间。 在多线程中，不能被其他的进程（线程）打断的操作就叫原子操作。 Redis 单命令的原子性主要得益于 Redis 的单线程 3、List 单键多值 Redis ；列表是简单的字符串列表，按照插入顺序排序。可以添加一个元素列表的头部(左边) 或者尾部 (右边)。 它的底层实际是一个双向链表，对两端的操作行选性能很高，通过索引下标的操作中间的节点性能会差 常用操作 指令 描述 lpush/rpush&lt;key&gt;&lt;value1&gt;&lt;value2&gt; 从左边/右边插入一个值或多个值 lpoy/rpop &lt;key&gt; 从左边/右边吐出一个值。值在键在，值光键亡。 rpoplush&lt;key1&gt;&lt;key2&gt; 从&lt;key1&gt;列表边吐出一个值，插到&lt;key2&gt;列表的左边 lrange&lt;key&gt;&lt;start&gt;&lt;stop&gt; 按照索引下标获取元素(从左到右) lindex&lt;key&gt;&lt;index&gt; 按照索引下标获取的元素(从左到右) llen&lt;key&gt; 获得列表长度 linsert&lt;key&gt; before&lt;value&gt; &lt;newvalue&gt; 在&lt;value&gt;的后面的插入&lt;newvalue&gt; 插入值 lrem&lt;key&gt;&lt;n&gt;&lt;vakue&gt; 从左边删除 n 个 value(从左到右) 4、Set Redis set 对外提供的功能与 list 类似是一个列表功能，特殊之处在于 set 是可以自动排重的，当你需要存储一个列表数据，又不希望出现一个重复的数据时，set 是一个很好的选择，并且 set 提供了判断某个成员是否存在一个 set 集合内的重要接口，这个也是 list 所不能提供的。 Rdis 的 set 是 String 类型的无序集合。它底层其实是一个 value 为 null 的 hash 表，所以添加，删除，查找的复杂度都是 O(1)。 常用操作 方法 描述 setadd&lt;key&gt;&lt;value1&gt;&lt;value2&gt;… 将一个或多个 menber 元素加入到集合 key 当中，已经存于集合的 menber 元素将忽略 smembers&lt;key&gt; 取出该集合的所有值。 sismember&lt;key&gt;&lt;value&gt; 判断一个集合&lt;key&gt;是否含有该&lt;value&gt;值，有返回值 1，没有返回 0 scard &lt;key&gt; 返回该集合的元素个数 srem&lt;key&gt;&lt;value1&gt;&lt;value2&gt;… 删除集合中的某个元素 spop&lt;key&gt; 随机从该集合中吐出一个值 srandmenber&lt;key&gt;&lt;n&gt; 随机从该集合中取出 n 个值。不会从集合中删除 sinter&lt;key1&gt;&lt;key2&gt; 返回两个集合的交集元素 sunion&lt;key1&gt;&lt;key2&gt; 返回两个集合的并集元素 sdiff&lt;key1&gt;&lt;key2&gt; 返回两个集合的差集元素 5、Hash Redis hash 是一键值对集合 Redis hash 是一个 string 类型的 field 和 value 的映射表，hash 特点适用用于存储对象。 类似 java 里面的 Map&lt;String，Object&gt; 分析一个问题：现有一个 JavaBean 对象，在 Redis 中如何存？ 第一种方案：用户 ID 为 key,VALUE 为 JavaBean 序列化后的字符串 ​ 缺点：每次修改的用户的某个属性需要，先反序列化改好后在序列化回去。开销较大 第二种方案：用户 ID+属性名作为 key 属性值作为 Value. ​ 缺点：用户 ID 数据冗余 第三种方案：通过 key(用户 ID) + filed(属性标签) 就可以操作对应的属性数据了，既不需要重复存储数据，也不会带来序列化和并发修改控制的问题。 常用操作 方法 描述 hset&lt;key&gt; &lt;field&gt;&lt;value&gt; 给&lt;key&gt;集合中的&lt;field&gt;键赋值&lt;value&gt; hmset&lt;key1&gt;&lt;field&gt; 从&lt;key1&gt;集合&lt;field&gt; 取出 value hmset&lt;key1&gt;&lt;field1&gt;&lt;value1&gt; &lt;field2&gt; &lt;value2&gt;… 批量设置 hash 的值 hexists key &lt;field&gt; 查看哈希表 key 中，给定域 field 是否存在 hkeys&lt;key&gt; 列出该 hash 集合的所有的 field hvals&lt;key&gt; 列出该 hash 集合的所有 value hincrby&lt;key&gt;&lt;field&gt;&lt;increment&gt; 为哈希表 key 中的域 field 的值加上增量 increment hsetnx &lt;key&gt; &lt;field&gt;&lt;value&gt; 将哈希表 key 中的域 field 的值设置为 value ，当且仅当域 field 不存在 6、zset(sorted ser) Redis 有序集合 zset 与 普通的 set 非常相似，是一个没有重复元素的字符串集合。不同之处是有序集合的每个成员都关联一个评分(sroce), 这个评分(score) 被用来按照从最低的分到最高的方式排序集合中的成员。集合中的成员是唯一的，但是评分可以是重复了。 因为元素是有序的，所以你也可以很快的根据评分（score) 或者次序（position）来获取一个范围的元素。访问有序集合的中间元素也是非常快的，因此你能够使用有序集合作为一个没有重复的成员的智能列表。 常用操作 方法 描述 zadd &lt;key&gt; &lt;score1&gt; &lt;value1&gt; &lt;score2&gt; &lt;value2&gt;… 将一个或多个 member 元素及其 score 值加入到有序集合 key 当中 zrange&lt;key&gt; &lt;start&gt;&lt;stop&gt;[WINHSCORES] 返回有序集 key 中，下标在&lt;start&gt;&lt;stop&gt;之间的元素带 WITHSCORES,可以让分数一起和值返回到结果集。 zrangebyscore key min max [withscores] [limit offset count] 返回有序集合 key 中， 所有 score 值介于 min 和 max 之间(包括等于 min 或 max) 的成员。有序集合按 score 值递增（从小到大）次序排列。 zrevrangebyscore key max min [withscores] [limit offset count] 同上，改为从大到小排列。 zincrby &lt;key&gt; &lt;increment&gt; &lt;value&gt; 为元素的 score 加上增量 zrem&lt;key&gt;&lt;value&gt; 删除集合下，指定值的元素 zcount&lt;key&gt;&lt;min&gt;&lt;max&gt; 统计该集合，分数区间内的元素个数 zran&lt;key&gt; &lt;value&gt; 返回该值在集合中排名，从 0 开始。 二、Redis 的相关配置 计量单位说明,大小写不敏感 include 类似 jsp 中的 include，多实例的情况可以把公用的配置文件提取出来 ip 地址的绑定 bind 默认情况 bind=127.0.0.1 只能接受本机的访问请求 不写的情况下，无限制接受任何 ip 地址的访问 生产环境肯定要写你应用服务器的地址 如果开启了 protected-mode，那么在没有设定 bind ip 且没有设密码的情况下， Redis 只允许接受本机的相应 tcp-backlog 可以理解是一个请求到达后至到接受进程处理前的队列 backlog 队列总和=未完成三次握手队列 + 已经完成三次握手队列 高并发环境 tcp-backlog 设置值跟超时时限内的 Redis 吞吐量决定 timeout 一个空闲的客户端维持多少秒会关闭， 0 为永不关闭。 tcp keepalive 对访问客户端的一种心跳检测，每个 n 秒检测一次，官方推荐设置为 60 秒 daemonize 是否为后台进程 pidfile 存放 pid 文件的位置，每个实例会产生一个不同的 pid 文件 log level 四个级别根据使用阶段来选择，生产环境选择 notice 或者 warning log level 日志文件名称 syslog 是否将 Redis 日志输送到 linux 系统日志服务中 syslog-ident 日志的标志 syslog-facility 输出日志的设备 database 设定库的数量 默认 16 security 在命令行中设置密码 maxclient 最大客户端连接数 maxmemory 设置 Redis 可以使用的内存量。一旦到达内存使用上限， Redis 将会试图移除内部数据，移除规则可以通过 maxmemory-policy 来指定。如果 Redis 无法根据移除规则来移除内存中的数据，或者设置了“不允许移除”，那么 Redis 则会针对那些需要申请内存的指令返回错误信息，比如 SET、 LPUSH 等。 Maxmemory-policy volatile-lru: 使用 LRU 算法移除 key, 只对设置了过期时间的键 allkeys-lru：使用 LRU 算法移除 key volatile-random：在过期集合中移除随机的 key，只对设置了过期时间的键 allkeys-random：移除随机的 key volatile-ttl：移除那些 TTL 值最小的 key，即那些最近要过期的 key noeviction：不进行移除。针对写操作，只是返回错误信息 Maxmemory-samples 设置样本数量， LRU 算法和最小 TTL 算法都并非是精确的算法，而是估算值，所以你可以设置样本的大小。一般设置 3 到 7 的数字，数值越小样本越不准确，但是性能消耗也越小。 三、Redis 的 Java 客户端 Jedis1、Jedis 所需要的 jar 包，可以通过 Maven 的依赖引入 使用 Windows 环境下 Idea 连接虚拟机中的 Redis 注意事项 禁用 Linux 的防火墙： Linux(CentOS7)里执行命令 ： systemctl stop firewalld.service redis.conf 中注释掉 bind 127.0.0.1 ,然后 protect-mode no。 Jedis 测试连通性 : 123456789 public class JedisTest &#123; public static void main(String[] args) &#123; // 连接本地 Redis 服务 Jedis jedis = new Jedis(&quot;192.168.64.129&quot;,6379); // 查看服务是否运行，打出pong 表示OK System.out.println(&quot;connection is OK =====&gt;:&quot; + jedis.ping()); &#125;&#125; 四、 Redis 事务1、Redis 中的事务的定义​ Redis 事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。Redis 事务的主要作用就是串联多个命令防止别的命令插队。 2、multi、exec、discard 从输入 Multi 命令开始，输入的命令都会依次进入执行命令列中，单不会执行，至到输入 Exec 后，Redis 会将之前的命令依次执行。 组队的过程中可以通过 discard 来放弃组队。 3、事务中的错误处理 组队中的某个命令出现了报告错误，执行时整个的所有队列都会别取消。 如果执行阶段某个命令出现了错误，则只有报错的命令不会被执行，而其他的命令会执行，不会回滚。 4、通过事务解决问题 悲观锁(Pessimistic Lock) ，顾名思义，就是很悲观，每次去拿数据的时候都被认为别人会修改，所以每次在那数据的时候都会上锁，这样别人想拿这个数据就会 block 直接它拿到锁。传统的关系型数据库里边就用到了很多这样的机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。 乐观锁(Optimistic Lock) ,顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下再此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量。Redis 就是利用这种 check-and-set 机制实现的事务。 5、Redis 事务的使用 WACH key[key….] 在执行 multi 之前， 先执行 watch key1[key2], 可以监视一个(或多个)key，如果在事务执行之前这个(或这些)Key 被其他命令所改动，那么事务将被打断。 unwatch 取消 WATCH 命令对所有 key 监视。如果执行 WATCH 命令之后，EXEC 命令或 DISCAED 命令先被执行了的话，那么就不需要在执行 UNWINAH 了。 三特性 单独的隔离操作 事务中的所有命令都会被序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发来的命令请求所打断。 没有隔离级别的概念 队列中的命令没有被提交之前都不会实际的被执行，因为事务提交前的任何指令都不会被实际执行，也就不存在”事务内的查询要看到事务里的更新，在事务外查询不能看到” 不保证原子性 Redis 同一个事务中如果有一条命令执行失败，其后的命令仍会被执行，没有回滚 五、Redis 持久化Redis 提供 2 个不用形式的持久化方式 RDB 和 AOF 1、RDB 在指定的时间间隔内将内存中的数据集快照写入磁盘，也就是行话讲的 Snapshot 快照，它恢复时是将快照文件直接读到内存里。 备份的执行：Redis 会单独创建（fork）一个子进程来进行持久化，会将数据写入到一个临时文件中，待持久化进程都结束，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何的 IO 操作的，这就是确保了极高的性能如果需要进行大规模的数据恢复，且对数据恢复的完整性不是非常敏感,那 RDB 方式要比 AOF 方式更加的高效。RDB 的缺点是最后一次持久化后的数据可能丢失。 fork： 在 Linux 程序中，fork() 会产生一个和父进程完全相同的子进程，但子进程在此后多会 exec 系统调用，出于效率考虑，Linux 中引入”写时复制技术“，一般情况父进程和子进程会共同一段物理内存，只有进程空间的各段的内容要发生变化时，才会父进程的内容复制一份个子进程。 RDB 保存的文件 在 redis.conf 中的配置文件，默认为 dump. rdb RDB 文件的保存路径 默认为 Redis 启动时命令所在的目录下，也可以修改 RDB 的保存策略 手动保存快照 save：只管保存，其他不管，全部阻塞 bgsave: 按照保存策略的自动保存 RDB 的相关配置 stop-writes-on-bgsave-error yes 当 Redis 无法写入磁盘的话，直接关闭 Redis 的写入操作。 rdbcompression yes 进行 rdb 保存时，将文件压缩 rdbchecksum yes 在存储的快照后，还可以让 Redis 使用 CRC64 算法来进行数据校验，但是这样做会增加大约 10% 的性能消耗，如果希望获取到最大的性能提升，可以关闭此功能 RDB 的备份 与恢复 备份:先通过 config get dir 查询 rdb 文件的目录 , 将*.rdb 的文件拷贝到别的地方 恢复: 关闭 Redis，把备份的文件拷贝到工作目录下,启动 redis,备份数据会直接加载。 RDB 的优缺点 优点: 节省磁盘空间,恢复速度快. 缺点：虽然 Redis 在 fork 时使用了写时拷贝技术，但是如果数据庞大时还是比较消耗性能。在备份周期在一定的间隔时间做一次备份，所有如果 Redis 意外 down 掉的话，就会失去最后一个快照后的所有修改。 2、AOF 以日志的形式来记录每个写的操作，将 Redis 执行的过程的所有写的指令记录下来（读操作不记录），只许追加文件但不可以改写文件，Redis 启动之初会读取该文件重新构建数据，换言之，Redis 重启的话就根据日志文件的内容将写的指令从前到后执行一次以完成数据的恢复工作。 AOF 默认不开启，需要手动在配置文件中配置。 可以在 redis.conf 中配置文件名称，默认为 appendonly.aof ​ AOF 文件的保存路径，同 RDB 的路径一致 AOF 文件故障备份 AOF 的备份机制和性能虽然和 RDB 不同，但是备份和恢复的操作 RDB 一样，都是拷贝文件，需要恢复时再拷贝到 Redis 工作目录下，启动系统即加载 AOF 文件故障恢复 如遇到 AOF 文件损坏，可通过 redis-check-aof –fix appendonly.aof 进行恢复 AOF 同步频率设置 始终同步，每次 Redis 的写入都会立刻记入日志 。 每秒同步，每秒记入日志一次，如果宕机，本秒的数据可能丢失。 把不主动进行同步，把同步时机交给操作系统。 Rewrite AOF 采用文件追加方式，文件会越来越大为避免出现此种情况，新增了重写机制,当 AOF 文件的大小超过所设定的阈值时， Redis 就会启动 AOF 文件的内容压缩，只保留可以恢复数据的最小指令集.可以使用命令 bgrewriteaof。 Redis 实现重写：AOF 文件持续增长而过大时，会 fork 出一条新进程来将 3 文件重写（也是先写临时文件最后写 rename）,遍历新进程的内存中的数据，每条记录有一条的 Set 语句。重写的 aof 文件的操作，并没有读取旧的 aof 文件，而是将整个内存中的数据库名内容用命令的方式重写了一个新的 aof 文件，这点和快照有点类似。 何时重写: 重写虽然可以节省大量的磁盘空间，减少恢复时间。但是每次重写还是有一定的负担的，因此设定 Redis 要满足一定条件才会进行重写。 系统载入时或者上次重写完毕时，Redis 会记录此时的 AOF 大写，设为 base_size,如果 Redisde AOF 当前大小 &gt;= base_size + base_size*100%(默认)且当前大小&gt;=64mb(默认)的情况下，Redis 会对 AOF 进行重写。 AOF 的优缺点 优点： 备份机制更稳点，丢失数据概率更低。 可读的日志文本，通过操作 AOF 稳健，可以处理误操作。 缺点： 比起 RDB 占用更多的磁盘空间 恢复备份速度要慢 每次读写都同步的话，有一定的性能压力。 3、RDB 和 AOF 用哪个好 官方推荐两个都启用。 如果对数据不敏感，可以选单独用 RDB 不建议单独使用 AOF， 因为可能会出现 Bug。 如果只是做内存缓存，可以都不用 六、Redis 主从复制​ 主从复制，就是主机数据更新后根据配置和策略，自动同步到备用的 master/slaver 机制。 Master 以写为主， Slave 以读为主。 1、主从复制的目的 读写分离，性能扩展 容灾快速恢复 2、主从配置 原则：配从不配主 步骤: 准备三个 Redis 实例，一主两从 拷贝多个 redis.conf 文件 include 开启 daemonize yes pid 文件名字 pidfile 指定端口 port Log 文件名字 Dump.rdb 名字 dbfilename Appendonly 关闭或换掉名字 1234include /opt/myRedis/redis.confpidfile /var/run/redis6381.pidport 6381dbfilename dump6381.rdb info replication 打印主从复制的相关信息 salveof &lt;ip&gt; &lt;port&gt; 成为主从复制的相关信息 3、一主二从模式 复制原理： 每次从机联通之后，都会给主机发送 sync 指令 主机立即进行存盘操作，发送 RDB 文件，给从机 从机收到 RDB 文件后，进行全盘加载 之后每次主机的写操作，都会立刻发送给从机，从机执行相同的命令 4、薪火相传模式演示 上一个 slave 可以是下一个 slave 的 Master，slave 同样可以接收其他的 slaves 的接收和同步请求，那么该 slave 作为链条中下一个的 master, 可以有效减轻 master 的写压力，去同步化降低风险。 中途变更转向：会清除之前的数据，重新建立拷贝最新的 风险是一旦某个 slave 宕机，后面的 slave 都没法备份 反客为主（小弟上位） 当一个 master 宕机后，后面的 slave 可以立即升为 master， 其后面的 slave 不用做任何修改。用 slave no one 将从机边为主机。 哨兵模式 sentine（推荐大哥） 反客为主的自动版，能够后台监控主机是否故障，如果故障了根据投票数自动将从库转换为主库。 配置哨兵 调整为一主二从模式 自定义的/myRedis 目录下新建 sentine.conf 文件 在配置文件中填写内容 ==sentinel monitor mymaster 127.0.0.1 6379 1== 其中 mymaster 为监控对象起的服务器名称(随意起)， 1 为 至少有多少个哨兵同意迁移的数量。 启动哨兵 执行 redis-sentinel /myRedis/sentinel.conf 5、故障恢复 七、Redis 集群1、集群 Redis 集群 实现了对 Redis 的水平扩容，即启动 N 个 redis 节点，将整个数据库分布式存储在这个 N 个节点中， 每个节点存储总数据的 1/N。 Redis 集群通过分区(partiton）来提供一定程度的可用性（availability ）： 即使集群中有部分节点失效或者无法进行通信，集群也可以继续处理命令请求。 2、安装 ruby 环境① 能上网 执行yum install ruby 执行 yum install rubygems ② 不能上网 cd /run/media/root/CentOS 7 x86_64/Packages 获取如下 rpm 包 ==注意==： 因为 redis 集群需要使用 2.3.0 及以上版本，而 Linux 系统自带的是 2.0.0,需要更新一下，才能启动 方法：换 yum 源安装 12345678yum install centos-release-scl-rh //会在/etc/yum.repos.d/目录下多出一个CentOS-SCLo-scl-rh.repo源yum install rh-ruby23 -y //直接yum安装即可 scl enable rh-ruby23 bash //必要一步ruby -v //查看安装版本 使用：gem install redis 3、准备 6 个 Redis 实例 准备 6 个实例 6379,6380,6381,6389,6390,6391 拷贝多个 redis.conf 文件开启 daemonize yesPid 文件名字指定端口Log 文件名字Dump.rdb 名字Appendonly 关掉或者换名字 再加入如下配置cluster-enabled yes 打开集群模式cluster-config-file nodes-端口号.conf 设定节点配置文件名cluster-node-timeout 15000 设定节点失联时间，超过该时间（毫秒），集群自动进行主从切换 1234567include /opt/myRedis/redis.confpidfile /var/run/redis6379.pidport 6379dbfilename dump6379.rdbcluster-enabled yescluster-config-file nodes-6379.confcluster-node-timeout 15000 4、合体 将 6 个实例全部启动， nodes-端口号.conf 文件都生成正常 2.合体 进入到 cd /opt/redis-3.2.5/src 执行 ./redis-trib.rb create –replicas 1 192.168.64.129:6379 192.168.64.129:6380 192.168.64.129:6381 192.168.64.129:6389 192.168.64.129:6390 192.168.64.129:6391 ==注意: IP 地址修改为当前服务器的地址，端口号为每个 Redis 实例对应的端口号== 5、集群操作 以集群的方式进入客户端 1redis-cli -c -p 端口号 通过 cluster nodes 命令查看集群信息 redis cluster 如何分配这六个节点。一个集群至少要有三个主节点。选项 –replicas 1 表示我们希望为集群中的每个主节点创建一个从节点。分配原则尽量保证每个主数据库运行在不同的 IP 地址，每个从库和主库不在一个 IP 地址上。 slots ：一个 Redis 集群包含 16384 个插槽（ hash slot）， 数据库中的每个键都属于这 16384 个插槽的其中一个， 集群使用公式 CRC16(key) % 16384 来计算键 key 属于哪个槽， 其中 CRC16(key) 语句用于计算键 key 的 CRC16 校验和 。 集群中的每个节点负责处理一部分插槽。 举个例子， 如果一个集群可以有主节点，其中： 节点 A 负责处理 0 号至 5500 号插槽。 节点 B 负责处理 5501 号至 11000 号插槽。 节点 C 负责处理 11001 号至 16383 号插槽 在集群中录入值 在 redis-cli 每次录入、查询键值， redis 都会计算出该 key 应该送往的插槽，如果不是该客户端对应服务器的插槽， redis 会报错，并告知应前往的 redis 实例地址和端口. redis-cli 客户端提供了 – c 参数实现自动重定向。如 redis-cli -c – p 6379 登入后，再录入、查询键值对可以自动重定向。 不在一个 slot 下的键值，是不能使用 mget,mset 等多键操作。 可以通过{}来定义组的概念，从而使 key 中{}内相同内容的键值对放到一个 slot 中去 。 不在一个 slot 下的键值，是不能使用 mget,mset 等多键操作。 可以通过{}来定义组的概念，从而使 key 中{}内相同内容的键值对放到一个 slot 中去 。 查询集群中的值 CLUSTER KEYSLOT &lt;key&gt; 计算键 key 应该被放置在哪个槽上。 CLUSTER COUNTKEYSINSLOT &lt;slot&gt; 返回槽 slot 目前包含的键值对数量 CLUSTER GETKEYSINSLOT &lt;slot&gt; &lt;count&gt; 返回 count 个 slot 槽中的键 6、集群的 Jedis 开发123456789public class JedisClusterTest &#123; public static void main(String[] args) &#123; Set&lt;HostAndPort&gt; set =new HashSet&lt;HostAndPort&gt;(); set.add(new HostAndPort(&quot;192.168.64.129&quot;,6379)); JedisCluster jedisCluster=new JedisCluster(set); jedisCluster.set(&quot;k1&quot;, &quot;v1&quot;); System.out.println(jedisCluster.get(&quot;k1&quot;)); &#125;&#125; 7、Redis 集群的优缺点 优点 实现扩容 分摊压力 无中心配置相对简单 缺点 多键操作是不被支持的 多键的 Redis 事务是不被支持的。 lua 脚本不被支持。 由于集群方案出现较晚，很多公司已经采用了其他的集群方案，而代理或者客户端分片 的方案想要迁移至 redis cluster，需要整体迁移而不是逐步过渡，复杂度较大。","categories":[{"name":"Redis","slug":"Redis","permalink":"http://blog.oy6090.top/categories/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://blog.oy6090.top/tags/Redis/"}]},{"title":"Git基本使用","slug":"git 基本使用","date":"2020-08-14T16:00:00.000Z","updated":"2020-08-14T16:00:00.000Z","comments":true,"path":"posts/2493.html","link":"","permalink":"http://blog.oy6090.top/posts/2493.html","excerpt":"","text":"一、git 基本指令git 安装案例 1、创建版本库 在项目文件夹内， 执行： git init 2、提交文件 指令 描述 git status 进行查看文件状态 git add 文件名 将文件添加到暂存区 git commit 提交文件到本地库 git commit -m “注释内容” 编写注释，完成提交 3、查看文件提交记录 执行 git log 文件名 进行查看历史记录 git log –pretty=oneline 文件名 （简易信息查看） 4、回退历史 git reset –hard HEAD^ 回到上一次提交 git rest – hard HEAD~n 回退 n 次操作（回退 2 次版本以上，就建议使用此指令） 5、版本穿越 进行查看历史记录的版本号，执行 git reflog 文件名 执行git reset –hard 版本号 6、还原文件 git checkout – 文件名 7、删除某个文件 先删除文件，在git add 提交 8、git 结构 工作区：就是电脑的本地的磁盘目录 本地库：工作区有个掩藏目录.git，它就是 Git 的本地版本库 暂存区：一般存放在”git 目录”下的 index 文件(.git/index)中，所以我们把暂存区有时也叫索引区(index)。 9、创建分支 git branch &lt;分支名&gt; git branch -v 查看分支 10、切换分支 git checkout &lt;分支名&gt; 一步完成： git checkout -b &lt;分支名&gt; 11、合并分支 先切换到主干 git checkout master git merge &lt;分支名&gt; 12、冲突​ 冲突一般是指同一个文件同一位置的代码，在两个版本合并的时版本管理软件无法判断到底应该保留那个版本，因此会提示该文件发生冲突，需要手工判断解决冲突。 合并时冲突 ​ 程序合并时发生冲突系统会提示CONFLICT关键字，命令行后缀会进入MERGING状态，表示此时是解决冲突的状态。 解决冲突： 此时通过 git diff 可隐找到发生冲突的文件及冲突的内容。 然后修改冲突文件的内容，再次git add&lt;file&gt; 和 git commit 提交后，后缀MERGING消失，说明冲突解决完成。 二、git 与 github图示： 1、增加远程地址 git remote add &lt;远端代号&gt; &lt;远端地址&gt; &lt;远端代号&gt; 是指远程链接的代号，一般直接用 origin 做为代号，也可以自定义。 &lt;远端地址&gt;默认远程链接的 url 例如：git remote add origin https://github.com/user111/Helloworld.git 2、推送到远程库 git push &lt;远端代号&gt; &lt;本地分支的名称&gt; &lt;远端代号&gt; 是指远程链接的代号 &lt;分支名称&gt; 是指要提交的分支名字，比如 master。 例如：git push origin master 3、从 GitHub 上克隆一个项目 git clone &lt;远端地址&gt;&lt;新项目目录名&gt; &lt;远端地址&gt; 是指远程链接的地址 &lt;项目目录名&gt; 是指为克隆的项目在本地新建的目录名称，可以不填，默认是 Github 的项目名。 命令执行完成后，会自动为这个远端地址建一个名为 origin 的代号。 例如： git clone https://github.com/user111/Helloworld.git hello_world 4、从 gitHub 更新项目 git pull &lt;远端代号&gt;&lt;远端分支名&gt; &lt;远端代号&gt; 是指远程链接的代号 &lt;远端分支名&gt; 是指远端的分支名称，如 master. 例如：git pull origin master 5、协作冲突 三、https VS ssh​ ssh 模式与 https 模式的一个重要的好处就是，每次 push、pull、fetch 等操作时，不用重复填写用户名密码。（前提是你必须是这个项目的拥有者或合作者，且配置好了 ssh key）。 1、配置 SSH key 步骤 1：检查电脑上是否已经生成 SSH Key 在 git bash 下执行如下命令 步骤 2：创建 SSH Key: ssh-keygen -t rsa -C &#x58;&#88;&#x58;&#88;&#88;&#88;&#64;&#x68;&#97;&#105;&#110;&#97;&#110;&#x2e;&#x6e;&#x65;&#116; 成功的话在~/下生成.shh 文件夹，进去，打开 id_rsa.pub, 复制里面的 Key。 步骤 3：进入.sshwe 文件包，打印 id_rsa.pub 的内容，复制全部内容 步骤 4：登入 GitHub 后，右上角点击 setting 步骤 5：在左侧菜单中选择 SSH and GPG keys 步骤 6：Title 随便写，Key 把之前 id_rsa.pub 的内容复制进去，点击 Add SSH Key，设置 shh key 完成。 测试连通性：找到一个项目，要改用 ssh 连接 要建立新的远程代号 &#x67;&#x69;&#116;&#x40;&#103;&#x69;&#x74;&#x68;&#117;&#x62;&#x2e;&#x63;&#111;&#109;:yuebuqun3333/jianfa.git(参考上面) git remote add originssh &#x67;&#x69;&#116;&#x40;&#103;&#105;&#x74;&#104;&#117;&#98;&#46;&#99;&#111;&#x6d;:yuebuqun3333/jianfa.git ​ 以后再提交代码的时候就不用输入密码（第一次使用会要求输入个人 yes） git push originssh master 四、Git 工作流1、Git 工作流​ 简单来说就是，一个项目的成员们在工作中统一使用 Git 的方式。 2、集中式工作流 像 SVN 一样，集中式工作流以中央仓库为项目所修改的单店=点实体。所有的修改都是提交到 Master 这个分支上。 这种方式与 SVN 的主要区别就是开发人员有本地库，Git 很多特性并没有用到 3、GitFlow 工作流 Gitflow 工作流通过为功能开发、发布准备和维护设立独立的分支，让发布迭代的过程更流畅。严格的分支模型也为大型项目提供了一些非常必要的结构。 4、分支种类 主干分支 master 主要负责管理正在运行的生产环境代码。永远保持与正在运行的生产环境完全一致。 开发分支 develop 主要负责管理正在开发过程的代码。一般情况下应该是最新的代码。 bug 修理分支 hotfix 主要负责管理生产环境下出现的紧急修复代码。从主干分支分出，修理完毕并测试上线后，并回主干分支。并回后，视情况可以删除该分支。 发布版本分支 release 较大的版本上线前，会从开发分支中分出发布版本分支，进行最后阶段的集成测试。该版本上线后，会合并到主干分支。生产环境运行一段阶段较稳定后可以视情况删除。 功能分支 feature 为了不影响较短周期的开发工作，一般把中长期开发模块，会从开发分支中独立出来。 开发完成后会合并到开发分支。","categories":[{"name":"Git工具","slug":"Git工具","permalink":"http://blog.oy6090.top/categories/Git%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"GitHub","slug":"GitHub","permalink":"http://blog.oy6090.top/tags/GitHub/"}]},{"title":"Maven基本知识","slug":"Maven基本知识","date":"2020-08-13T16:00:00.000Z","updated":"2020-10-25T02:27:31.587Z","comments":true,"path":"posts/3554798849.html","link":"","permalink":"http://blog.oy6090.top/posts/3554798849.html","excerpt":"","text":"一、Maven 基本1、自动化构建​ 简单来说就是它可以自动的从建构过程的起点一直执行到终点： 2、Maven 核心概念 POM 约定的目录结构 坐标 依赖管理 仓库管理 生命周期 插件和目标 继承 聚合 3、安装使用① 检查 JAVA_HOME 环境变量 ② 解压 Maven 的核心程序 ​ 将 apache-maven-3.5.0-bin.zip 解压到一个非中文无空格的目录下。 例如： 1D:\\Server\\apache-maven-3.5.0 ③ 配置环境变量 M2_HOME：D:\\Server\\ apache-maven-3.5.0（以自己安装路径的为准） path：%M2_HOME%\\bin 或 D:\\Server\\ apache-maven-3.5.0\\bin ④ 查看 Maven 版本信息验证安装是否正确 ⑤ 配置本地仓库 Maven 默认的本地仓库： ~.m2\\repository 目录 。Tips： ~表示当前用户的家目录。 Maven 的核心配置文件位置 1解压目录\\ D:\\Server\\ apache-maven-3.5.0\\conf\\settings.xml 设置方式 12&lt;localRepository&gt;以及准备好的仓库位置&lt;/localRepository&gt;&lt;localRepository&gt;D:/RepMaven&lt;/localRepository&gt; 配置镜像源 123456&lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt; &lt;/mirror&gt; 配置使用的 JDK 版本 1234567891011121314&lt;profile&gt; &lt;id&gt;jdk-1.8&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;jdk&gt;1.8&lt;/jdk&gt; &lt;/activation&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt; &lt;/properties&gt;&lt;/profile&gt; 二、Maven 结构 main: 目录用于存放主程序 test: 目录用于存放测试的程序 java: 目录用于存放源码的文件。 resources: 目录用于存放配置文件和资源文件 1、Maven 约定的目录结构 （cmd 中使用）注意：运行 Maven 命令时一定要进入 pom.xml 文件所在的目录！ 指令 描述 mvn compile 编译源代码 mvn test-compile 编译测试代码 mvn test 运行应用程序中的单元测试 mvn clean 清除目标目录中的生成结果 mvn site 生成项目相关信息的网站 mvn package 依据项目生成 jar 文件 mvn install 在本地 Repository 中安装 jar mvn idea:idea 生成 idea 项目 mvn archetype:create 创建 Maven 项目 mvn eclipse:eclipse 生成 eclipse 项目 mvn source:jar 单独打包源码 补充： 指令 描述 mvn clean package mvn clean compile 清理编译 mvn clean test 三、POMProject Object Model：项目对象模型。 将 Java 工程的相关信息封装为对象作为便于操作和管理的模型。Maven 工程的核心配置。 可以说学习 Maven 就是学习 pom.xml 文件中的配置。 四、坐标1、Maven 的坐标 &lt;groupId&gt;com.oy.maven&lt;/groupId&gt; &lt;artifactId&gt;Hello&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; groupId：公司或组织的域名倒序+当前项目名称 artifactId： 当前项目的模块名称 version：当前模块的版本 2、通过坐标到仓库中查找 jar 包 将 gav 三个向量连起来 1com.oy.maven+Hello+0.0.1-SNAPSHOT 以连起来的字符串作为目录结构到仓库中查找 1com&#x2F;oy&#x2F;maven&#x2F;Hello&#x2F;0.0.1-SNAPSHOT&#x2F;Hello-0.0.1-SNAPSHOT.jar 注意：我们自己的 Maven 工程必须执行安装操作才会进入仓库。 安装的命令是： mvn install 五、依赖管理1、基本概念当 A jar 包需要用到 B jar 包中的类时，我们就说 A 对 B 有依赖。例如： commons-fileupload-1.3.jar 依赖于 commons-io-2.0.1.jar。通过第二个 Maven 工程我们已经看到， 当前工程会到本地仓库中根据坐标查找它所依赖的 jar 包。配置的基本形式是使用 dependency 标签指定目标 jar 包的坐标。 例如： 12345678910&lt;dependencies&gt; &lt;dependency&gt; &lt;!—坐标 --&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.10&lt;/version&gt; &lt;!-- 依赖的范围 --&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 2、接依赖和间接依赖如果 A 依赖 B， B 依赖 C， 那么 A→B 和 B→C 都是直接依赖，而 A→C 是间接依赖。 3、依赖的范围① compile main 目录下的 Java 代码可以访问这个范围的依赖 test 目录下的 Java 代码可以访问这个范围的依赖 部署到 Tomcat 服务器上运行时要放在 WEB-INF 的 lib 目录下 ​ 例如： 对 Hello 的依赖。主程序、测试程序和服务器运行时都需要用到。 ② test main 目录下的 Java 代码不能访问这个范围的依赖 test 目录下的 Java 代码可以访问这个范围的依赖 ]部署到 Tomcat 服务器上运行时不会放在 WEB-INF 的 lib 目录下 ​ 例如：对 junit 的依赖。仅仅是测试程序部分需要。 ③ provided main 目录下的 Java 代码可以访问这个范围的依赖 test 目录下的 Java 代码可以访问这个范围的依赖 部署到 Tomcat 服务器上运行时不会放在 WEB-INF 的 lib 目录下 例如： servlet-api 在服务器上运行时， Servlet 容器会提供相关 API，所以部署的时候不需要。 4、依赖的传递性 5、依赖的原则： 解决 jar 包冲突① 路径最短者优先 ② 路径相同时先声明者优先 ​ 这里“声明”的先后顺序指的是 dependency 标签配置的先后顺序。 6、依赖的排除123456789101112&lt;dependency&gt; &lt;groupId&gt;com.atguigu.maven&lt;/groupId&gt; &lt;artifactId&gt;Survey160225_4_Environment&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;!-- 依赖排除 --&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt; 7、统一管理目标 jar 包的版本1234567891011121314&lt;properties&gt; &lt;spring.version&gt;4.1.1.RELEASE&lt;/spring.version&gt;&lt;/properties&gt;.... &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; 六、生命周期1、Maven 的生命周期Maven 有三套相互独立的生命周期， 分别是： Clean Lifecycle 在进行真正的构建之前进行一些清理工作。 Default Lifecycle 构建的核心部分，编译，测试，打包，安装，部署等等。 Site Lifecycle 生成项目报告，站点，发布站点。 再次强调一下它们是相互独立的，你可以仅仅调用 clean 来清理工作目录，仅仅调用 site 来生成站点。当然你也可以直接运行 mvn clean install site 运行所有这三套生命周期。 2、clean 生命周期Clean 生命周期一共包含了三个阶段： pre-clean 执行一些需要在 clean 之前完成的工作 clean 移除所有上一次构建生成的文件 post-clean 执行一些需要在 clean 之后立刻完成的工作 3、Site 生命周期 pre-site 执行一些需要在生成站点文档之前完成的工作 site 生成项目的站点文档 post-site 执行一些需要在生成站点文档之后完成的工作，并且为部署做准备 site-deploy 将生成的站点文档部署到特定的服务器上 这里经常用到的是 site 阶段和 site-deploy 阶段，用以生成和发布 Maven 站点，这可是 Maven 相当强大的功能， Manager 比较喜欢，文档及统计数据自动生成，很好看。 七、继承​ 此时如果项目需要将各个模块的 junit 版本统一为 4.9， 那么到各个工程中手动修改无疑是非常不可取的。 使用继承机制就可以将这样的依赖信息统一提取到父工程模块中进行统一管理。 1、创建父工程​ 创建父工程和创建一般的 Java 工程操作一致，唯一需要注意的是： 打包方式处要设置为 pom。 2、在子工程中引用父工程 ... ... ... 从当前目录到父项目的 pom.xml 文件的相对路径 代码示例： 1234567&lt;parent&gt; &lt;groupId&gt;com.oy.maven&lt;/groupId&gt; &lt;artifactId&gt;Parent&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;!-- 指定从当前子工程的 pom.xml 文件出发，查找父工程的 pom.xml 的路径 --&gt; &lt;relativePath&gt;../Parent/pom.xml&lt;/relativePath&gt;&lt;/parent&gt; 此时如果子工程的 groupId 和 version 如果和父工程重复则可以删除。 3、在父工程中管理依赖将 Parent 项目中的 dependencies 标签，用 dependencyManagement 标签括起来 junit junit 4.9 test 在子项目中重新指定需要的依赖，删除范围和版本号 ​ ​ junit ​ junit ​ 八、聚合​ 将多个工程拆分为模块后， 需要手动逐个安装到仓库后依赖才能够生效。 修改源码后也需要逐个手动进行 clean 操作。 而使用了聚合之后就可以批量进行 Maven 工程的安装、清理工作。 1、配置聚合​ 在总的聚合工程中使用 modules/module 标签组合， 指定模块工程的相对路径即可 12345&lt;modules&gt; &lt;module&gt;../Hello&lt;/module&gt; &lt;module&gt;../HelloFriend&lt;/module&gt; &lt;module&gt;../MakeFriends&lt;/module&gt;&lt;/modules&gt;","categories":[{"name":"工具","slug":"工具","permalink":"http://blog.oy6090.top/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"Maven","slug":"Maven","permalink":"http://blog.oy6090.top/tags/Maven/"}]},{"title":"Mybatis基础","slug":"Mybatis基础","date":"2020-08-06T16:00:00.000Z","updated":"2020-10-25T02:27:51.758Z","comments":true,"path":"posts/3661501281.html","link":"","permalink":"http://blog.oy6090.top/posts/3661501281.html","excerpt":"","text":"mybatis-generator-core-1.3.2.jar 一、Mybatis 入门案例1、开发环境准备（Idea） 导入 MyBatis 框架的 jar 包、 MySQL 驱动包、log4j 的 jar 包 导入 log4j 的配置文件（复制粘贴即可） 12345678910111213141516171819202122&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE log4j:configuration SYSTEM &quot;log4j.dtd&quot;&gt;&lt;log4j:configuration xmlns:log4j=&quot;http://jakarta.apache.org/log4j/&quot;&gt; // 注意这里，自己使用的工具 &lt;appender name=&quot;STDOUT&quot; class=&quot;org.apache.log4j.ConsoleAppender&quot;&gt; &lt;param name=&quot;Encoding&quot; value=&quot;UTF-8&quot; /&gt; &lt;layout class=&quot;org.apache.log4j.PatternLayout&quot;&gt; &lt;param name=&quot;ConversionPattern&quot; value=&quot;%-5p %d&#123;MM-dd HH:mm:ss,SSS&#125; %m (%F:%L) \\n&quot; /&gt; &lt;/layout&gt; &lt;/appender&gt; &lt;logger name=&quot;java.sql&quot;&gt; &lt;level value=&quot;debug&quot; /&gt; &lt;/logger&gt; &lt;logger name=&quot;org.apache.ibatis&quot;&gt; &lt;level value=&quot;info&quot; /&gt; &lt;/logger&gt; &lt;root&gt; &lt;level value=&quot;debug&quot; /&gt; &lt;appender-ref ref=&quot;STDOUT&quot; /&gt; &lt;/root&gt;&lt;/log4j:configuration&gt; 注意： 1234&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE log4j:configuration SYSTEM &quot;log4j.dtd&quot;&gt;&lt;log4j:configuration xmlns:log4j=&quot;http://jakarta.apache.org/log4j/&quot;&gt; 这里的 &lt;log4j:configuration xmlns:log4j=”http://jakarta.apache.org/log4j/&quot;&gt; 在 Idea 中会报错 解决办法： 改为： 123&lt;!DOCTYPE log4j:configuration SYSTEM &quot;http://logging.apache.org/log4j/1.2/apidocs/org/apache/log4j/xml/doc-files/log4j.dtd&quot;&gt;&lt;log4j:configuration debug=&quot;true&quot;&gt; 最终版：（Idea） 12345678910111213141516171819202122&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE log4j:configuration SYSTEM &quot;http://logging.apache.org/log4j/1.2/apidocs/org/apache/log4j/xml/doc-files/log4j.dtd&quot;&gt;&lt;log4j:configuration debug=&quot;true&quot;&gt; &lt;appender name=&quot;STDOUT&quot; class=&quot;org.apache.log4j.ConsoleAppender&quot;&gt; &lt;param name=&quot;Encoding&quot; value=&quot;UTF-8&quot; /&gt; &lt;layout class=&quot;org.apache.log4j.PatternLayout&quot;&gt; &lt;param name=&quot;ConversionPattern&quot; value=&quot;%-5p %d&#123;MM-dd HH:mm:ss,SSS&#125; %m (%F:%L) \\n&quot; /&gt; &lt;/layout&gt; &lt;/appender&gt; &lt;logger name=&quot;java.sql&quot;&gt; &lt;level value=&quot;debug&quot; /&gt; &lt;/logger&gt; &lt;logger name=&quot;org.apache.ibatis&quot;&gt; &lt;level value=&quot;info&quot; /&gt; &lt;/logger&gt; &lt;root&gt; &lt;level value=&quot;debug&quot; /&gt; &lt;appender-ref ref=&quot;STDOUT&quot; /&gt; &lt;/root&gt;&lt;/log4j:configuration&gt; 2、创建测试表123456789101112-- 创建库CREATE DATABASE test_mybatis;-- 使用库USE test_mybatis;-- 创建表CREATE TABLE tb_user( uid INT PRIMARY KEY AUTO_INCREMENT, username VARCHAR(50), password VARCHAR(50), age INT, sex VARCHAR(20)); 3、创建 javaBean1234567891011public class User &#123; private Integer uid; private String userName; private String password; private Integer age; private String sex;....生成构造器，以及get、set、toString方法。 4、Mapper 接口1234public interface UserMapper &#123; User getUserByUid(String uid);&#125; 5、创建 MyBatis 的全局配置文件12345678910111213141516171819202122&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;!-- 数据库连接环境的配置 --&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/test_mybatis&quot;/&gt; // 根据自己的配置 &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt; // 根据自己的配置 &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 引入SQL映射文件,Mapper映射文件 --&gt; &lt;mappers&gt; &lt;mapper resource=&quot;UserMapper.xml&quot; /&gt; &lt;/mappers&gt;&lt;/configuration&gt; 6、创建 Mybatis 的 sql 映射文件12345678910111213141516171819&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.oy.online.mapper.UserMapper&quot;&gt; &lt;!-- &lt;select&gt;: 定义查询语句 id : 设置SQL语句的唯一标识 resultType: 结果类型，即实体类的全限定名 --&gt; &lt;select id=&quot;getUserByUid&quot; resultType=&quot;com.oy.online.bean.User&quot;&gt; select uid, username, password, age, sex from tb_user where uid = #&#123;uid&#125; &lt;/select&gt;&lt;/mapper&gt; 7、测试123456789101112public class TestMybatis &#123; @Test public void test() throws IOException &#123; InputStream is = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is); SqlSession sqlSession = sqlSessionFactory.openSession(); // getMapper():会通过动态代理动态生成UserMapper的代理实现类 UserMapper userMapper = sqlSession.getMapper(UserMapper.class); User userByUid = userMapper.getUserByUid(&quot;1&quot;); System.out.println(userByUid); &#125;&#125; 二、MyBatis 全局配置文件1、MyBatis 全局配置文件简介文件结构如下： ​ 2、properties 属性 创建一个资源文件，名为jdbc.properties 的文件,将四个连接字符串的数据在资源文件中通过键值 对(key=value)的方式放置 。 1234jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/test_mybatisjdbc.username=rootjdbc.password=root 123456&lt;!-- &lt;properties &gt;: 设置或引入资源文件 resource: 在类路径下访问资源文件 url: 在网络路径或磁盘路径下访问资源文件 --&gt; &lt;properties resource=&quot;jdbc.properties&quot;&gt;&lt;/properties&gt; 在 environment 元素的 dataSource 元素中为其动态设置 1234567891011&lt;environments default=&quot;mysql&quot;&gt; &lt;environment id=&quot;mysql&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot; /&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;$&#123;jdbc.driver&#125;&quot; /&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot; /&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot; /&gt; &lt;/dataSource&gt; &lt;/environment&gt;&lt;/environments&gt; 3、settings 属性12345678&lt;settings&gt; &lt;!-- 将下划线映射成驼峰，user_name映射为userName --&gt; &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt; &lt;!-- 开启延迟加载 --&gt; &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt; &lt;!-- 是否查询所有数据 --&gt; &lt;setting name=&quot;aggressiveLazyLoading&quot; value=&quot;false&quot;/&gt;&lt;/settings&gt; 4、typeAliases 别名处理 类型别名是为 Java 类型设置一个短的名字，可以方便我们引用某个类。 （typeAlias） 类很多的情况下，可以批量设置别名这个包下的每一个类创建一个默认的别名，就是简单类名小写 。(package) 12345678&lt;typeAliases&gt; &lt;!-- 为类型设置类型别名 type: Java 类型， 若只设置type, 默认的别名就是类型，且不区分大小写 --&gt; &lt;!--&lt;typeAlias type=&quot;com.oy.online.bean.User&quot; alias=&quot;user&quot;&gt;&lt;/typeAlias&gt;--&gt; &lt;package name=&quot;com.oy.online.bean&quot;/&gt;&lt;/typeAliases&gt; MyBatis 已经取好的别名 5、environments 环境配置 每种环境使用一个 evironments 标签进行匹配并指定唯一标识符 可以通过 environments 标签中的 defaul 属性指定一个环境的标识符来快速的切换环境。 1234567&lt;!-- &lt;environments&gt;:设置连接数据库的环境 default:设置默认使用的数据库环境--&gt;&lt;environments default=&quot;mysql&quot;&gt; .....&lt;/environments&gt; environment 指定具体环境 id：指定当前环境的唯一标识 transactionManager type: JDBC | MANAGED | 自定义 JDBC : 使用了 JDBC 的提交和回滚设置，依赖于从数据源的到的连接来管理事务范围。(JdbcTransactionFactory) MANAGED: 不提交或回滚一个连接、让容器管理事务的整个生命周期（比如 JEE 应用服务器的上下文。ManagedTransactionFactory ） 自定义： 实现 TransationFactory 接口，type = 全类名/别名 5、dataSource type: UNPOOLED | POOLED | JNDI | 自定义 UNPOOLED: 不使用连接池，UnpooledDataSourceFactory POOLED： 使用连接池， PooledDataSourceFactory JNDI： 在 EJB 或应用服务器这类容器中查找执行的数据源 自定义：实现 DataSourceFactory 接口 ，定义数据源的获取方式 提醒： 实际开发中我们使用 Spring 管理数据源，并进行事务控制的配置来覆盖上述的配置。 6、mappers 映射器 mapper 逐个注册 SQL 映射文件 resource : 引入类路径下的文件 url : 引入网络路径或者是磁盘路径下的文件 class : 引入 Mapper 接口。有 SQL 映射文件，要求 Mapper 接口与 SQL 映射文件同名同位置，没有 SQL 映射文件，使用注解在接口的方法上写 SQL 语句。 12345&lt;mappers&gt; &lt;mapper resource=&quot;EmployeeMapper.xml&quot; /&gt; &lt;mapper class=&quot;com.OY.mybatis.dao.EmployeeMapper&quot;/&gt; &lt;package name=&quot;com.OY.mybatis.dao&quot;/&gt;&lt;/mappers&gt; 使用批量注册，这种方式要求 SQL 映射文件名必须和接口名相同并且在同一目录下 &lt;package&gt; 123&lt;mappers&gt; &lt;package name=&quot;com.oy.online.Mapper&quot;/&gt;&lt;/mappers&gt; 三、Mybatis 映射文件（CRUD）1234&#x2F;&#x2F; namespace: 根据自己的接口来确定&lt;mapper namespace&#x3D;&quot;com.oy.online.Mapper.UserMapper&quot;&gt;....&lt;&#x2F;mapper&gt; SQL 映射文件有很少的几个顶级元素 cache – 给定命名空间的缓存配置。 cache-ref – 其他命名空间缓存配置的引用。 resultMap – 是最复杂也是最强大的元素，用来描述如何从数据库结果集中来加载对象。 sql – 可被其他语句引用的可重用语句块。 insert – 映射插入语句 update – 映射更新语句 delete – 映射删除语句 select – 映射查询语 1、selectMapper 接口方法 12// 根据eid 查询一个员工的信息Emp getEmpByEid(String eid); Mapper 映射文件 123&lt;select id=&quot;getEmpByEid&quot; resultType=&quot;com.oy.online.bean.Emp&quot;&gt; select eid, ename, age, sex, did from emp where eid = #&#123;eid&#125;&lt;/select&gt; 2、insertMapper 接口方法 12// 添加员工void addEmp(Emp emp); Mapper 映射文件 123&lt;insert id=&quot;addEmp&quot; &gt; insert into emp values(null, #&#123;ename&#125;, #&#123;age&#125;, #&#123;sex&#125;)&lt;/insert&gt; 3、updateMapper 接口方法 12// 修改员工信息void updateEmp(Emp emp); Mapper 映射文件 1234&lt;!--void updateEmp(Emp emp);--&gt;&lt;update id=&quot;updateEmp&quot;&gt; update emp set ename = #&#123;ename&#125;, age = #&#123;age&#125;, sex =#&#123;sex&#125; where eid = #&#123;eid&#125;&lt;/update&gt; 4、deleteMapper 接口方法 123&lt;delete id=&quot;deleteEmp&quot;&gt; delete from emp where eid = #&#123;eid&#125;&lt;/delete&gt; Mapper 映射文件 12// 删除员工信息Boolean deleteEmp(String eid); 四、Mybatis 映射文件（参数传递）1、主键生成方式、获取主键值 主键生成方式 支持主键自增，例如 MySQL 数据库 不支持主键自增，例如 Oracle 数据库 获取主键值 若数据库支持自动生成主键的字段（比如 MySQL 和 SQL Server），则可以设置useGeneratedKeys=”true”，然后再把 keyProperty 设置到目标属性上。 Mapper 接口方法 12//添加员工信息void insertEmp(Emp emp); Mapper 映射文件 1234567&lt;!-- useGeneratedKeys: 可以使用自动生成的主键 keyProperty： 将自动生成的主键赋值给传递过来的参数的哪一个属性--&gt;&lt;insert id=&quot;insertEmp&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;eid&quot;&gt; insert into emp values(null, &#x27;$&#123;ename&#125;&#x27;, $&#123;age&#125;, &#x27;$&#123;sex&#125;&#x27;)&lt;/insert&gt; 测试： 12345678910@Testpublic void tes1() throws IOException &#123; InputStream is = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is); SqlSession sqlSession = sqlSessionFactory.openSession(true); //自动处理事务 ParaMpper mapper = sqlSession.getMapper(ParaMpper.class); Emp emp = new Emp(null, &quot;小沫沫&quot;, 12, &quot;女&quot;); mapper.insertEmp(emp); System.out.println(emp.getEid());&#125; 2、 参数的传递mybatis 获取参数值的两种方式： ${}: insert into emp values(null, admit, 23, 男) Statement: 必须使用字符串拼接的方式操作 SQL，一定要注意单引号问题 #{}：insert into emp values(null, ?,?,?) PrepardStratement: 可以使通配符操作 SQL，因为在为 String 赋值时 使用建议：建议使用#{}，在特殊情况下，需要使用${},例如模糊查询和分页查询 参数传递的方式： 当传递参数为单个 String 或基本数据类型和其他包装类 #{} ：可以以任意的名字获取参数值 ${} : 只能以${value} 或 ${_parameter} 获取 当传输的参数为 JavaBean 时 #{} 和 ${} 都可以通过属性名直接获取属性值，但是要*注意${}的单引号问题。\\* 1insert into emp values(null, &#x27;$&#123;ename&#125;&#x27;, $&#123;age&#125;, &#x27;$&#123;sex&#125;&#x27;) 当传递多个参数时，mybatis 会默认将这些参数放在 map 集合中 两种方式： 键为 0,1,2,3…N-1, 以参数为值 键为 param1, param2,param3….paramN, 以参数为值 #{}：#{0}，#{1}；#{param1}、#{param2} ${}: ${param1}、${param2}, 但是要注意${}的单引号问题 12345&lt;select id=&quot;getEmpByEidAndEname&quot; resultType=&quot;Emp&quot;&gt; &lt;!--select eid, ename, age, sex from emp where eid = #&#123;0&#125; and ename = #&#123;1&#125;--&gt; &lt;!-- select eid, ename, age, sex from emp where eid = #&#123;param1&#125; and ename = #&#123;param2&#125;--&gt; select eid, ename, age, sex from emp where eid = &#x27;$&#123;param1&#125;&#x27; and ename = &#x27;$&#123;param2&#125;&#x27; &lt;/select&gt; 命名参数 为参数使用@Param 起一个名字，Mybatis 就会将这些参数封进 map 中， key 就是我们自己指的名字 Mapper 接口 1Emp getEmpByEidAndEnameByParam(@Param(&quot;eid&quot;) String eid, @Param(&quot;ename&quot;) String ename); Mapper 映射文件 1234&lt;!--Emp getEmpByEidAndEnameByParam(@Param(&quot;eid&quot;) String eid, @Param(&quot;ename&quot;) String ename)--&gt;&lt;select id=&quot;getEmpByEidAndEnameByParam&quot; resultType=&quot;Emp&quot;&gt; select eid, ename, age, sex from emp where eid = #&#123;eid&#125; and ename = #&#123;ename&#125;&lt;/select&gt; Map 我们也可以封装多个参数为 Map，直接传递 Mapper 映射文件 1234&lt;!--Emp getEmpByMap(Map&lt;String, Object&gt; map)--&gt;&lt;select id=&quot;getEmpByMap&quot; resultType=&quot;Emp&quot;&gt; select eid, ename, age, sex from emp where eid = $&#123;eid&#125; and ename = &#x27;$&#123;ename&#125;&#x27;&lt;/select&gt; _测试_： 123456789101112@Testpublic void test4() throws IOException &#123; InputStream is = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is); SqlSession sqlSession = sqlSessionFactory.openSession(true); ParaMpper mapper = sqlSession.getMapper(ParaMpper.class); HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;eid&quot;, &quot;3&quot;); map.put(&quot;ename&quot;, &quot;小明&quot;); Emp empByMap = mapper.getEmpByMap(map); System.out.println(empByMap);&#125; Collection/Array 会被 MyBatis 封装成一个 map 传入, Collection 对应的 key 是 collection,Array 对应的 key 是 array. 如果确定是 List 集合， key 还可以是 list. 3、参数处理 参数位置支持的属性 javaType、 jdbcType、 mode、 numericScale、 resultMap、 typeHandler、 jdbcTypeName、expression 实际上通常被设置的是：可能为空的列名指定 jdbcType ,例如: insert into orcl_employee(id,last_name,email,gender) values(employee_seq.nextval,#{lastName,jdbcType=NULL },#{email},#{gen der}) 4、参数的获取方式 #{key}: 获取参数的值，预编译到 SQL 中。安全。 ${key}: 获取参数的值，拼接到 SQL 中。有 SQL 注入问题。 5、select 查询的几种情况 查询单行数据返回单个对象 1Emp getEmpByEid(String eid); 查询数据表中的数量 1Integer getCount(); 查询多行数据返回对象的集合 1public List&lt;Employee&gt; getAllEmps(); 查询单行数据返回 Map 集合 1Map&lt;String, Object&gt; getEmpMapByEid(String eid); 查询多行数据返回 Map 集合 12@MapKey(&quot;eid&quot;) // 设置map的键，因为在查询时传出所有的员工信息，可以把员工信息作为值，但是必须设置键Map&lt;String, Object&gt; getAllEmpMap(); 6、resultMap 自定义映射 自定义 resultMap, 实现高级结果集映射。 id：用于完成主键值的映射。 result：用于完成普通列的映射。 association: 一个复杂的类型关联；许多的结果将包装成这种类型 collection： 复杂的类型集 12345&lt;resultMap&gt;：自定义映射，处理复杂的表关系&lt;id column=&quot;eid&quot; property=&quot;eid&quot;/&gt;&lt;id&gt;：设置主键的映射关系，column设置字段名，property设置属性名&lt;result column=&quot;ename&quot; property=&quot;ename&quot;/&gt;&lt;result&gt;：设置非主键的映射关系，column设置字段名，property设置属性名 ① id&amp;result 代码示例： 123456789&lt;select id=&quot;getEmployeeById&quot; resultMap=&quot;myEmp&quot;&gt; select id, last_name,email, gender from tbl_employee where id =#&#123;id&#125;&lt;/select&gt;&lt;resultMap type=&quot;com.oy.mybatis.beans.Employee&quot; id=&quot;myEmp&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot; /&gt; &lt;result column=&quot;last_name&quot; property=&quot;lastName&quot;/&gt; &lt;result column=&quot;email&quot; property=&quot;email&quot;/&gt; &lt;result column=&quot;gender&quot; property=&quot;gender&quot;/&gt;&lt;/resultMap&gt; ② association (多对一) POJO 中的属性可能会是一个对象,我们可以使用联合查询，并以级联属性的方式封装对象.使用 association 标签定义对象的封装规则 。 12345public class Dept &#123; private Integer did; private String dname;...省略set、get方法&#125; 12345678public class Emp &#123; private Integer eid; private String ename; private Integer age; private String sex; private Dept dept;...省略set、get方法&#125; 使用级联的方式 12345678910111213&lt;resultMap id=&quot;empMap&quot; type=&quot;Emp&quot;&gt; &lt;id column=&quot;eid&quot; property=&quot;eid&quot;/&gt; &lt;result column=&quot;ename&quot; property=&quot;ename&quot;/&gt; &lt;result column=&quot;age&quot; property=&quot;age&quot;/&gt; &lt;result column=&quot;sex&quot; property=&quot;sex&quot;/&gt; &lt;!--级联的方式--&gt; &lt;result column=&quot;did&quot; property=&quot;dept.did&quot;/&gt; &lt;result column=&quot;dname&quot; property=&quot;dept.dname&quot;/&gt;&lt;/resultMap&gt;&lt;select id=&quot;getAllEmp&quot; resultMap=&quot;empMap&quot;&gt; select e.eid, e.ename, e.age, e.sex, e.did, d.dname from emp e left join dept d on e.did = d.did&lt;/select&gt; Association 12345678910111213&lt;resultMap id=&quot;empMap&quot; type=&quot;Emp&quot;&gt; &lt;id column=&quot;eid&quot; property=&quot;eid&quot;/&gt; &lt;result column=&quot;ename&quot; property=&quot;ename&quot;/&gt; &lt;result column=&quot;age&quot; property=&quot;age&quot;/&gt; &lt;result column=&quot;sex&quot; property=&quot;sex&quot;/&gt; &lt;association property=&quot;dept&quot; javaType=&quot;Dept&quot;&gt; //javaType:&quot;com.oy.online.bean.Dept&quot; &lt;id column=&quot;did&quot; property=&quot;did&quot;/&gt; &lt;result column=&quot;dname&quot; property=&quot;dname&quot;/&gt; &lt;/association&gt;&lt;/resultMap&gt;&lt;select id=&quot;getAllEmp&quot; resultMap=&quot;empMap&quot;&gt; select e.eid, e.ename, e.age, e.sex, e.did, d.dname from emp e left join dept d on e.did = d.did&lt;/select&gt; ③ association 分布查询在世界开发中，对于每个实体类对都应该由具体的增删改查的方法，也就是 DAO 层，因此对于查询员工信息并将对应的部门信息也查询出来的需求，就可以通过分布的方式完成查询。 先通过员工的 id 查询员工的信息 在通过查询出来的员工信息的外键（部门 id） 查询对应的部门信息。 123456&lt;mapper namespace=&quot;com.oy.online.Mapper.DeptMapper&quot;&gt; &lt;!-- Dept getDeptByDid(String did);--&gt; &lt;select id=&quot;getDeptByDid&quot; resultType=&quot;Dept&quot;&gt; select did, dname from dept where did = #&#123;did&#125; &lt;/select&gt;&lt;/mapper&gt; 12345678910111213141516&lt;resultMap id=&quot;empMapStep&quot; type=&quot;Emp&quot;&gt; &lt;id column=&quot;eid&quot; property=&quot;eid&quot;/&gt; &lt;result column=&quot;ename&quot; property=&quot;ename&quot;/&gt; &lt;result column=&quot;age&quot; property=&quot;age&quot;/&gt; &lt;result column=&quot;sex&quot; property=&quot;sex&quot; /&gt; &lt;!-- select: 分布查询的SQL的id,即接口的全限定名、方法名或namespace.SQL的id column: 分布查询的条件，注意:此条件必须是数据库查询过得 --&gt; &lt;association property=&quot;dept&quot; select=&quot;com.oy.online.Mapper.DeptMapper.getDeptByDid&quot; column=&quot;did&quot; /&gt;&lt;/resultMap&gt;&lt;!-- Emp getEmpStep(String eid);--&gt;&lt;select id=&quot;getEmpStep&quot; resultMap=&quot;empMapStep&quot;&gt; select eid, ename, age, sex, did from emp where eid = #&#123;eid&#125;&lt;/select&gt; 测试： 123456789@Testpublic void test2() throws IOException &#123; InputStream is = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is); SqlSession sqlSession = sqlSessionFactory.openSession(true); EmpDeptMapper mapper = sqlSession.getMapper(EmpDeptMapper.class); Emp empStep = mapper.getEmpStep(&quot;1&quot;); System.out.println(empStep);&#125; ④ association 分步查询使用延迟加载​ 在分布查询的基础上，可以使用延迟加载来提升查询的效率，只需要在全局的 Settings 中进行如下配置： 1234&lt;!-- 开启延迟加载 --&gt;&lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt;&lt;!-- 设置加载的数据是按需还是全部 --&gt;&lt;setting name=&quot;aggressiveLazyLoading&quot; value=&quot;false&quot;/&gt; ⑤ collection (多对一或多对多) POJO 中的属性可能会是一个集合对象,我们可以使用联合查询，并以级联属性的方式封装对象.使用 collection 标签定义对象的封装规则 。 123456public class Dept &#123; private Integer did; private String dname; private List&lt;Emp&gt; emps;...省略set、get方法&#125; Collection 12345678910111213141516171819&lt;resultMap id=&quot;deptMap&quot; type=&quot;Dept&quot;&gt; &lt;id column=&quot;did&quot; property=&quot;did&quot;/&gt; &lt;result column=&quot;dname&quot; property=&quot;dname&quot;/&gt; &lt;!-- &lt;collection&gt;: 处理一对多和多对多的关系 ofType: 指集合中的类型，不需要指定javaType --&gt; &lt;collection property=&quot;emps&quot; ofType=&quot;Emp&quot;&gt; &lt;id column=&quot;eid&quot; property=&quot;eid&quot;/&gt; &lt;result column=&quot;ename&quot; property=&quot;ename&quot;/&gt; &lt;result column=&quot;age&quot; property=&quot;age&quot;/&gt; &lt;result column=&quot;sex&quot; property=&quot;sex&quot;/&gt; &lt;/collection&gt;&lt;/resultMap&gt; &lt;!-- Dept getDeptEmpsByDid(String did)--&gt;&lt;select id=&quot;getDeptEmpsByDid&quot; resultMap=&quot;deptMap&quot; &gt; select d.did, d.dname, e.eid, e.ename, e.age, e.sex from dept d left join emp e on d.did = e.did where d.did = #&#123;did&#125;&lt;/select&gt; ⑥ collection 分步查询​ 实际的开发中，对于每个实体类都应该有具体的增删改查方法，也就是 DAO 层， 因此对于查询部门信息并且将对应的所有的员工信息也查询出来的需求，就可以通过分步的方式完成查询。 先通过部门的 id 查询部门信息 再通过部门 id 作为员工的外键查询对应的部门信息 1234567891011121314 &lt;!--List&lt;Emp&gt; getEmpListByDid(String did);--&gt;&lt;select id=&quot;getEmpListByDid&quot; resultType=&quot;Emp&quot;&gt; select eid, ename, age, sex from emp where did= #&#123;did&#125;&lt;/select&gt;&lt;resultMap id=&quot;deprStep&quot; type=&quot;Dept&quot;&gt; &lt;id column=&quot;did&quot; property=&quot;did&quot;/&gt; &lt;result column=&quot;dname&quot; property=&quot;dname&quot;/&gt; &lt;collection property=&quot;emps&quot; select=&quot;com.oy.online.Mapper.EmpDeptMapper.getEmpListByDid&quot; column=&quot;did&quot;&gt;&lt;/collection&gt; &lt;/resultMap&gt;&lt;!--Dept getOnlyDeptByDid(String did);--&gt;&lt;select id=&quot;getOnlyDeptByDid&quot; resultMap=&quot;deprStep&quot;&gt; select did, dname from dept where did = #&#123;did&#125;&lt;/select&gt; 测试： 1234567891011@Testpublic void test4() throws IOException &#123; InputStream is = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is); SqlSession sqlSession = sqlSessionFactory.openSession(true); EmpDeptMapper mapper = sqlSession.getMapper(EmpDeptMapper.class); Dept onlyDeptByDid = mapper.getOnlyDeptByDid(&quot;1&quot;); System.out.println(onlyDeptByDid); System.out.println(&quot;=============================&quot;); System.out.println(onlyDeptByDid.getDname());&#125; ⑦ collection 分步查询使用延迟加载1234&lt;!-- 开启延迟加载 --&gt;&lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt;&lt;!-- 设置加载的数据是按需还是全部 --&gt;&lt;setting name=&quot;aggressiveLazyLoading&quot; value=&quot;false&quot;/&gt; ⑧ 扩展: 分步查询多列值的传递 如果分步查询时，需要传递给调用的查询中多个参数，则需要将多个参数封装成 Map 来进行传递，语法如下: {k1=v1, k2=v2….} 在所调用的查询方，取值时就要参考 Map 的取值方式，需要严格的按照封装 map 时所用的 key 来取值. &lt;collection property=”emps” select=”com.oy.online.Mapper.EmpDeptMapper.getEmpListByDid” column=”**{did=did}**”&lt;/collection&gt; ⑨ 扩展: association 或 collection 的 fetchType 属性 在&lt;association&gt; 和&lt;collection&gt;标签中都可以设置 fetchType，指定本次查询是否要使用延迟加载。默认为 fetchType=”lazy” ,如果本次的查询不想使用延迟加载，则可设置为 fetchType=”eager”. fetchType 可以灵活的设置查询是否需要使用延迟加载，而不需要因为某个查询不想使用延迟加载将全局的延迟加载设置关闭. &lt;collection property=”emps” select=”com.oy.online.Mapper.EmpDeptMapper.getEmpListByDid” column=”did” **fetchType=”eager”** &lt;/collection&gt; 五、Mybatis 动态 SQL1、Mybatis 动态 SQL 简介 动态的 SQL 是 Mybatis 强大的特征之一。极大的简化我们拼装 SQL 的操作 动态 SQL 元素和使用 JSTL 或其类似基于 XML 的文本处理器相似 Mybatis 采用功能强大的基于 OGNL 的表达式来简化 if choose(when , otherwise) trim(where, set) foreach OGNL（ Object Graph Navigation Language ）对象图导航语言，这是一种强大的 表达式语言，通过它可以非常方便的来作对象属性。 类似于我们的 EL， SpEL 等。 描述 属性 访问对象属性： person.name 调用方法： person.getName() 调用静态属性/方法： @java.lang.Math@PI@java.util.UUID@randomUUID() 调用构造方法： new com.oy.bean.Person(‘admin’).name 运算符： +,-*,/,% 逻辑运算符： in,not in,&gt;,&gt;=,&lt;,&lt;=,==,!= 注意：xml 中的特殊符号如：“&gt;”,“&lt;”等这些都需要使用转义字符 。 2、if where if 用于简单的判断 Where 用于解决 SQL 语句中的 where 关键字以及条件中第一个 and 或者 or 的问题。(去掉多余的 and) Mapper 接口 12// 根据eid,ename, age, sex,多条件查询员工的信息List&lt;Emp&gt; getEmpListByMultiter(Emp emp); Mapper 映射 1234567891011121314151617&lt;select id=&quot;getEmpListByMultiter&quot; resultType=&quot;Emp&quot;&gt; select eid, ename, age, sex from emp &lt;where&gt; &lt;if test=&quot;eid != null&quot;&gt; and eid = #&#123;eid&#125; &lt;/if&gt; &lt;if test=&quot;ename != null and ename != &#x27;&#x27;&quot;&gt; and ename = #&#123;ename&#125; &lt;/if&gt; &lt;if test=&quot;age != null&quot;&gt; and age = #&#123;age&#125; &lt;/if&gt; &lt;if test=&quot;sex == 1 or sex == 2&quot;&gt; and sex = #&#123;sex&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 3、trim Trim 可以在条件判断完的 SQL 语句前后添加 或者去掉指定的字符 prefix: 添加前缀（在操作的 SQL 语句前加入某些内容） prefixOverrides: 去掉前缀（把操作的 SQL 语句前的某些内容去掉） suffix: 添加后缀（在操作的 SQL 语句后加入某些内容） suffixOverrides: 去掉后缀 (把操作的 SQL 语句后的某些内容去掉) Mapper 映射 1234567891011121314151617&lt;select id=&quot;getEmpListByMultiter&quot; resultType=&quot;Emp&quot;&gt; select eid, ename, age, sex from emp &lt;trim prefix=&quot;where&quot; suffixOverrides=&quot;and|or&quot;&gt; &lt;if test=&quot;eid != null&quot;&gt; eid = #&#123;eid&#125; and &lt;/if&gt; &lt;if test=&quot;ename != null and ename != &#x27;&#x27;&quot;&gt; ename = #&#123;ename&#125; and &lt;/if&gt; &lt;if test=&quot;age !=null&quot;&gt; age = #&#123;age&#125; and &lt;/if&gt; &lt;if test=&quot;sex == 1 or sex == 0&quot;&gt; sex = #&#123;sex&#125; &lt;/if&gt; &lt;/trim&gt;&lt;/select&gt; Mapper 接口 12// 根据eid,ename, age, sex,多条件查询员工的信息List&lt;Emp&gt; getEmpListByMultiter(Emp emp); 4、set set 主要用于解决修改操作中 SQL 语句中可能多出的逗号的问题 Mapper 映射 123456789101112131415&lt;update id=&quot;updateEmpByConditionSet&quot;&gt; update emp &lt;set&gt; &lt;if test=&quot;ename != null and ename != &#x27;&#x27;&quot;&gt; ename = #&#123;ename&#125;, &lt;/if&gt; &lt;if test=&quot;age != null&quot;&gt; age = #&#123;age&#125;, &lt;/if&gt; &lt;if test=&quot;sex == 1 or sex == 2&quot;&gt; sex = #&#123;sex&#125; &lt;/if&gt; &lt;/set&gt; where eid = #&#123;eid&#125;&lt;/update&gt; Mapper 接口 12// 修改用户信息void updateEmpByConditionSet(Emp emp); 5、Choose(when、otherwise)choose 主要是用于分支判断，类似于 java 中的 switch case, 只会满足所有分支中的一个。 Mapper 映射 123456789101112131415161718&lt;select id=&quot;getEmpListByChoose&quot; resultType=&quot;Emp&quot;&gt; select eid, ename, age, sex from emp where &lt;choose&gt; &lt;when test=&quot;eid != null&quot;&gt; eid = #&#123;eid&#125; &lt;/when&gt; &lt;when test=&quot;ename != null and ename = &#x27;&#x27;&quot;&gt; ename = #&#123;ename&#125; &lt;/when&gt; &lt;when test=&quot;age != null&quot;&gt; age = #&#123;age&#125; &lt;/when&gt; &lt;otherwise&gt; sex = #&#123;sex&#125; &lt;/otherwise&gt; &lt;/choose&gt;&lt;/select&gt; Mapper 接口 12// 根据eid ,eanem, age, sex中的其中一个查询一个员工信息List&lt;Emp&gt; getEmpListByChoose(Emp emp); 6、foreach foreach 主要用于循环迭代 collection: 指定要遍历的集合或数组 item: 设置别名 close: 设置循环体开始内容 open: 设置循环体开始内容 separator: 设置每一次循环之间的分隔符 index: 若遍历的是 list, index 代表下标： 若遍历的是 map, index 代表键 ① 批量删除Mapper 接口 12//通过list集合实现批量删除void deleteMoreByList(@Param(&quot;eids&quot;)List&lt;Integer&gt; eids); Mapper 映射 12345678910111213141516 &lt;!--delete from emp where eid in ();delete from emp where eid = 1 or eid = 2 or eid = 3--&gt; &lt;delete id=&quot;deleteMoreByList&quot;&gt; delete from emp where &lt;foreach collection=&quot;eids&quot; item=&quot;eid&quot; separator=&quot;or&quot; open=&quot;(&quot; close=&quot;)&quot;&gt; eid = #&#123;eid&#125; &lt;/foreach&gt; &lt;/delete&gt; &lt;delete id=&quot;deleteMoreByList&quot;&gt; delete from emp where eid in &lt;foreach collection=&quot;eids&quot; item=&quot;eid&quot; separator=&quot;,&quot; open=&quot;(&quot; close=&quot;)&quot;&gt; #&#123;eid&#125; &lt;/foreach&gt; &lt;/delete&gt; ② 批量查询Mapper 接口 1List&lt;Emp&gt; SelectMoreByList(@Param(&quot;eids&quot;)List&lt;Emp&gt; eids); Mapper 映射 123456789101112&lt;select id=&quot;SelectMoreByList&quot; resultType=&quot;Emp&quot;&gt; select eid , ename, age, sex from emp where &lt;foreach collection=&quot;eids&quot; item=&quot;eid&quot; separator=&quot;or&quot; &gt; eid = #&#123;eid&#125; &lt;/foreach&gt;&lt;/select&gt;&lt;select id=&quot;SelectMoreByList1&quot; resultType=&quot;Emp&quot;&gt; select eid , ename, age, sex from emp where eid in &lt;foreach collection=&quot;eids&quot; item=&quot;eid&quot; separator=&quot;,&quot; open=&quot;(&quot; close=&quot;)&quot;&gt; #&#123;eid&#125; &lt;/foreach&gt;&lt;/select&gt; ③ 批量添加Mapper 接口 1void insertMoreByArray(@Param(&quot;emps&quot;)Emp[] emps); Mapper 映射 123456&lt;insert id=&quot;insertMoreByArray&quot;&gt; insert into emp values &lt;foreach collection=&quot;emps&quot; item=&quot;emp&quot; separator=&quot;,&quot;&gt; (null, #&#123;emp.ename&#125;, #&#123;emp.age&#125;, #&#123;emp.sex&#125;,1) &lt;/foreach&gt;&lt;/insert&gt; 测试 12345678910111213@Testpublic void test8() throws IOException &#123; SqlSessionFactory sqlSessionFactory = getSqlSessionFactory(); SqlSession sqlSession = sqlSessionFactory.openSession(true); EmpMapper mapper = sqlSession.getMapper(EmpMapper.class); Emp emp = new Emp(null, &quot;小小&quot;,12,&quot;女&quot;); Emp emp1 = new Emp(null, &quot;小名&quot;,14,&quot;女&quot;); Emp emp2 = new Emp(null, &quot;小正&quot;,17,&quot;男&quot;); Emp emp3 = new Emp(null, &quot;小莫&quot;,12,&quot;男&quot;); Emp[] emps = &#123;emp, emp1, emp2, emp3, emp3&#125;; mapper.insertMoreByArray(emps);&#125; ③ 批量修改注意：执行之前需要在 jdbc.properties 配置文件中的 url 最后配置 “**?allowMultiQueries=true**” jdbc.url=jdbc:mysql://localhost:3306/test_mybatis**?allowMultiQueries=true** Mapper 接口 1void updateMoreByArray(@Param(&quot;emps&quot;)List&lt;Emp&gt; emps); Mapper 映射 12345&lt;update id=&quot;updateMoreByArray&quot;&gt; &lt;foreach collection=&quot;emps&quot; item=&quot;emp&quot; &gt; update emp set ename = #&#123;emp.ename&#125;, age = #&#123;emp.age&#125;,sex = #&#123;emp.sex&#125; where eid = #&#123;emp.eid&#125;; &lt;/foreach&gt;&lt;/update&gt; 测试： 1234567891011121314151617@Testpublic void test9() throws IOException &#123; SqlSessionFactory sqlSessionFactory = getSqlSessionFactory(); SqlSession sqlSession = sqlSessionFactory.openSession(true); EmpMapper mapper = sqlSession.getMapper(EmpMapper.class); Emp emp = new Emp(14, &quot;小小&quot;,12,&quot;女&quot;); Emp emp1 = new Emp(15, &quot;小明&quot;,14,&quot;男&quot;); Emp emp2 = new Emp(16, &quot;小正&quot;,17,&quot;男&quot;); Emp emp3 = new Emp(17, &quot;小莫&quot;,12,&quot;男&quot;); List list = new ArrayList(); list.add(emp); list.add(emp1); list.add(emp2); list.add(emp3); mapper.updateMoreByArray(list);&#125; 7、sql sql 标签是用于抽取可重复的 sql 片段，将相同的，使用频繁的 SQL 片段抽取出来，单独定义，方便多次引用 抽取 SQL 123&lt;sql id=&quot;selectSQL&quot;&gt; select eid, ename, age, sex from emp&lt;/sql&gt; 引用 SQL： 1&lt;include refid=&quot;selectSQL&quot;&gt;&lt;/include&gt; 六、Mybatis 缓存机制1、缓存机制 Mybatis 包含一个非常强大的查询的缓存特征，它可以非常方便地搭配配置和定制。缓存可以极大的提升查询效率 Mybatis 系统中的默认定义了两极缓存。 一级缓存 二级缓存 默认情况下，只有一级缓存（Sqlsession 级别的缓存，也称为本地缓存）开启。 二级缓存需要手动开启配置，它是基于 namespace 级别的缓存（映射）。 为了提高扩展性。Mybatis 定义了缓存接口 Cache.我们可以通过实现 Cache 接口来自定义二级缓存。 2、一级缓存的使用Mapper 接口 12// 根据eid 来查询员工信息Emp getEmpByEid(String eid); Mapper 映射 12345678&lt;sql id=&quot;selectSQL&quot;&gt; select eid, ename, age, sex from emp&lt;/sql&gt;&lt;!--Emp getEmpByEid(String eid);--&gt;&lt;select id=&quot;getEmpByEid&quot; resultType=&quot;Emp&quot;&gt; &lt;include refid=&quot;selectSQL&quot;&gt;&lt;/include&gt; where eid = #&#123;eid&#125;&lt;/select&gt; 测试 1234567891011121314151617public SqlSessionFactory getSqlSessionFactory() throws IOException &#123; InputStream is = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is); return sqlSessionFactory;&#125;@Testpublic void test1() throws IOException &#123; SqlSessionFactory sqlSessionFactory = getSqlSessionFactory(); SqlSession sqlSession = sqlSessionFactory.openSession(true); EmpMapper mapper = sqlSession.getMapper(EmpMapper.class); Emp empByEid = mapper.getEmpByEid(&quot;14&quot;); System.out.println(empByEid); System.out.println(&quot;=================================&quot;); Emp empByEid1 = mapper.getEmpByEid(&quot;14&quot;); System.out.println(empByEid1);&#125; 说明：clearCache() 来清空本地缓存 3、一级缓存失效的几种情况 不同的 SqlSession 对应不同的一级缓存 同一个 SqlSession 但是查询条件不同 同一个 SqlSession 两次查询期间执行了任意一次增删改操作 同一个 SqlSession 两次查询期间手动清空了缓存 4、二级缓存的使用 二级缓存(second level cache)，全局作用域缓存 二级缓存默认不开启，需要手动配置 Mybatis 提供二级缓存的接口以及实现，缓存实现要求 POJO 实现 Serializable 接口 二级缓存在 SqlSession 关闭或提交之后才会生效 二级缓存使用步骤： 全局配置文件中开启二级缓存&lt;setting name=”cacheEnabled” value=”true”/&gt; 需要使用二级缓存的映射文件处使用 cache 配置缓存&lt;cache /&gt; 注意：POJO 需要实现 Serializable 接口 代码示例： 1234567891011121314151617 public SqlSessionFactory getSqlSessionFactory() throws IOException &#123; InputStream is = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is); return sqlSessionFactory; &#125;@Test public void test2() throws IOException &#123; SqlSessionFactory sqlSessionFactory = getSqlSessionFactory(); SqlSession sqlSession = sqlSessionFactory.openSession(true); EmpMapper mapper = sqlSession.getMapper(EmpMapper.class); Emp empByEid = mapper.getEmpByEid(&quot;14&quot;); System.out.println(empByEid); sqlSession.commit(); System.out.println(&quot;===============================&quot;); Emp empByEid1 = mapper.getEmpByEid(&quot;14&quot;); System.out.println(empByEid1); &#125; 二级缓存相关的属性 属性 描述 eviction=“FIFO” 缓存回收策略：LRU – 最近最少使用的：移除最长时间不被使用的对象。FIFO – 先进先出：按对象进入缓存的顺序来移除它们。SOFT – 软引用：移除基于垃圾回收器状态和软引用规则的对象。WEAK – 弱引用：更积极地移除基于垃圾收集器状态和弱引用规则的对象。默认的是 LRU flushInterval 刷新间隔，单位毫秒默认情况是不设置，也就是没有刷新间隔，缓存仅仅调用语句时刷新 size 引用数目，正整数代表缓存最多可以存储多少个对象，太大容易导致内存溢出 readOnly 只读， true/falsetrue：只读缓存；会给所有调用者返回缓存对象的相同实例。因此这些对象不能被修改。这提供了很重要的性能优势。false：读写缓存；会返回缓存对象的拷贝（通过序列化）。这会慢一些，但是安全，因此默认是 false。 5、缓存的相关属性设置 全局 setting 的 cacheEnable: 配置二级缓存的开关，一级缓存一直打开的。 select 标签的 userCache 属性：配置这个 select 是否使用二级缓存。一级缓存一直使用的 sql 标签的 flushCache 属性： 增删改默认 flushCache =true. sql 执行以后，会同时清空一级和二级缓存。 查询默认 flushCache = false。 sqlSession.clearCache(): 只是用来清除一级缓存。 6、整合第三方缓存 为了提高扩展性。myBatis 定义了 缓存接口 Cache。我们可以通过实现 Cache 接口来自定义二级缓存 整合 E 和 Cache 缓存步骤： ① 导入 echcache 包，以及整合包，日志包 ​ ② 编写 ehcache,xml 配置文件 12345678910111213141516171819202122232425262728293031323334353637&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;ehcache xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:noNamespaceSchemaLocation=&quot;../config/ehcache.xsd&quot;&gt; &lt;!-- 磁盘保存路径 --&gt; &lt;diskStore path=&quot;D:\\atguigu\\ehcache&quot; /&gt; &lt;defaultCache maxElementsInMemory=&quot;1000&quot; maxElementsOnDisk=&quot;10000000&quot; eternal=&quot;false&quot; overflowToDisk=&quot;true&quot; timeToIdleSeconds=&quot;120&quot; timeToLiveSeconds=&quot;120&quot; diskExpiryThreadIntervalSeconds=&quot;120&quot; memoryStoreEvictionPolicy=&quot;LRU&quot;&gt; &lt;/defaultCache&gt;&lt;/ehcache&gt;&lt;!--属性说明：l diskStore：指定数据在磁盘中的存储位置。l defaultCache：当借助CacheManager.add(&quot;demoCache&quot;)创建Cache时，EhCache便会采用&lt;defalutCache/&gt;指定的的管理策略以下属性是必须的：l maxElementsInMemory - 在内存中缓存的element的最大数目l maxElementsOnDisk - 在磁盘上缓存的element的最大数目，若是0表示无穷大l eternal - 设定缓存的elements是否永远不过期。如果为true，则缓存的数据始终有效，如果为false那么还要根据timeToIdleSeconds，timeToLiveSeconds判断l overflowToDisk - 设定当内存缓存溢出的时候是否将过期的element缓存到磁盘上以下属性是可选的：l timeToIdleSeconds - 当缓存在EhCache中的数据前后两次访问的时间超过timeToIdleSeconds的属性取值时，这些数据便会删除，默认值是0,也就是可闲置时间无穷大l timeToLiveSeconds - 缓存element的有效生命期，默认是0.,也就是element存活时间无穷大 diskSpoolBufferSizeMB 这个参数设置DiskStore(磁盘缓存)的缓存区大小.默认是30MB.每个Cache都应该有自己的一个缓冲区.l diskPersistent - 在VM重启的时候是否启用磁盘保存EhCache中的数据，默认是false。l diskExpiryThreadIntervalSeconds - 磁盘缓存的清理线程运行间隔，默认是120秒。每个120s，相应的线程会进行一次EhCache中数据的清理工作l memoryStoreEvictionPolicy - 当内存缓存达到最大，有新的element加入的时候， 移除缓存中element的策略。默认是LRU（最近最少使用），可选的有LFU（最不常使用）和FIFO（先进先出） --&gt; 注意：IDEA 中新建 ehcache.xml 文件报错 报错语句 1&lt;ehcache xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:noNamespaceSchemaLocation=&quot;../config/ehcache.xsd&quot;&gt; 解决办法 打开 settings - languages&amp;frameworks - schemas and dtds ,添加地址 http://ehcache.org/ehcache.xsd 将 “ ../config/ehcache.xsd ” 改成 “ http://ehcache.org/ehcache.xsd ” ③ 配置 cache 标签 1&lt;cache type=&quot;org.mybatis.caches.ehcache.EhcacheCache&quot;&gt;&lt;/cache&gt; ④ 测试 1234567891011121314151617181920@Test public void test3() throws IOException &#123; SqlSessionFactory sqlSessionFactory = getSqlSessionFactory(); SqlSession sqlSession = sqlSessionFactory.openSession(true); EmpMapper mapper = sqlSession.getMapper(EmpMapper.class); Emp empByEid = mapper.getEmpByEid(&quot;14&quot;); System.out.println(empByEid); sqlSession.commit(); System.out.println(&quot;====================================&quot;); EmpMapper mapper1 = sqlSession.getMapper(EmpMapper.class); Emp empByEid1 = mapper.getEmpByEid(&quot;6&quot;); System.out.println(empByEid1); sqlSession.commit(); System.out.println(&quot;====================================&quot;); EmpMapper mapper2 = sqlSession.getMapper(EmpMapper.class); Emp empByEid2 = mapper.getEmpByEid(&quot;7&quot;); System.out.println(empByEid2); &#125; 七、MyBatis 逆向工程1、逆向工程的配置 导入逆向工程的 jar 包 mybatis-generator-core-1.3.2.jar 编写 MBG 的配置文件（重要几处配置），可参考官方手册 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;&lt;generatorConfiguration&gt; &lt;!-- targetRuntime: 执行生成的逆向工程的版本 MyBatis3Simple: 生成基本的CRUD MyBatis3: 生成带条件的CRUD --&gt; &lt;context id=&quot;DB2Tables&quot; targetRuntime=&quot;MyBatis3&quot;&gt; &lt;!-- 设置连接数据库的信息 --&gt; &lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot; connectionURL=&quot;jdbc:mysql://localhost:3306/test_mybatis&quot; userId=&quot;root&quot; password=&quot;root&quot;&gt; &lt;/jdbcConnection&gt; &lt;javaTypeResolver &gt; &lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot; /&gt; &lt;/javaTypeResolver&gt; &lt;!-- javabean的生成策略 --&gt; &lt;javaModelGenerator targetPackage=&quot;com.oy.online.bean&quot; targetProject=&quot;.\\src&quot;&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot; /&gt; &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot; /&gt; &lt;/javaModelGenerator&gt; &lt;!-- 映射文件的生成策略 --&gt; &lt;sqlMapGenerator targetPackage=&quot;com.oy.online.Mapper&quot; targetProject=&quot;.\\config&quot;&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot; /&gt; &lt;/sqlMapGenerator&gt; &lt;!-- mapper接口的生成策略 --&gt; &lt;javaClientGenerator type=&quot;XMLMAPPER&quot; targetPackage=&quot;com.oy.online.Mapper&quot; targetProject=&quot;.\\src&quot;&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot; /&gt; &lt;/javaClientGenerator&gt; &lt;!-- 设置要将数据库中的哪张表逆向生成哪一个javabean --&gt; &lt;table tableName=&quot;emp&quot; domainObjectName=&quot;Emp&quot;&gt;&lt;/table&gt; &lt;table tableName=&quot;dept&quot; domainObjectName=&quot;Dept&quot;&gt;&lt;/table&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; 运行代码生成器生成代码 1234567891011@Testpublic void testMBG() throws Exception &#123; List&lt;String&gt; warnings = new ArrayList&lt;String&gt;(); boolean overwrite = true; File configFile = new File(&quot;mbg.xml&quot;); ConfigurationParser cp = new ConfigurationParser(warnings); Configuration config = cp.parseConfiguration(configFile); DefaultShellCallback callback = new DefaultShellCallback(overwrite); MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config, callback, warnings); myBatisGenerator.generate(null);&#125; 2、逆向工程的使用 基本查询（查询全部数据） 123456789@Testpublic void test2() throws Exception &#123; SqlSessionFactory sqlSessionFactory = getSqlSessionFactory(); SqlSession sqlSession = sqlSessionFactory.openSession(true); EmpMapper mapper = sqlSession.getMapper(EmpMapper.class); // 不添加条件，即是查询所有数据 List&lt;Emp&gt; emps = mapper.selectByExample(null); emps.forEach(System.out::println);&#125; 带条件查询 123456789101112131415161718192021@Testpublic void test1() throws Exception &#123; SqlSessionFactory sqlSessionFactory = getSqlSessionFactory(); SqlSession sqlSession = sqlSessionFactory.openSession(true); EmpMapper mapper = sqlSession.getMapper(EmpMapper.class); EmpExample empExample = new EmpExample(); EmpExample.Criteria c1 = empExample.createCriteria(); c1.andEnameLike(&quot;%a%&quot;); c1.andSexEqualTo(&quot;1&quot;); EmpExample.Criteria c2 = empExample.createCriteria(); c2.andDidEqualTo(2); empExample.or(c2); List&lt;Emp&gt; emps = mapper.selectByExample(empExample); for (Emp emp : emps) &#123; System.out.println(emp); &#125;&#125; 八、扩展-PageHelper 分页插件1、PageHelper 的使用步骤 导入相关包 pagehelper-x.x.x.jar 和 jsqlparser-0.9.5.jar 在 Mybatis 全局配置文件中配置分页插件 123&lt;plugins&gt; &lt;plugin interceptor=&quot;com.github.pagehelper.PageInterceptor&quot;&gt;&lt;/plugin&gt;&lt;/plugins&gt; 2、Page 对象的使用 载查询之前通过 PageHelps.startPage(页码，条数)设置分页信息，该方法返回 Page 对象 1234567891011121314151617181920public SqlSessionFactory getsqlSessionFactory() throws IOException &#123; InputStream is = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is); return sqlSessionFactory;&#125;@Testpublic void testPageHelps() throws IOException &#123; SqlSessionFactory sqlSessionFactory = getsqlSessionFactory(); SqlSession sqlSession = sqlSessionFactory.openSession(true); EmpMapper mapper = sqlSession.getMapper(EmpMapper.class); Page&lt;Object&gt; page = PageHelper.startPage(2, 3); List&lt;Emp&gt; emps = mapper.getAllEmps(); emps.forEach(System.out::println); System.out.println(&quot;====================================================&quot;); System.out.println(&quot;当前页：&quot; + page.getPageNum()); System.out.println(&quot;总页码:&quot;+ page.getPages()); System.out.println(&quot;总条数：&quot;+ page.getTotal()); System.out.println(&quot;每条显示的条数：&quot;+ page.getPageSize());&#125; 3、PageInfo 对象的使用 在查询完数据以后，使用 PageInfo 对象封装查询结果，可以获取更详细的分页信息以及完成分页逻辑 1234567891011121314151617181920212223242526272829@Testpublic void testPageHelps1() throws IOException &#123; SqlSessionFactory sqlSessionFactory = getsqlSessionFactory(); SqlSession sqlSession = sqlSessionFactory.openSession(true); EmpMapper mapper = sqlSession.getMapper(EmpMapper.class); // 设置分页信息 Page&lt;Object&gt; page = PageHelper.startPage(2, 3); List&lt;Emp&gt; emps = mapper.getAllEmps(); PageInfo&lt;Emp&gt; info = new PageInfo&lt;&gt;(emps, 5); for (Emp emp : emps) &#123; System.out.println(emp); &#125; System.out.println(&quot;===================================&quot;); System.out.println(&quot;当前页：&quot;+info.getPageNum()); System.out.println(&quot;总页数：&quot;+ info.getPages()); System.out.println(&quot;每页显示的条数：&quot; + info.getPageSize()); System.out.println(&quot;是否是第一页：&quot;+ info.isIsFirstPage()); System.out.println(&quot;是否显示最后一页：&quot; + info.isIsLastPage()); System.out.println(&quot;是否有上一页：&quot;+ info.isHasPreviousPage()); System.out.println(&quot;是否有下一页：&quot; + info.isHasNextPage()); System.out.println(&quot;======================================&quot;); int[] nums = info.getNavigatepageNums(); for (int num : nums) &#123; System.out.print(num + &quot; &quot;); &#125;&#125;","categories":[{"name":"JavaEE框架","slug":"JavaEE框架","permalink":"http://blog.oy6090.top/categories/JavaEE%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"java","slug":"java","permalink":"http://blog.oy6090.top/tags/java/"},{"name":"Mybatis","slug":"Mybatis","permalink":"http://blog.oy6090.top/tags/Mybatis/"}]},{"title":"MySQL基础","slug":"MySQL基础篇","date":"2020-08-03T16:00:00.000Z","updated":"2020-10-25T02:28:11.363Z","comments":true,"path":"posts/864013447.html","link":"","permalink":"http://blog.oy6090.top/posts/864013447.html","excerpt":"","text":"数据库的相关概念一、数据库的好处 可以持久化数据到本地 结构化查询 二、数据库的常见概念1、DB：数据库，存储数据的容器 2、DBMS：数据库管理系统，又称为数据库软件或数据库产品，用于创建或管理 DB3、SQL：结构化查询语言，用于和数据库通信的语言，不是某个数据库软件特有的，而是几乎所有的主流数据库软件通用的语言 三、数据库存储数据的特点1、数据存放到表中，然后表再放到库中 2、一个库中可以有多张表，每张表具有唯一的表名用来标识自己 3、表中有一个或多个列，列又称为“字段”，相当于java中“属性” 4、表中的每一行数据，相当于java中“对象” 四、常见的数据库管理系统mysql、oracle、db2、sqlserver 五、MySQL 的优点1、开源、免费、成本低 2、性能高、移植性也好 3、体积小，便于安装 DQL 语言基础查询一、语法select 查询列表 from 表名; 二、特点1、查询列表可以是字段、常量、表达式、函数，也可以是多个 2、查询结果是一个虚拟表 三、示例1、查询单个字段1select 字段名 from 表名; 1SELECT `last_name` FROM `employees`; 2、查询多个字段1select 字段名，字段名 from 表名; 12SELECT `last_name`,`email`,`employee_id`FROM employees; 3、查询所有字段1select * from 表名 1SELECT * FROM `employees`; 4、查询常量12select 常量值;注意：字符型和日期型的常量值必须用单引号引起来，数值型不需要 1SELECT 100 ; 5、查询函数select 函数名(实参列表); 123SELECT DATABASE();SELECT VERSION();SELECT USER(); 6、查询表达式1select 100/1234; 1select 100/1234; 7、起别名12①as②空格 1234567891011121314151617#方式一：使用as关键字SELECT USER() AS 用户名;SELECT USER() AS &quot;用户名&quot;;SELECT USER() AS &#x27;用户名&#x27;;SELECT last_name AS &quot;姓 名&quot; FROM employees;#方式二：使用空格SELECT USER() 用户名;SELECT USER() &quot;用户名&quot;;SELECT USER() &#x27;用户名&#x27;;SELECT last_name &quot;姓 名&quot; FROM employees; 8、去重1select distinct 字段名 from 表名; 1234#需求：查询员工涉及到的部门编号有哪些SELECT DISTINCT department_id FROM employees; 9、+1234作用：做加法运算select 数值+数值; 直接运算select 字符+数值;先试图将字符转换成数值，如果转换成功，则继续运算；否则转换成0，再做运算select null+值;结果都为null 123456789101112-- 需求：查询 first_name 和last_name 拼接成的全名，最终起别名为：姓 名#方案1：使用+ pass×SELECT first_name+last_name AS &quot;姓 名&quot;FROM employees;#方案2：使用concat拼接函数SELECT CONCAT(first_name,last_name) AS &quot;姓 名&quot;FROM employees; 10、【补充】concat 函数12功能：拼接字符select concat(字符1，字符2，字符3,...); 12SELECT CONCAT(first_name,last_name) AS &quot;姓 名&quot;FROM employees; 11、【补充】ifnull 函数1功能：判断某字段或表达式是否为null，如果为null 返回指定的值，否则返回原本的值 1select ifnull(commission_pct,0) from employees; 12、【补充】isnull 函数1功能：判断某字段或表达式是否为null，如果是，则返回1，否则返回0 条件查询一、语法123select 查询列表from 表名where 筛选条件 1234#案例：查询工资&lt;15000的姓名、工资SELECT last_name,salaryFROM employeesWHERE salary&lt;15000; 二、筛选条件的分类1、简单条件运算符1&gt; &lt; = &lt;&gt; != &gt;= &lt;= &lt;=&gt;安全等于 1234#案例：查询部门编号不是100的员工信息SELECT *FROM employeesWHERE department_id &lt;&gt; 100; 2、逻辑运算符123&amp;&amp; and|| or! not 1234567891011#案例1：查询部门编号不是 50-100之间员工姓名、部门编号、邮箱#方式1：SELECT last_name,department_id,emailFROM employeesWHERE department_id &lt;50 OR department_id&gt;100;#方式2：SELECT last_name,department_id,emailFROM employeesWHERE NOT(department_id&gt;=50 AND department_id&lt;=100); 3、模糊查询12like:一般搭配通配符使用，可以判断字符型或数值型通配符：%任意多个字符，_任意单个字符 1234#案例1：查询姓名中包含字符a的员工信息SELECT *FROM employeesWHERE last_name LIKE &#x27;%a%&#x27;; 4、其他between and 功能：判断某个字段的值是否介于xx之间 between and/not between and 123456#案例1：查询部门编号是30-90之间的部门编号、员工姓名#方式1：SELECT department_id,last_nameFROM employeesWHERE department_id BETWEEN 30 AND 90; in12345功能：查询某字段的值是否属于指定的列表之内a in(常量值1,常量值2,常量值3,...)a not in(常量值1,常量值2,常量值3,...)in/not inis null /is not null：用于判断null值 123456789#案例1：查询部门编号是30/50/90的员工名、部门编号#方式1：SELECT last_name,department_idFROM employeesWHERE department_id IN(30,50,90); is null/is not nullis null PK &lt;=&gt; 普通类型的数值 null值 可读性 is null × √ √ &lt;=&gt; √ √ × 123456789#案例1：查询没有奖金的员工信息SELECT *FROM employeesWHERE commission_pct IS NULL;#案例2：查询有奖金的员工信息SELECT *FROM employeesWHERE commission_pct IS NOT NULL; 12345= 只能判断普通的内容IS 只能判断NULL值&lt;=&gt; 安全等于，既能判断普通内容，又能判断NULL值 1234567SELECT *FROM employeesWHERE salary &lt;=&gt; 10000;SELECT *FROM employeesWHERE commission_pct &lt;=&gt; NULL; 排序查询一、语法1234select 查询列表from 表where 筛选条件order by 排序列表 【asc&#125;desc】 二、特点1234561、asc ：升序，如果不写默认升序 desc：降序2、排序列表 支持 单个字段、多个字段、函数、表达式、别名3、order by的位置一般放在查询语句的最后（除limit语句之外） 三、示例1、按单个字段排序1234567891011#案例1：将员工编号&gt;120的员工信息进行工资的升序SELECT *FROM employeesORDER BY salary ;#案例1：将员工编号&gt;120的员工信息进行工资的降序SELECT *FROM employeesWHERE employee_id&gt;120ORDER BY salary DESC; 2、按表达式排序123456#案例1：对有奖金的员工，按年薪降序SELECT *,salary*12*(1+IFNULL(commission_pct,0)) 年薪FROM employeesWHERE commission_pct IS NOT NULLORDER BY salary*12*(1+IFNULL(commission_pct,0)) DESC; 3、按别名排序123456#案例1：对有奖金的员工，按年薪降序SELECT *,salary*12*(1+IFNULL(commission_pct,0)) 年薪FROM employeesORDER BY 年薪 DESC; 4、按函数的结果排序1234#案例1：按姓名的字数长度进行升序SELECT last_nameFROM employeesORDER BY LENGTH(last_name); 5、按多个字段排序1234#案例1：查询员工的姓名、工资、部门编号，先按工资升序，再按部门编号降序SELECT last_name,salary,department_idFROM employeesORDER BY salary ASC,department_id DESC; 6、补充选学：按列数排序12345SELECT * FROM employeesORDER BY 2 DESC;SELECT * FROM employeesORDER BY first_name; 常见函数一、字符函数 方法 描述 concat(str1,str2) 拼接 substr(str,pos) 截取从 pos 开始的所有字符，起索引从 1 开始 substr(str,pos,len) 截取 len 个从 pos 开始的字符，起始索引从 1 开始 Length(str) 获取字节个数 upper(str) 变大写 lower(str) 变小写 trim(【substr from】str) 去前后之后指定的字符，默认是去空格 left(str,len) 从左边截取指定 len 个数的字符 right(str,len) 从右边截指定 Len 个数的字符 lpad(str,substr,len) 左填充 rpad(str,substr,len) 右填充 strcmp(str1,str2) 比较两个字符的大小 instr(str,substr) 获取 substr 在 str 中的第一次出现的索引 示例： CONCAT 拼接字符 12SELECT CONCAT(&#x27;hello&#x27;, first_name,last_name) 备注FROM employees; LENGTH 获取字节长度 1SELECT LENGTH(&#x27;hello&#x27;); CHAR_LENGTH 获取字符个数 1SELECT CHAR_LENGTH(&#x27;hell,xiaoming&#x27;); SUBSTRING 截取子串 12SELECT SUBSTR(&#x27;hellowoorld&#x27;,1,3);SELECT SUBSTR(&#x27;hellowoorld&#x27;,2); INSTR 获取字符第一次出现的索引 12SELECT INSTR(&#x27;三打白骨精aaa白骨精bb白骨精&#x27;,&#x27;白骨精&#x27;);SELECT INSTR(&#x27;三打白骨精aaa白骨精bb白骨精&#x27;,&#x27;白骨精&#x27;); TRIM 去前后指定的字符，默认是去空格 1SELECT TRIM(&#x27; xiaoming &#x27;) AS a; LPAD/RPAD 左填充/右填充 1SELECT LPAD(&#x27;小明&#x27;,10,&#x27;a&#x27;); UPPER/LOWER 变大写/变小写 案例：查询员工表的姓名，要求格式：姓首字符大写，其他字符小写，名所有字符大写，且姓和名之间用_分割，最后起别名“OUTPUT” 12SELECT CONCAT(UPPER(SUBSTR(first_name,1,1)),LOWER(SUBSTR(first_name,2)),&#x27;_&#x27;,UPPER(last_name)) AS &#x27;OUTPUT&#x27;FROM employees; STRCMP 比较两个字符大小 12SELECT STRCMP(&#x27;aec&#x27;,&#x27;aec&#x27;);SELECT STRCMP(&#x27;adc&#x27;,&#x27;cfg&#x27;); LEFT/RIGHT 截取子串 12SELECT LEFT(&#x27;鸠摩智&#x27;,1);SELECT RIGHT(&#x27;鸠摩智&#x27;,1); 二、数字函数 方法 描述 ceil(x) 向上取整 floor(X) 向下取整 round(x,d) 四舍五入 mod(x,y) 取模/取余 truncate(x,d) 截取，保留小数点后 d 位 abs(x) 求绝对值 示例： ABS 绝对值 1SELECT ABS(-2.4); CEIL 向上取整 返回&gt;=该参数的最小整数 123SELECT CEIL(-1.77999);SELECT CEIL(-1.09);SELECT CEIL(0.09); FLOOR 向下取整，返回&lt;=该参数的最大整数 12SELECT FLOOR(-1.09);SELECT FLOOR(0.09); ROUND 四舍五入 12SELECT ROUND(4,555);SELECT ROUND(1.8712345,2); TRUNCATE 截断 1SELECT TRUNCATE(1.8776787,2); MOD 取余 123SELECT MOD(10,3); // 1SELECT MOD(-10,3); // -1SELECT MOD(10,-3); // 1 三、日期函数 方法 描述 now() 获取当前日趋–时间 curtime() 只有时间 curdate() 只有日期 date_format(date,格式) 格式日期为字符 str_to_date(str，格式) 将字符转换为日期 datediff(date1,date2) 获取两个日期之间的天差数 year(date) 获取年 month(date) 获取月 NOW 1SELECT NOW(); CURDATE 1SELECT CURDATE(); DATEDIFF 1SELECT DATEDIFF(&#x27;1998-7-16&#x27;,&#x27;2019-7-13&#x27;); DATE_FORMAT 12SELECT DATE_FORMAT(&#x27;1998-7-19&#x27;,&#x27;%Y年%m月%d日 %H小时%i分钟%s秒&#x27;) 出生日期SELECT DATE_FORMAT(hiredate,&#x27;%Y年%M月%d日 %H小时%i分钟%s秒&#x27;)入职日期 STR_TO_DATE 按指定格式解析字符串为日期类型 12SELECT * FROM employeesWHERE hiredate&lt;STR_TO_DATE(&#x27;3/15 1998&#x27;,&#x27;%m/%d %Y&#x27;); 四、流程控制语句 ① if(条件，表达式 1, 表达式 2)：如果条件成立，返回表达式 1，否则返回表达式 2 ② case 表达式 when 值 1 then 结果 1 when 值 2 then 结果 2 …. else 结果 n end ③ case when 条件 1 then 结果 1 when 条件 2 then 结果 2 … else 结果 n end 示例： IF 函数 1SELECT IF(100&gt;9,&#x27;好&#x27;,&#x27;坏&#x27;); 需求：如果有奖金，则显示最终奖金，如果没有，则显示 0 12SELECT IF(commission_pct IS NULL,0,salary*12*commission_pct) 奖金FROM employees; CASE 函数 案例：部门编号是 30，工资显示为 2 倍部门编号是 50，工资显示为 3 倍部门编号是 60，工资显示为 4 倍否则不变显示 部门编号，新工资，旧工资 12345678SELECT department_id,salary,CASE department_idWHEN 30 THEN salary*2WHEN 50 THEN salary*3WHEN 60 THEN salary*4ELSE salaryEND newsalaryFROM employees; 案例：如果工资&gt;20000,显示级别 A工资&gt;15000,显示级别 B工资&gt;10000,显示级别 C否则，显示 D 12345678SELECT salary,CASEWHEN salary&gt;20000 THEN &#x27;A&#x27;WHEN salary&gt;15000 THEN &#x27;B&#x27;WHEN salary&gt;10000 THEN &#x27;C&#x27;ELSE &#x27;D&#x27;END AS &#x27;等级&#x27;FROM employees 分组函数 方法 描述 sum 求和 avg 求平均数 max 求最大值 min 求最小值 count 计算非空字段值的个数 示例： #案例 1 ：查询员工信息表中，所有员工的工资和、工资平均值、最低工资、最高工资、有工资的个数。 12SELECT SUM(salary),AVG(salary),MIN(salary),MAX(salary),COUNT(salary)FROM employees 分组查询一、语法 select 分组函数，分组的字段 from 表名 where 分组前的筛选条件 grounp by 分组列表 having 分组后的筛选 order by 排序列表 二、特点​ ① 分组列表可以是单个字段、多个字段 ​ ② 筛选条件分为两类 筛选的基表 使用的关键字 位置 分组前筛选 原始表 where group by 前面 分组后筛选 分组后的结果集 having group by 后面 三、执行顺序​ ① from 子句 ​ ② where 子句 ​ ③ group by 子句 ​ ④ having 子句 ​ ⑤ select 子句 ​ ⑥order by 子句 示例： ​ 1. 查询每个工种的员工平均工资 123SELECT AVG(salary),job_idFROM employeesGROUP BY job_id; 查询哪个部门的员工个数&gt;5 1234SELECT COUNT(*) 员工个数,department_idFROM employeesGROUP BY department_idHAVING COUNT(*)&gt;5; 每个工种有奖金的员工的最高工资&gt;12000 的工种编号和最高工资 12345SELECT job_id,MAX(salary)FROM employeesWHERE commission_pct IS NOT NULLGROUP BY job_idHAVING MAX(salary)&gt;12000; 查询没有奖金的员工的最高工资&gt;6000 的工种编号和最高工资,按最高工资升序 123456SELECT MAX(salary) 最高工资, job_idFROM employeesWHERE commission_pct IS NULLGROUP BY job_idHAVING MAX(salary)&gt;6000ORDER BY MAX(salary) ASC; 查询每个工种每个部门的最低工资,并按最低工资降序 (工种和部门都一样，才是一组) 123SELECT MIN(salary) 最低工资,job_id,department_idFROM employeesGROUP BY job_id,department_id 连接查询说明：当查询中涉及到了多个字段，则需要通过多表连接 笛卡尔乘积： ​ 出现原因：没有有效的连接条件 ​ 解决办法：添加有效的连接条件 一、SQL92 语法语法： select 查询列表 ① from 表 1 别名， 表 2 别名 ② where 连接条件 ③ and 筛选条件 ④ group by 分组列表 ⑤ having 分组后的筛选 ⑥ order by 排序列表 ⑦ 执行顺序：② ③ ④ ⑤ ⑥ ① ⑦ 1、等值连接语法： select 查询列表 from 表 1 别名， 表 2 别名 where 表 1.key= 表 2.key 【and 筛选条件】 【group by 分组字段】 【having 分组后的筛选】 【order by 排序字段】 代码示例： 等值连接：查询女神名和对应的男神名 123SELECT NAME ,boyNameFROM boys,beautyWHERE beauty.boyfriend_id = boys.id; 查询有奖金的员工名、部门名 1234SELECT last_name , department_name,commission_pctFROM employees e , departments dWHERE e.`department_id` = d.`department_id`AND e.`commission_pct` IS NOT NULL; 查询有奖金的每个部门的部门名和部门的领导编号和该部门的最低工资 12345SELECT department_name, d.`manager_id`,MIN(salary)FROM departments d,employees eWHERE d.`department_id` = e.`department_id`AND commission_pct IS NOT NULLGROUP BY department_name,d.`department_id`; 查询每个工种的工种名和员工的个数，并且按员工个数降序 12345SELECT job_title , COUNT(*)FROM employees e, jobs jWHERE e.`job_id`=j.`job_id`GROUP BY job_titleORDER BY COUNT(*) DESC 三表连接: 查询员工名、部门名和所在的城市 1234567SELECT last_name,department_name,cityFROM employees e,departments d,locations lWHERE e.`department_id`=d.`department_id`AND d.`location_id`=l.`location_id`AND city LIKE &#x27;s%&#x27;ORDER BY department_name DESC; 2、非等值连接语法： select 查询列表 from 表 1 别名,表 2 别名 where 非等值的连接条件 【and 筛选条件】 【group by 分组字段】 【having 分组后的筛选】 【order by 排序字段】 3、自连接语法： select 查询列表 from 表 别名 1,表 别名 2 where 等值的连接条件 【and 筛选条件】 【group by 分组字段】 【having 分组后的筛选】 【order by 排序字段】 代码示例： 自连接: 查询 员工名和上级的名称 123SELECT e.employee_id,e.last_name,m.employee_id,m.last_nameFROM employees e,employees mWHERE e.`manager_id`=m.`employee_id`; 二、SQL99 语法1、内连接语法： select 查询列表 ① from 表 1 别名 ② 【inner】 join 表 2 on 连接条件 ③ 【inner】 join 表 3 on 连接条件 ③ where 筛选条件 ④ group by 分组列表 ⑤ having 分组后的筛选 ⑥ order by 排序列表 ⑦ 执行顺序： ② ③ ④ ⑤ ⑥ ① ⑦ 特点： ​ ① 表的顺序可以调换 ​ ② 内连接的结果=多表的交集 ​ ③ n 表连接至少需要 n-1 个连接条件 分类： 等值连接 非等值连接 自连接 代码示例: 查询员工名和部门名 1234SELECT last_name,department_nameFROM departments dJOIN employees eON e.`department_id`=d.department_id; 添加筛选条件: 查询部门编号&gt;100 的部门名和所在的城市名 12345SELECT department_name,cityFROM departments dJOIN locations lON d.`location_id` = l.`location_id`WHERE d.`department_id`&gt;100; 添加分组+筛选+排序: 查询部门中员工个数&gt;10 的部门名，并按员工个数降序 1234567SELECT department_name,COUNT(*) 员工个数FROM employees eJOIN departments dON e.`department_id` = d.`department_id`GROUP BY d.`department_id`HAVING 员工个数&gt;10ORDER BY 员工个数 DESC; 非等值连接: 查询部门编号在 10-90 之间的员工的工资级别，并按级别进行分组 123456SELECT COUNT(*) 个数,gradeFROM employees eJOIN sal_grade gON e.`salary` BETWEEN g.`min_salary`AND g.`max_salary`WHERE e.`department_id` BETWEEN 10 AND 90GROUP BY g.`grade` 自连接: 查询员工名和对应的领导名 1234SELECT e.`last_name`, m.last_nameFROM employees eJOIN employees mON e.`manager_id`=m.employee_id; 2、外连接语法： select 查询列表 from 表 1 别名 left | right| full 【outer】 join 表 2 别名 on 连接条件 where 筛选条件 group by 分组后的筛选 order by 排序列表 特点： ​ ① 查询的结果 = 主表的所有的行，如果从表和它比配的将显示匹配行，如果从表没有匹配的则显示 null ​ ② left join 左边的就是主表，right join 右边的就是主表， full jion 两边都是主表 ​ ③ 一般用于查询除了交集部分的剩余的不匹配的行 代码示例： 查询所有女神记录，以及对应的男神名,如果没有对应的男神，则显示为 null。 左连接 123SELECT b.*,bo.*FROM beauty bLEFT JOIN boys bo ON b.`boyfriend_id` = bo.`id`; 右连接： 123SELECT b.*,bo.*FROM boys boRIGHT JOIN beauty b ON b.`boyfriend_id` = bo.`id`; 子查询一、含义 嵌套在其他语句内部的 select 语句称为子查询或内查询 外面的语句可以是 insert、update、select 等，一般 select 作为外面的语句较多 外面如果为 select 语句，则此语句称为外查询或主查询 二、分类按出现位置 select 后面 ​ 仅仅支持标量子查询 from 后面 ​ 表子查询 where 或 having 后面 ​ 标量子查询 ​ 列子查询 ​ 行子查询 ​ 表子查询 按结果集的行列 标量子查询(单行子查询)：结果集为一行一列 列子查询(多行子查询):结果集为多行一列 行子查询：结果集为多行多列 表子查询：结果集为多行多列 代码示例： 查询最低工资大于 50 号部门最低工资的部门 id 和其最低工资 12345678SELECT department_id, MIN(salary)FROM employeesGROUP BY department_idHAVING MIN(salary) &gt; ( SELECT MIN(salary) FROM employees WHERE department_id = 50 ); 返回 job_id 与 141 号员工相同，salary 比 143 号员工多的员工姓名，job_id 和工资 1234567891011SELECT last_name,job_id,salaryFROM employeesWHERE job_id =( SELECT job_id FROM employees WHERE employee_id = 141) AND salary&gt;( SELECT salary FROM employees WHERE employee_id = 143); 多行子查询:返回 location_id 是 1400 或 1700 的部门中的所有员工姓名 12345678SELECT last_nameFROM employeesWHERE department_id IN( # distinct 去重 SELECT distinct department_id FROM departments WHERE location_id IN(1400,1700) ); 放在 select 后面: 查询部门编号是 50 的员工个数 12345SELECT ( SELECT COUNT(*) FROM employees WHERE department_id = 50) 个数; 放在 from 后面: 查询每个部门的平均工资的工资级别 123456789SELECT dep_ag.department_id,dep_ag.ag,g.gradeFROM sal_grade gJOIN ( SELECT AVG(salary) ag,department_id FROM employees GROUP BY department_id) dep_ag ON dep_ag.ag BETWEEN g.min_salary AND g.max_salary; 放在 exists 后面 12345SELECT EXISTS( SELECT * FROM employees WHERE last_name=&#x27;Abel&#x27;) 有无Able; 分页查询一、应用场景 当要查询的条目数太多，一页显示不全 二、语法 select 查询列表 from 表 limit【offset】size 注意： offset 代表的是起始条目的索引，默认开始从 0 开始 size 代表的是条目数 公式： 假如要显示的页数为 page,每一页的条目数为 size select 查询列表 from 表 limit(page - 1)* size, size 代码示例： 查询员工信息表的前 5 条 1SELECT * FROM employees LIMIT 0,5; 查询年薪最高的前 10 名 1234SELECT last_name, salary,salary*12*(1+IFNULL(commission_pct,0)) 年薪FROM employeesORDER BY 年薪 DESCLIMIT 0,10 查询有奖金的，且工资较高的第 11 名到第 20 名 12345SELECT *FROM employeesWHERE commission_pct IS NOT NULLORDER BY salary DESCLIMIT 10,10; 联合查询一、含义​ union: 合并、联合，将多次查询的结果合并成为一个点结果 二、语法 查询语句 1 ​ union【all】 查询语句 2 ​ union【all】 ….. 三、意义 将一条比较复杂的查询语句拆分成为多条语句 适用于查询多个表的时候，查询的列表是一致 四、特点 要求多查询列数必须一致 要求多条查询语句的查询的各列类型、顺序最好一致 union 去重，union all 包含重复项 代码示例： 查询所有国家的年龄&gt;20 岁的用户信息 12SELECT * FROM usa WHERE uage &gt; 20 UNIONSELECT * FROM chinese WHERE age &gt;20 查询所有国家的用户姓名和年龄 123SELECT uname,uage FROM usaUNIONSELECT age,&#x27;name&#x27; FROM chinese union 自动去重/union all 可以支持重复项 1234567SELECT 1,&#x27;小明&#x27;UNION ALLSELECT 1,&#x27;小明&#x27;UNION ALLSELECT 1,&#x27;小明&#x27;UNION ALLSELECT 1,&#x27;小明&#x27; ; DDL 语言库的管理 ① 创建库 create database 【if not exists】库名 【characster set 字符集名】 ② 修改表 alter database 库名 character set 字符集名； ③ 删除表 drop database 【if exists】 库名； 代码示例： 创建数据库 12CREATE DATABASE stuDB;CREATE DATABASE IF NOT EXISTS stuDB; 删除数据库 12DROP DATABASE stuDB;DROP DATABASE IF EXISTS stuDB; 表的管理 ① 创建表 create table【if not exists】表名（ ​ 字段名 字段类型【约束】， ​ 字段名 字段类型【约束】， ​ 字段名 字段类型【约束】， ​ …… ） ② 修改表 1.添加列 alter table 表名 add conlumu 列名 类型【firat|after】 2.修改列的类型或约束 alter table 表名 modify column 列名 新类型【新约束】 3.修改列名 alter table 表名 change column 旧列名 新列名 类型 4.删除列 alter table 表名 drop column 列名 5.修改表名 alter table 表名 raname【to】 新表名 ③ 删除表 drop table【if exists】 表名 ④ 复制表 ① 复制表的结构 creato table 表名 like 旧表 ② 复制表的结构+数据 create table 表名 select 查询列表 from 旧表【where 筛选】 代码示例： 没有添加约束 12345678CREATE TABLE IF NOT EXISTS stuinfo( stuid INT , stuname VARCHAR(20), stugender CHAR(1), email VARCHAR(20), borndate DATETIME); 添加约束 12345678910CREATE TABLE IF NOT EXISTS stuinfo( stuid INT PRIMARY KEY,#添加了主键约束 stuname VARCHAR(20) UNIQUE NOT NULL,#添加了唯一约束+非空 stugender CHAR(1) DEFAULT &#x27;男&#x27;,#添加了默认约束 email VARCHAR(20) NOT NULL, age INT CHECK( age BETWEEN 0 AND 100),#添加了检查约束，mysql不支持 majorid INT, CONSTRAINT fk_stuinfo_major FOREIGN KEY (majorid) REFERENCES major(id)#添加了外键约束); 修改表 12345678910111213141516171819202122#1.修改表名ALTER TABLE stuinfo RENAME TO students;#2.添加字段ALTER TABLE students ADD COLUMN borndate TIMESTAMP NOT NULL;DESC students;#3.修改字段名ALTER TABLE students CHANGE COLUMN borndate birthday DATETIME NULL;#4.修改字段类型ALTER TABLE students MODIFY COLUMN birthday TIMESTAMP ;#5.删除字段ALTER TABLE students DROP COLUMN birthday;DESC students; 删除表 1DROP TABLE IF EXISTS students; 复制表 1234567891011121314#仅仅复制表的结构CREATE TABLE newTable2 LIKE major;#复制表的结构+数据CREATE TABLE newTable3 SELECT * FROM girls.`beauty`;#案例：复制employees表中的last_name,department_id,salary字段到新表 emp表，但不复制数据CREATE TABLE empSELECT lat_name,department_id,salaryFROM myemployees.`employees`WHERE 1=2; 数据类型一、数值型1、整型 tinyint 、 sallint、mediumint、int/integer、bigint 1 2 3 4 8 特点： ① 都可以设置无符号和有符号，默认通过 unsigned 设置无符号 ② 如果超出范围，会报 out or range 异常，插入临界值 ③ 长度可以不指定，默认会有一个长度，长度代表显示的最大宽度，如果不够则左边用 0 填充，但需要搭配 zerofill，并且默认变为无符号整型。 2、浮点型 定点数：decimal(M,D) 浮点数： ​ float(M,D) 4 ​ double(M,D) 8 特点： ① M 代表整数+ 小数部位的个数，D 代表小数整位 ② 如果超出范围，则报 out or range 异常，并且插入临界值 ③ M 和 D 都可以省略，但对于定点数，M 默认为 10， D 默认为 0 ④ 如果精度要较高，则优先考虑使用定点数 二、字符型 char 、varchar、binary、enum、set、text、blob char: 固定长度的字符，写法为 char(M),最大长度不能超过 M，其中 M 可以省略，默认为 1 varchar: 可变长度的字符，写法为 varchar(M),最大长度不能 M，不可省略 M 三、日期型 year 年 date 日期 time 时间 datetime 日期时间 8 timestamp 日期+时间 4 比较容易受时区、语法模式、版本的影响，更能反映当前时区的真实时间 常见的约束一、常见的约束 约束 描述 NOT NUll 非空，该字段的值必填 UnIQUE 唯一，该字段的值不可重复 DEFAULT 默认，该字段的值不用手动插入有默认值 CHECK 检查，mysql 不支持 PRIMARY KEY 主键，该字段的值不可重复并且非空 unique+not null FPREIGN KEY 外键，该字段的值引用了另外的标的字段 主键和唯一 1.区别： ​ ① 一个表至多有一个主键，但可以有多个唯一 ​ ② 主键不允许为空，唯一可以为空 2.相同点： ​ 都具有唯一性 ​ 都支持组合键，但不推荐 外键： ① 用于限制两个表的关系，从表的字段值引用了主表的某个字段值 ② 外键列和主表的被引用列要求类型一致，意义一样，名称无要求 ③ 主表的被引用列要求是一个 key(一般就是主键) ④ 插入数据，先插入主表 ​ 删除数据，先删除从表 可以通过以下两种方式来删除主表的记录 代码示例： ​ 方式一：级联删除 1ALTER TABLE stuinfo ADD CONSTRAINT fk_stu_major FOREIGN KEY(majorid) REFERENCES major(id) ON DELETE CASCADE; ​ 方式二：级联置空 1ALTER TABLE stuinfo ADD CONSTRAINT fk_stu_major FOREIGN KEY(majorid) REFERENCES major(id) ON DELETE SET NULL; 二、创建表的添加约束 create table 表名（ ​ 字段名 字段类型 not null ,#非空 ​ 字段名 字段类型 primary key,#主键 ​ 字段名 字段类型 unique,#唯一 ​ 字段名 字段类型 default 值， #默认 ​ constraint 约束名 foreign key(字段名) references 主表(被引用列 1) ） 注意： 支持类型 可以起约束名 列级约束 除了外键 不可以 表级约束 除了非空和默认 可以，但对主键无效 列级约束可以在一个字段上追加多个，中间用空格隔开，没有顺序要求 三、修改表时添加或删除约束 1.非空 ​ 添加非空 ​ alter table 表名 modify column 字段名 字段类型 not null; ​ 删除非空 ​ alter table 表名 modify column 字段名 字段类型; 2.默认 ​ 添加默认 ​ alter table 表名 modify columu 字段名 字段类型 default 值; ​ 删除默认 ​ alter table 表名 modify column 字段名 字段类型; 3.主键 ​ 添加主键 ​ alter table 表名 add【 constraint 约束名】 primary key(字段名)； ​ 删除主键 ​ alter table 表名 add drop primary key; 4.唯一 ​ 添加唯一 ​ alter table 表名 add【constraint 约束名】 unique(字段名); ​ 删除唯一 ​ alter table 表名 drop index 索引名; 5.外键 ​ 添加外键 ​ alter table 表名 add【constraint 约束名】 foreign key(字段名) references 主表(被引用列) ​ 删除外键 ​ alter table 表名 drop foreign key 约束名; 四、自增长列 特定： ​ 1.不用手动插入值，可以自动提供序列值，默认从 1 开始，步长为 1 ​ auto_increment_increment ​ 如果要更改起始值：手动插入值 ​ 如果要更改步长：更改系统变量 ​ set auto_increment_increment=值 ​ 2.一个表至多有一个自增长列 ​ 3.自增长列只能支持数值型 ​ 4.自增长列必须为一个 key 创建表时设置自增长列 ​ create table 表( ​ 字段名 字段类型 约束 auto_increment ​ ) 修改表时设置自增长列 ​ alter table 表 modify column colum 字段名 字段类型 约束 auto_increment 删除自增长列 ​ alter table 表 modify column 字段名 字段类型 约束 DML 语言插入1、方式一 语法： insert into 表名(字段名,…) values(值,…); 特点： ​ 1、要求值的类型和字段的类型要一致或兼容 ​ 2、字段的个数和顺序不一定与原始表中的字段个数和顺序一致 但必须保证值和字段一一对应 ​ 3、假如表中有可以为 null 的字段，注意可以通过以下两种方式插入 null 值 ​ ① 字段和值都省略 ② 字段写上，值使用 null ​ 4、字段和值的个数必须一致 ​ 5、字段名可以省略，默认所有列 2、方式二 语法： insert into 表名 set 字段=值,字段=值,…; 两种方式 的区别： ​ 1.方式一支持一次插入多行，语法如下： insert into 表名【(字段名,..)】 values(值，..),(值，…),…; ​ 2.方式一支持子查询，语法如下： insert into 表名 查询语句; 修改1、修改单表的记录 语法：update 表名 set 字段=值，字段=值【where 筛选条件】 2、修改多表的记录【补充】 语法： update 表 1 别名 left|right|inner join 表 2 别名 on 连接条件 set 字段=值，字段=值 【where 筛选条件】 删除1、使用 delete 删除单表的记录 ​ 语法：delete 别名 1，别名 2 from 表 1 别名 ​ inner| left | right join 表 2 别名 on 连接条件 ​ 【where 筛选条件】 2、 使用 truncate 语法：truncate table 表名 3、两种方式的区别 #【面试题】delete 和 truncate 的区别 1.delete 可以添加 WHERE 条件 ​ TRUNCATE 不能添加 WHERE 条件，一次性清除所有数据 2.truncate 的效率较高 3.如果删除带自增长列的表， ​ 使用 DELETE 删除后，重新插入数据，记录从断点处开始 ​ 使用 TRUNCATE 删除后，重新插入数据，记录从 1 开始 ​ SELECT * FROM gradeinfo; ​ TRUNCATE TABLE gradeinfo; ​ INSERT INTO gradeinfo(gradename)VALUES(‘一年级’),(‘2 年级’),(‘3 年级’); 4.delete 删除数据，会返回受影响的行数 ​ TRUNCATE 删除数据，不返回受影响的行数 5.delete 删除数据，可以支持事务回滚 ​ TRUNCATE 删除数据，不支持事务回滚 代码示例： 添加 1INSERT INTO stuinfo values(1,&#x27;吴倩&#x27;,&#x27;女&#x27;,&#x27;wuqian@qq.com&#x27;,&#x27;2001.1.2&#x27;); 修改(修改年龄&lt;20 的专业编号为 3 号，且邮箱更改为 &#x78;&#120;&#x40;&#113;&#x71;&#x2e;&#99;&#111;&#109;) 12UPDATE stuinfo SET majorid = 3,email = &#x27;xx@qq.com&#x27;WHERE age&lt;20; 删除 12345#案例1：删除姓李所有信息DELETE FROM stuinfoWHERE stuname LIKE &#x27;李%&#x27;；#案例2：删除表中所有数据TRUNCATE TABLE stuinfo; 事务1、含义 事务:一条或多条 sql 语句组成一个执行单位，一组 sql 语句要么都执行要么不执行 2、特点 A 原子性：一个事务是不可再分割的整体，要么都执行要么都不执行 C 一致性：一个事务可以使数据从一个状态切换到另一个一致的状态 I 隔离性： 一个事务不受其他事务的干扰，多个事务相互隔离的 D 持久性：一个事务一旦提交了，则永久的持久化到本地 3、事务的使用步骤 隐式（自动）事务：没有明显的开始的结束，本身就是一条事务可以自动提交，比如 insert、update、delete 显式事务：具有明显的开启和结束。 使用显式事务： ① 开启事务 12set autocommit = 0;start transaction：#可以省略 设置回滚点： 提交：commit: 回滚：rollback; 回滚到指定的地方；rollback to 回滚点名： 4、并发事务 脏读：一个事务读取其他事务还没有提交的数据，读到的是其他事务“更新”的数据 不可重复读：一个事务多次读取，结果不一样 幻读：一个事务读取了其他事务还没有提交的数据，只是读到的是 其他事务”插入”的数据 隔离级别: 脏读 不可重复读 幻读 read uncommitted:读未提交 × × × read committed:读已提交 √ × × repeatable read：可重复读 √ √ × serializable：串行化 √ √ √","categories":[{"name":"数据库","slug":"数据库","permalink":"http://blog.oy6090.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"java","slug":"java","permalink":"http://blog.oy6090.top/tags/java/"},{"name":"MySQL","slug":"MySQL","permalink":"http://blog.oy6090.top/tags/MySQL/"}]},{"title":"java项目：员工管理系统","slug":"Java项目：员工管理系统","date":"2020-08-02T16:00:00.000Z","updated":"2021-01-22T03:53:06.715Z","comments":true,"path":"posts/33872.html","link":"","permalink":"http://blog.oy6090.top/posts/33872.html","excerpt":"","text":"项目的具体源码，已经打包放在博客末尾 Java 项目：员工管理系统搭建环境:​ Idea 集成开发工具 技术点： 数组 面向对象 继承 多态 接口 异常的处理 项目结构： 代码示例：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119public class TeaView &#123; private NameLIstService lIstService = new NameLIstService(); private TeamService teamService = new TeamService(); public void enterMainMenu()&#123; boolean loopFlag = true; char key = 0; while(loopFlag)&#123; if(! (key == &#x27;1&#x27;))&#123; listAllEmployees(); &#125; System.out.print(&quot;1-团队列表 2-添加团队成员 3-删除团队成员 4-退出 请选择(1-4)：&quot;); key = TSUtility.readMenuSelection(); System.out.println(); switch (key)&#123; case &#x27;1&#x27;: getTeam(); break; case &#x27;2&#x27;: addMenber(); break; case &#x27;3&#x27;: deleMember(); break; case &#x27;4&#x27;: System.out.print(&quot;确认是否退出(Y/N)：&quot;); char yn = TSUtility.readConfirmSelection(); if(yn == &#x27;Y&#x27;)&#123; loopFlag = false; break; &#125; &#125; &#125; &#125; /** * 以表格形式列出公司所有的员工 */ public void listAllEmployees()&#123; System.out.println(&quot;\\n--------------------开发团队调度软件---------------------\\n&quot;); Employee[] employees = lIstService.getAllEmployees(); if(employees.length == 0)&#123; System.out.println(&quot;没有客户资料&quot;); &#125;else&#123; System.out.println(&quot;ID\\t姓名\\t\\t年龄\\t\\t工资\\t\\t职位\\t\\t状态\\t\\t奖金\\t\\t股票\\t\\t领用设备&quot;); &#125; for(Employee e : employees)&#123; System.out.println(&quot; &quot;+ e); &#125; System.out.println(&quot;-------------------------------------------------------------------------------&quot;); &#125; /** * 显示团队成员列表操作 */ public void getTeam()&#123; System.out.println(&quot;\\n--------------------团队成员列表---------------------\\n&quot;); Programmer[] team = teamService.getTeam(); if(team.length == 0)&#123; System.out.println(&quot;开发团队目前没有成员！&quot;); &#125;else&#123; System.out.println(&quot;TID/ID\\t姓名\\t\\t年龄\\t\\t工资\\t\\t职位\\t\\t奖金\\t\\t股票&quot;); &#125; for(Programmer p : team)&#123; System.out.println(&quot; &quot; + p.getDetailsForTeam()); &#125; System.out.println(&quot;-----------------------------------------------------&quot;); &#125; /** * 实现添加成员的操作 */ public void addMenber() &#123; System.out.println(&quot;---------------------添加成员---------------------&quot;); System.out.print(&quot;请输入要添加的员工ID: &quot;); int id = TSUtility.readInt(); try &#123; Employee e = lIstService.getEmployee(id); teamService.addMenber(e); System.out.println(&quot;添加成功&quot;); &#125; catch (TeamException e) &#123; System.out.println(&quot;添加失败，原因：&quot; + e.getMessage()); &#125; // 按回车键继续 TSUtility.readReturn(); &#125; /** * 实现删除成员操作 */ public void deleMember()&#123; System.out.println(&quot;---------------------删除成员---------------------&quot;); System.out.print(&quot;请输入要删除员工的TID：&quot;); int id = TSUtility.readInt(); System.out.println(&quot;确认是否删除(Y/N)：&quot;); char yn = TSUtility.readConfirmSelection(); if(yn ==&#x27;N&#x27;)&#123; return; &#125; try &#123; teamService.removeMember(id); System.out.println(&quot;删除成功&quot;); &#125; catch (TeamException e) &#123; System.out.println(&quot;删除失败，原因：&quot; + e.getMessage()); &#125; //按回车键继续 TSUtility.readReturn(); &#125; public static void main(String[] args)&#123; TeaView teaView = new TeaView(); teaView.enterMainMenu(); &#125;&#125; 提取码：kp6t 下载源码","categories":[{"name":"项目实战","slug":"项目实战","permalink":"http://blog.oy6090.top/categories/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/"}],"tags":[{"name":"java","slug":"java","permalink":"http://blog.oy6090.top/tags/java/"},{"name":"java项目","slug":"java项目","permalink":"http://blog.oy6090.top/tags/java%E9%A1%B9%E7%9B%AE/"}]},{"title":"SpringMVC基础（下篇）","slug":"SpringMVC基础知识（下篇）","date":"2020-08-02T16:00:00.000Z","updated":"2020-10-25T02:28:45.901Z","comments":true,"path":"posts/4019007238.html","link":"","permalink":"http://blog.oy6090.top/posts/4019007238.html","excerpt":"","text":"一、处理 JSON​ JSON 知识： JSON 有两种格式：① Json 对象：{key:value,key:value….}，②Json 数组:[value1, value2…] Json 对象解析方式： 对象.key; Json 数组的解析方式：for 循环遍历 java 对象转 Json： ① Bean 和 map —》Json 对象；② List —》 json 数组 1、 返回 JSON 加入 jar 包： 下载地址：https://repo1.maven.org/maven2/com/fasterxml/jackson/core/ 注意： 请根据自己的 Spring 版本下载最新的 jar，否则有肯能会报错。 报错异常可以参考我这篇博客：解决方案 SpringMVC 处理 json 四个条件 ​ ① 导入 jackson 的 jar ​ ② 在 springMVC 的配置文件中开启 MVC 驱动，&lt;mvc:annotation-driven /&gt; ​ ③ 在处理 ajax 请求的方法上加上注解**@ResponseBody** ​ ④ 将要转换为 json 且响应到客户端的数据，直接作为该方法的返回值返回 代码示例 【index.jsp】 123456789101112131415161718192021222324252627&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;$Title$&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;$&#123;pageContext.servletContext.contextPath&#125;/js/jquery-1.8.2.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; &gt; $(function () &#123; $(&#x27;#btn&#x27;).click(function () &#123; $.ajax(&#123; url:&quot;testJson&quot;, type:&quot;POST&quot;, dataType:&quot;json&quot;, success:function (msg) &#123; for(var i in msg)&#123; var emp = msg[i]; alert(&quot;id=&quot;+emp.id+&quot;,lastName=&quot;+emp.lastName+&quot;,departmentName=&quot;+emp.department.departmentName); &#125; &#125; &#125;); &#125;); &#125;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;a href=&quot;testJson&quot;&gt;测试JSON&lt;/a&gt; &lt;/body&gt;&lt;/html&gt; 【JsonControllerTest.json】**@ResponseBody : ** SpringMVC 对 JSON 的支持 1234567891011121314@Controllerpublic class JsonControllerTest &#123; @Autowired private EmployeeDao employeeDao; @RequestMapping(value = &quot;/testJson&quot;) @ResponseBody public Collection&lt;Employee&gt; testJson()&#123; Collection&lt;Employee&gt; emps = employeeDao.getAll(); return emps; &#125;&#125; 测试 2、 使用 AJAX【index.jsp】 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;html&gt; &lt;head&gt; &lt;title&gt;$Title$&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;$&#123;pageContext.servletContext.contextPath&#125;/css/index_like.css&quot; /&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;$&#123;pageContext.servletContext.contextPath&#125;/js/jquery-1.8.2.min.js&quot; &gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(function () &#123; $(&quot;#btn&quot;).click(function () &#123; $.ajax(&#123; url: &quot;testJson&quot;, type: &quot;POST&quot;, dataType: &quot;json&quot;, success: function (msg) &#123; /* [ &#123;&quot;id&quot;:1001,&quot;lastName&quot;:&quot;E-AA&quot;,&quot;email&quot;:&quot;aa@163.com&quot;,&quot;gender&quot;:1,&quot;department&quot;:&#123;&quot;id&quot;:101,&quot;departmentName&quot;:&quot;D-AA&quot;&#125;&#125;, &#123;&quot;id&quot;:1002,&quot;lastName&quot;:&quot;E-BB&quot;,&quot;email&quot;:&quot;bb@163.com&quot;,&quot;gender&quot;:1,&quot;department&quot;:&#123;&quot;id&quot;:102,&quot;departmentName&quot;:&quot;D-BB&quot;&#125;&#125;, &#123;&quot;id&quot;:1003,&quot;lastName&quot;:&quot;E-CC&quot;,&quot;email&quot;:&quot;cc@163.com&quot;,&quot;gender&quot;:0,&quot;department&quot;:&#123;&quot;id&quot;:103,&quot;departmentName&quot;:&quot;D-CC&quot;&#125;&#125;, &#123;&quot;id&quot;:1004,&quot;lastName&quot;:&quot;E-DD&quot;,&quot;email&quot;:&quot;dd@163.com&quot;,&quot;gender&quot;:0,&quot;department&quot;:&#123;&quot;id&quot;:104,&quot;departmentName&quot;:&quot;D-DD&quot;&#125;&#125;, &#123;&quot;id&quot;:1005,&quot;lastName&quot;:&quot;E-EE&quot;,&quot;email&quot;:&quot;ee@163.com&quot;,&quot;gender&quot;:1,&quot;department&quot;:&#123;&quot;id&quot;:105,&quot;departmentName&quot;:&quot;D-EE&quot;&#125;&#125; ] */ // 第一种实现方式 /*var tb = &quot;&lt;table&gt;&quot;; tb += &quot;&lt;tr&gt;&lt;th&gt;id&lt;/th&gt;&lt;th&gt;lastName&lt;/th&gt;&lt;th&gt;email&lt;/th&gt;&lt;th&gt;gender&lt;/th&gt;&lt;th&gt;departmentName&lt;/th&gt;&lt;/tr&gt;&quot; for(var i in msg)&#123; var emp = msg[i]; tb += &quot;&lt;tr&gt;&lt;td&gt;&quot;+emp.id+&quot;&lt;/td&gt;&lt;td&gt;&quot;+emp.lastName+&quot;&lt;/td&gt;&lt;td&gt;&quot;+emp.email+&quot;&lt;/td&gt;&lt;td&gt;&quot;+emp.gender+&quot;&lt;/td&gt;&lt;td&gt;&quot;+emp.department.departmentName+&quot;&lt;/td&gt;&lt;/tr&gt;&quot; &#125; tb += &quot;&lt;/table&gt;&quot; $(&#x27;body&#x27;).append(tb);*/ //第二种实现方式 $(&quot;body&quot;).append(&quot;&lt;table&gt;&lt;/table&gt;&quot;); $(&quot;table&quot;).append( &quot;&lt;tr&gt;&lt;th&gt;id&lt;/th&gt;&lt;th&gt;lastName&lt;/th&gt;&lt;th&gt;email&lt;/th&gt;&lt;th&gt;gender&lt;/th&gt;&lt;th&gt;departmentName&lt;/th&gt;&lt;/tr&gt;&quot; ); for (var i in msg) &#123; var emp = msg[i]; $(&quot;table&quot;).append( &quot;&lt;tr&gt;&lt;td&gt;&quot; + emp.id + &quot;&lt;/td&gt;&lt;td&gt;&quot; + emp.lastName + &quot;&lt;/td&gt;&lt;td&gt;&quot; + emp.email + &quot;&lt;/td&gt;&lt;td&gt;&quot; + emp.gender + &quot;&lt;/td&gt;&lt;td&gt;&quot; + emp.department.departmentName + &quot;&lt;/td&gt;&lt;/tr&gt;&quot; ); &#125; &#125;, &#125;); &#125;); &#125;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;a href=&quot;hello&quot;&gt;测试&lt;/a&gt; &lt;br /&gt; &lt;a href=&quot;testJson&quot;&gt;测试JSON&lt;/a&gt; &lt;br /&gt; &lt;input id=&quot;btn&quot; type=&quot;button&quot; value=&quot;测试ajax&quot; /&gt; &lt;/body&gt;&lt;/html&gt; 测试： 二、HttpMessageConverter 原理1、HttpMessageConverter&lt;T&gt;HttpMessageConverter&lt;T&gt; 是 Spring3.0 新添加的一个接口， 负责将请求信息转换为一个对象（类型为 T）， 将对象（类型为 T）输出为响应信息 2、HttpMessageConverter&lt;T&gt;接口定义的方法 Boolean canRead(Class&lt;?&gt; clazz,MediaType mediaType): 指定转换器可以读取的对象类型，即转 换 器 是 否 可 将 请 求 信 息 转 换 为 clazz 类 型 的 对 象 ， 同 时 指 定 支 持 MIME 类 型(text/html,applaiction/json 等) Boolean canWrite(Class&lt;?&gt; clazz,MediaType mediaType):指定转换器是否可将 clazz 类型的对象写到响应流中，响应流支持的媒体类型在 MediaType 中定义。 List&lt;MediaType&gt; getSupportMediaTypes()：该转换器支持的媒体类型。 T read(Class&lt;? extends T&gt; clazz,HttpInputMessage inputMessage)：将请求信息流转换为 T 类型的对象。 void write(T t,MediaType contnetType,HttpOutputMessgae outputMessage):将 T 类型的对象写到响应流中，同时指定相应的媒体类型为 contentType。 123456package org.springframework.http;import java.io.IOException;import java.io.InputStream;public interface HttpInputMessage extends HttpMessage &#123; InputStream getBody() throws IOException;&#125; 123456package org.springframework.http;import java.io.IOException;import java.io.OutputStream;public interface HttpOutputMessage extends HttpMessage &#123; OutputStream getBody() throws IOException;&#125; 3、HttpMessageConverter使用 HttpMessageConverter 将请求信息转化并绑定到处理方法的入参中或将响应结果转为对应类型的响应信息， Spring 提供了两种途径： 使用 @RequestBody / @ResponseBody 对处理方法进行标注 使用 HttpEntity&lt;T&gt; / ResponseEntity&lt;T&gt; 作为处理方法的入参或返回值 三、文件上传下载1、文件下载 代码示例 方式一：图片名字由服务进行绑定 ​ 【index.jsp】 123&lt;body&gt; &lt;a href=&quot;down&quot;&gt;下载图片&lt;/a&gt;&lt;/body&gt; ​ 【TestUploadAndDownController.java】 12345678910111213141516171819@RequestMapping(value = &quot;/down&quot;)public ResponseEntity&lt;byte[]&gt; down(HttpSession session) throws Exception &#123; // 获取下载文件的路径 String realPath = session.getServletContext().getRealPath(&quot;img&quot;); String finalPath = realPath + File.separator + &quot;2.jpg&quot;; InputStream is = new FileInputStream(finalPath); // available():获取输入流所读取的文件的最大字节数 byte[] bt = new byte[is.available()]; is.read(bt); // 设置请求头 HttpHeaders headers = new HttpHeaders(); headers.add(&quot;Content-Disposition&quot;,&quot;attachment;filename=zzz.jpg&quot;); // 设置响应状态 HttpStatus status = HttpStatus.OK; ResponseEntity&lt;byte[]&gt; entity = new ResponseEntity&lt;&gt;(bt, headers, status); return entity;&#125; 测试： 方式二： 图片有请求方式来获取 ​ 【index.jsp】 123&lt;body&gt; &lt;a href=&quot;down/1&quot;&gt;下载图片&lt;/a&gt;&lt;/body&gt; ​ 【TestUploadAndDownController.java】 12345678910111213141516171819@RequestMapping(value = &quot;/down/&#123;username&#125;&quot;) public ResponseEntity&lt;byte[]&gt; down(@PathVariable(&quot;username&quot;) String username, HttpSession session) throws Exception &#123; // 获取下载文件的路径 String realPath = session.getServletContext().getRealPath(&quot;img&quot;); String finalPath = realPath + File.separator + username+&quot;.jpg&quot;; InputStream is = new FileInputStream(finalPath); byte[] bt = new byte[is.available()]; is.read(bt); // 获取请求头 HttpHeaders headers = new HttpHeaders(); headers.add(&quot;Content-Disposition&quot;,&quot;attachment;filename=&quot;+username+&quot;.jpg&quot;); // 设置响应状态 HttpStatus status = HttpStatus.OK; ResponseEntity&lt;byte[]&gt; entity = new ResponseEntity&lt;&gt;(bt, headers, status); return entity;&#125; 测试： 2、文件上传 导入需要的 Jar 包 代码示例 【index.jsp】 12345&lt;form action=&quot;up&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; 头像：&lt;input type=&quot;file&quot; name=&quot;uploadFile&quot;/&gt; 描述：&lt;input type=&quot;text&quot; name=&quot;desc&quot;/&gt; &lt;input type=&quot;submit&quot; value=&quot;上传&quot;/&gt;&lt;/form&gt; ​ 【配置 spingmvc.xml】不配置上传则会报错 12345678910&lt;!-- 处理文件，将客户端上传的File文件，处理为MultipartFile 注意：文件解析器的bean中id必须设置为multipartResolver --&gt;&lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt; &lt;!-- 设置文件解析的编码，注意：一定要和页面的pageEncoding保持一致 --&gt; &lt;property name=&quot;defaultEncoding&quot; value=&quot;UTF-8&quot;&gt;&lt;/property&gt; &lt;!-- 设置最大上传文件大小 --&gt; &lt;property name=&quot;maxUploadSize&quot; value=&quot;88888888&quot;&gt;&lt;/property&gt;&lt;/bean&gt; 【TestUploadAndDownController.java】 方式一： 12345678910111213141516171819@RequestMapping(value = &quot;/up&quot; ,method = RequestMethod.POST) public String up (String desc, MultipartFile uploadFile, HttpSession session) throws IOException &#123; // 获取上传文件的名称 String filename = uploadFile.getOriginalFilename(); String path = session.getServletContext().getRealPath(&quot;phone&quot;) + File.separator + filename; // 获取输入流 InputStream is = uploadFile.getInputStream(); // 获取输出流 File file = new File(path); OutputStream fos = new FileOutputStream(file); byte[] bt = new byte[1024]; int len; while((len = is.read(bt)) != -1)&#123; fos.write(bt, 0, len); &#125; is.close(); fos.close(); return &quot;success&quot;; &#125; 注意：上传出现异常 类型 异常报告 消息 E:\\IDEA\\SpringMVC\\SpringMVC_demo3\\out\\artifacts\\SpringMVC_demo3_war_exploded\\phone\\1.jpg (系统找不到指定的路径。) java.io.FileNotFoundException: E:\\IDEA\\SpringMVC\\SpringMVC_demo3\\out\\artifacts\\SpringMVC_demo3_war_exploded\\phone\\1.jpg (系统找不到指定的路径。) 解决方法：（以为自己的为例子）E:\\IDEA\\SpringMVC\\SpringMVC_demo3\\out\\artifacts\\SpringMVC_demo3_war_exploded 这个目录下创建一个phone 文件就可解决问题 可以在代码中写入 System.out.prinln(path); 方便查看图片上传的位置 方式二： 12345678910@RequestMapping(value = &quot;/up&quot;,method = RequestMethod.POST)public String up (MultipartFile uploadFile, HttpSession session) throws IOException &#123; // 获取上传文件的名称 String filename = uploadFile.getOriginalFilename(); String finalFileName = UUID.randomUUID() + filename.substring(filename.lastIndexOf(&quot;.&quot;)); String path = session.getServletContext().getRealPath(&quot;phone&quot;) + File.separator + finalFileName; File file = new File(path); uploadFile.transferTo(file); return &quot;success&quot;;&#125; 3、多个文件上传【index.jsp】 123456&lt;form action=&quot;up&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; 头像：&lt;input type=&quot;file&quot; name=&quot;uploadFile&quot;/&gt; 头像1：&lt;input type=&quot;file&quot; name=&quot;uploadFile&quot;/&gt; 头像2：&lt;input type=&quot;file&quot; name=&quot;uploadFile&quot;/&gt; &lt;input type=&quot;submit&quot; value=&quot;上传&quot;/&gt;&lt;/form&gt; 【TestUploadAndDownController.java】 1234567891011121314@RequestMapping(value = &quot;/up&quot;,method = RequestMethod.POST)public String ups(MultipartFile[] uploadFile, HttpSession session) throws IOException &#123; for(MultipartFile uploadFiles : uploadFile)&#123; // 判断文件是否为空 if(! uploadFiles.isEmpty())&#123; String filename = uploadFiles.getOriginalFilename(); String finalFileName = UUID.randomUUID() + filename.substring(filename.lastIndexOf(&quot;.&quot;)); String path = session.getServletContext().getRealPath(&quot;phone&quot;) + File.separator + finalFileName; File file = new File(path); uploadFiles.transferTo(file); &#125; &#125; return &quot;success&quot;;&#125; 四、拦截器1、 自定义拦截器​ Spring MVC 也可以使用拦截器对请求进行拦截处理，用户可以自定义拦截器来实现特定的 功 能 ， 自 定 义 的 拦 截 器 可 以 实 现 HandlerInterceptor 接 口 ， 也 可 以 继 承 HandlerInterceptorAdapter 适配器类 。 **preHandle()**：这个方法在业务处理器处理请求之前被调用，在该方法中对用户请求 request 进行处理。如果程序员决定该拦截器对请求进行拦截处理后还要调用其他的拦截器，或者是业务处理器去进行处理，则返回 true；如果程序员决定不需要再调用其他的组件去处理请求，则返回 false。 postHandle()： 这个方法在业务处理器处理完请求后，但是 DispatcherServlet 向客户端返回响应前被调用，在该方法中对用户请求 request 进行处理。 afterCompletion()：这个方法在 DispatcherServlet 完全处理完请求后被调用，可以在该方法中进行一些资源清理的操作。 代码示例： 【spingmvc.xml】中配置拦截器（3 中方式） ①（推荐使用）： 1234&lt;mvc:interceptors&gt; &lt;!--默认拦截所有的请求--&gt; &lt;bean class=&quot;com.oy.online.springmvc.interceptor.FirstInterceptor&quot;&gt;&lt;/bean&gt;&lt;/mvc:interceptors&gt; ②： 1234&lt;mvc:interceptors&gt; &lt;!--此方式要求拦截器类上必须加注解@Component --&gt; &lt;ref bean=&quot;firstInterceptor&quot;&gt;&lt;/ref&gt;&lt;/mvc:interceptors&gt; ③： 12345678910&lt;mvc:interceptors&gt; &lt;!-- 设置自定义拦截方式 --&gt; &lt;mvc:interceptor&gt; &lt;bean class=&quot;com.oy.online.springmvc.interceptor.FirstInterceptor&quot;/&gt; &lt;!-- 拦截所有的请求，这个必须写在前面，也就是写在【不拦截】的上面 --&gt; &lt;mvc:mapping path=&quot;/**&quot; /&gt; &lt;!-- 但是排除下面这些，也就是不拦截请求 --&gt; &lt;mvc:exclude-mapping path=&quot;/login.html&quot; /&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; 【index.jsp】 123&lt;body&gt; &lt;a href=&quot;testInterceptor&quot;&gt;测试拦截器&lt;/a&gt;&lt;/body&gt; 【FirstInterceptor.java】 ​ preHandle(): 中的 return 值 true 表示不拦截放行，反之 false 拦截 1234567891011121314151617public class FirstInterceptor implements HandlerInterceptor &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; System.out.println(&quot;First:preHandle&quot;); return true; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println(&quot;First:postHandle&quot;); &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println(&quot;First:afterCompletion&quot;); &#125;&#125; 【TestInterceptorController.java】 12345678@Controllerpublic class TestInterceptorController &#123; @RequestMapping(value = &quot;/testInterceptor&quot;) public String testInterceptor()&#123; return &quot;success&quot;; &#125;&#125; 测试： 2、拦截器方法执行顺序 3、多个拦截器的执行顺序图解： 总结： 当有多个拦截器时： preHandle: 按照拦截器数组的正向顺序执行 postHandle: 按照拦截器数组得反向顺序执行 afterCompletion: 按照拦截器的数组反向顺序执行 当多个拦截器的 PreHandle 有不同的值时 第一个返回 false,第二个返回 false: 只有第一个 preHandle 会执行 第一个返回 true， 第二个返回 false;两个(全部)拦截器的 preHandle 都会执行，但是（全部）postHandle 都不会执行，而 afterCompletion 只有第一个（返回 false 的拦截器之前的拦截器之前的所有 afterCompletion）会执行 第一个返回 fasle,第二个返回 true； 只有第一个的 preHandle 会执行 五、异常处理1、异常处理的概述 SpringMVC 通过 ExceptionResolver 处理程序的异常，包括 Handler 映射、数据绑定以及目标方法执行发生的异常。 SpringMVC 提供 HandlerExceptionResolver 的实现类 2、HandlerExceptionResolver DispatcherServlet 默认装配的 HandlerExceptionResolver 没有使用 &lt;mvc:annotation-driven/&gt; 配置 使用了 &lt;mvc:annotation-driven/&gt; 配置： 3、异常处理_DefaultHandlerExceptionResolver对一些特殊的异常进行处理，比如： NoSuchRequestHandlingMethodException HttpRequestMethodNotSupportedException HttpMediaTypeNotSupportedException HttpMediaTypeNotAcceptableException 代码示例： 【index.jsp】 123&lt;body&gt; &lt;a href=&quot;testException&quot;&gt;异常测试&lt;/a&gt;&lt;/body&gt; 【ExceptionControllerTest.java】 123456@RequestMapping(value = &quot;/testException&quot;,method = RequestMethod.POST) // 不能是POST请求 public String testException()&#123; System.out.println(&quot;testDefaultHandlerExceptionResolver...&quot;); return &quot;success&quot;; &#125; 测试： 4、异常处理_SimpleMappingExceptionResolver 在 springmmvc.xml 中配置 12345678&lt;!--异常处理--&gt;&lt;bean id=&quot;simpleMappingExceptionResolver&quot; class=&quot;org.springframework.web.servlet.handler.SimpleMappingExceptionResolver&quot;&gt; &lt;property name=&quot;exceptionMappings&quot;&gt; &lt;props&gt; &lt;prop key=&quot;java.lang.ArrayIndexOutOfBoundsException&quot;&gt;error&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt;&lt;/bean&gt; 【ExceptionControllerTest.java】 12345678@RequestMapping(value = &quot;/testSimpleMappingException&quot;)public String testSimpleMappingException()&#123; System.out.println(&quot;testSimpleMappingException....&quot;); String[] s = new String[10]; // s[i] 下标大于数组的长度 System.out.println(s[12]); return &quot;success&quot;;&#125; 测试： 【eeor.jsp】 12345&lt;body&gt; &lt;a href=&quot;#&quot;&gt;操作异常，请稍后重试&lt;/a&gt; &lt;br&gt; $&#123;requestScope.exception &#125;&lt;/body&gt; 六、运行流程1、 流程图 工作流程描述： 用户向服务器发起请求，请求被 SpringMVC 前端控制器 DispatcherServlet 捕获： DispatcherServlet 对请求解析，得到请求资源的标识符（URL）： 判断请求 URL 对应的映射 ① 不存在： 再判断是否配置了 mvc:default-servlet-handler： 如果没配置，则控制台报映射查找不到，客户端展示 404 错误 ② 存在： 执行下面的流程 根据 URL，调用 HandlerMapping 获取该 Handler 配置的所有相关的对象（包括 Handler 对象以及 Handler 对象对应的拦截器），最后 HandlerExecutionChain 对象的形式返回： DispatcherServlet 根据获得的 Handler， 选择一个合适的 HandlerAdapter。 如果成功获得 HandlerAdapter 后，此时将开始拦截器的 preHandler(…) 方法【正向】 提取 Request 中的模型数据，填充 Handler 入参，开始执行 Handler （Controller）方法，处理请求。在填充 Handler 的入参过程中，根据配置，SpringMVC 将帮助做一些额外的工作： ① HttpMessageConverter: 将请求的信息（如 json、xml 的数据）转换成一个对象，将对象转换成指定的响应信息 ② 数据转换：对请求的消息进行数据转换。如 String 转换 Integer、Double 等。 ③ 数据格式化：对请求的消息进行数据格式化。如将字符串转换成数字或格式化日期等。 ④ 数据验证：验证数据的有效性（长度、格式等），验证结果存储到 BindingResult 或 EEOR 中。 Handler 执行完成后，向 DispatcherServlet 返回一个 ModelAndView 对象 此时开始执行拦截器的 postHasndle(…)方法【逆向】 根据返回的 ModelAndView （此时会判断是否存在异常：如果存在异常，则执行 HandelExceptionResolver 进行异常处理）选择一个适合的 DispacherServlet（必须是已经注册到 Spring 容器中 的 ViewResolver ）返回给 DispatcherServlet，根据 Model 和 View， 来渲染试图 在返回给客户端需要执行拦截器的 AfterCompletion 方法【逆向】 将渲染的结果返回给客户端 七、Spring 整合 SpringMVC1、Spring 与 SpringMVC 的整合问题 需要进行 Spring 整合 SpringMVC 吗？ 还是需要加入 Spring 的 IOC 容器？ 是否需要在 web.xml 文件中配置启动 SpringMVC 容器的 ContextLoaderListener？ 需要：通常情况下，类似于数据源，事务，整合其他框架都是放在 Spring 的配置文件中（而不是放在 SpringMVC 的配置文件中），实际上方入 Spring 配置文件对应的 IOC 容器中还有 Servlet 和 Dao。 不需要：都放在 SpringMVC 的配置文件中，也可以分多个 Spring 的配置文件，然后使用 import 节点导入其他的配置文件 2、Spring 整合 SpringMVC 解决方案配置监听器 监听器配置【web.xml】 12345678&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt;&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:bean.xml&lt;/param-value&gt;&lt;/context-param&gt; 创建 Spring 的 【bean.xml】配置文件： 12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!--设置扫描组件的包--&gt; &lt;context:component-scan base-package=&quot;com.oy.online.springmvc&quot;&gt; &lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt; &lt;/context:component-scan&gt; &lt;!--&lt;bean id=&quot;teacher&quot; class=&quot;com.oy.online.springmvc.bean.Teacher&quot;&gt;&lt;/bean&gt;--&gt;&lt;/beans&gt; SpringMVC 配置文件：【Springmvc.xml】 12345678910&lt;!-- 设置扫描组件的包 --&gt;&lt;context:component-scan base-package=&quot;com.oy.online.springmvc.Controller&quot;/&gt;&lt;!-- 配置视图解析器 --&gt;&lt;bean id=&quot;internalResourceViewResolver&quot;class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/views/&quot;/&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;&lt;/bean&gt;&lt;mvc:default-servlet-handler/&gt;&lt;mvc:annotation-driven/&gt; 注意：在 Teanch 类中增加构造方法，启动服务器，查看构造器执行情况。若 Spring 的 IOC 容器 和 SpringMVC 的 IOC 容器扫描的包有重合的部分，就会导致有的 bean 会被创建 2 次。 解决：使 Spring 的 IOC 容器扫描的包和 SpringMVC 的 IOC 容器扫描的包没有重合的部分.使用 exclude-filter 和 include-filter 子节点来规定只能扫描的注解 。 【bean.xml】: &lt;!– 不扫描@Controller 注解 –&gt; 【Springmvc.xml】：&lt;!– 扫描@Controller 注解 –&gt; 【index.jsp】 123&lt;body&gt; &lt;a href=&quot;testListener&quot;&gt;监听器测试&lt;/a&gt;&lt;/body&gt; 【SpringListener.java】 12345678910111213public class SpringListener implements ServletContextListener &#123; @Override public void contextInitialized(ServletContextEvent servletContextEvent) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;); ServletContext servletContext = servletContextEvent.getServletContext(); servletContext.setAttribute(&quot;context&quot;, context); &#125; @Override public void contextDestroyed(ServletContextEvent servletContextEvent) &#123; &#125;&#125; 【ExceptionControllerTest.java】 123456789101112@Controllerpublic class ExceptionControllerTest &#123; @RequestMapping() public void testListener(HttpSession session)&#123; // 获取spring所管理的teacher对象 ServletContext servletContext = session.getServletContext(); ApplicationContext context = (ApplicationContext) servletContext.getAttribute(&quot;context&quot;); Teacher teacher = context.getBean(&quot;Teacher&quot;, Teacher.class); System.out.println(teacher); &#125;&#125; 测试： 3、SpringIOC 容器和 SpringMVC IOC 容器的关系 SpringMVC 的 IOC 容器中的 bean 可以来引用 Spring IOC 容器中的 bean，之则不行. Spring IOC 容器中的 bean 却不能来引用 SpringMVC IOC 容器中的 bean 。 在 Spring MVC 配置文件中引用业务层的 Bean 多个 Spring IOC 容器之间可以设置为父子关系，以实现良好的解耦。 Spring MVC WEB 层容器可作为 “业务层” Spring 容器的子容器：即 WEB 层容器可以引用业务层容器的 Bean，而业务层容器却访问不到 WEB 层容器的 Bean 。 4、SpringMVC 对比 Struts2 Spring MVC 的入口是 Servlet, 而 Struts2 是 FilterSpring MVC 会稍微比 Struts2 快些. Spring MVC 是基于方法设计, 而 Sturts2 是基于类,每次发一次请求都会实例一个 Action. Spring MVC 使用更加简洁, 开发效率 Spring MVC 确实比 struts2 高: 支持 JSR303, 处理 ajax 的请求更方便 Struts2 的 OGNL 表达式使页面的开发效率相比 Spring MVC 更高些","categories":[{"name":"JavaEE框架","slug":"JavaEE框架","permalink":"http://blog.oy6090.top/categories/JavaEE%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"java","slug":"java","permalink":"http://blog.oy6090.top/tags/java/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://blog.oy6090.top/tags/SpringMVC/"}]},{"title":"java项目：客户管理系统","slug":"java项目：客户信息管理系统","date":"2020-07-31T16:00:00.000Z","updated":"2021-01-22T03:51:27.900Z","comments":true,"path":"posts/10150.html","link":"","permalink":"http://blog.oy6090.top/posts/10150.html","excerpt":"","text":"源码已经打包在博客末尾，有需要的话自行下载。 java 项目： 客户信息管理系统环境：​ Idea 集成开发工具 技术点： 面向对象 数组 项目结构： 代码展示：【bean】 Customer.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class Customer &#123; private String name; // 姓名 private char gender; // 性别 private int age; // 年龄 private String phone; // 电话 private String email; // 邮箱 public Customer() &#123; &#125; public Customer(String name, char gender, int age, String phone, String email) &#123; this.name = name; this.gender = gender; this.age = age; this.phone = phone; this.email = email; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public char getGender() &#123; return gender; &#125; public void setGender(char gender) &#123; this.gender = gender; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getPhone() &#123; return phone; &#125; public void setPhone(String phone) &#123; this.phone = phone; &#125; public String getEmail() &#123; return email; &#125; public void setEmail(String email) &#123; this.email = email; &#125;&#125; 【service】 CusomerList.java\\ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394/***@Description 内部封装一个Customer[],提供对Customer数据的增删改查操作*/public class CustomerList &#123; private Customer[] customers; private int total; // 记录存储个数 /** * 构造器，用来初始化customer数组 * totalCustomer: 指定customer 数组的最大空间 * @param totalCustomer */ public CustomerList(int totalCustomer)&#123; customers = new Customer[totalCustomer]; &#125; /** * 添加指定的客户到数组中 * @param customer * @return 添加是否成功 */ public boolean addCustomer(Customer customer)&#123; if(customer != null &amp;&amp; total &lt; customers.length)&#123; customers[total++] = customer; return true; &#125; return false; &#125; /** * 替换指定索引位置上的数组元素 * @param index * @param cust * @return */ public boolean replanceCustomer(int index, Customer cust)&#123; if(index &gt;= 0 &amp;&amp; index &lt; total)&#123; customers[index] = cust; return true; &#125; return false; &#125; /** * 删除指定索引位置上的元素 * @param index * @return */ public boolean deleteCustomer(int index)&#123; if(index &gt;= 0 &amp;&amp; index &lt; total)&#123; for(int i = index; i &lt; total -1; i++)&#123; customers[i] = customers[i+1]; &#125; customers[total -1] = null; total--; // 存储人数在减少1 // customers[--total] = null; return true; &#125; return false; &#125; /** * 获取所有的customers 对象构成的数组 * @return */ public Customer[] getAllCustomers()&#123; Customer[] custs = new Customer[total]; // 给元素复制 for(int i = 0; i &lt; custs.length; i++)&#123; custs[i] = customers[i]; &#125; return custs; &#125; /** * 返回指定的索引位置上的Customer * @param index * @return 如果输入的index位置上的元素不存在，返回Null */ public Customer getCustomer(int index)&#123; if(index &gt;= 0 &amp;&amp; index &lt; total)&#123; return customers[index]; &#125; return null; &#125; /** * 返回Customer对象的个数 * @return */ public int getToTal()&#123; return total; &#125;&#125; 【ul】 CustomerView.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179public class CustomerView &#123; private CustomerList customerList = new CustomerList(10); public CustomerView()&#123; Customer customer = new Customer(&quot;柯南&quot;,&#x27;男&#x27;,23,&quot;13344453434&quot;,&quot;kennan@123.com&quot;); customerList.addCustomer(customer); &#125; public void enterMainMenu()&#123; boolean isFlag = true; do&#123; System.out.println(&quot;\\n-----------------客户信息管理软件-----------------\\n&quot;); System.out.println(&quot; 1 添 加 客 户&quot;); System.out.println(&quot; 2 修 改 客 户&quot;); System.out.println(&quot; 3 删 除 客 户&quot;); System.out.println(&quot; 4 客 户 列 表&quot;); System.out.println(&quot; 5 退 出\\n&quot;); System.out.print(&quot; 请选择(1-5)：&quot;); // 从键盘获取用户1-5的选择 char menu = CMUtility.readMenuSelection(); // 使用switch-case对用户选择，进行区别处理 switch(menu)&#123; case &#x27;1&#x27;: addNewCustomer(); break; case &#x27;2&#x27;: modifyCustomer(); break; case &#x27;3&#x27;: deleteCustomer(); break; case &#x27;4&#x27;: listAllCustomer(); break; case &#x27;5&#x27;: System.out.print(&quot;确认是否退出(Y/N)：&quot;); char exit = CMUtility.readConfirmSelection(); if(exit == &#x27;Y&#x27;)&#123; isFlag = false; &#125; &#125; &#125;while(isFlag); &#125; /** * 添加用户 */ public void addNewCustomer()&#123; System.out.println(&quot;---------------------添加客户---------------------&quot;); System.out.print(&quot;姓名：&quot;); String name = CMUtility.readString(5); System.out.print(&quot;性别：&quot;); char gender = CMUtility.readChar(); System.out.print(&quot;年龄：&quot;); int age = CMUtility.readInt(); System.out.print(&quot;电话：&quot;); String phone = CMUtility.readString(13); System.out.print(&quot;邮箱：&quot;); String email = CMUtility.readString(20); // 封装一个对象 Customer customer = new Customer(name, gender, age, phone, email); // 将此对象添加到CustomerList里的数组中 boolean flag = customerList.addCustomer(customer); if(flag)&#123; System.out.println(&quot;---------------------添加完成---------------------&quot;); &#125;else&#123; System.out.println(&quot;人数已达上限，添加失败！&quot;); &#125; &#125; /** * 2. 修改客户 */ public void modifyCustomer()&#123; System.out.println(&quot;---------------------修改客户---------------------&quot;); Customer customer; int index; for(;;)&#123; System.out.print(&quot;请选择待修改客户编号(-1退出)：&quot;); index = CMUtility.readInt(); if(index == -1)&#123; return; &#125; // 对于用户来将，我们让index 默认从1开始。 customer = customerList.getCustomer(index -1); if(customer == null)&#123; System.out.println(&quot;无法找到指定客户！&quot;); &#125;else&#123; break; &#125; &#125; // 修改用户的信息 System.out.println(&quot;姓名(&quot; + customer.getName() + &quot;):&quot;); // 如果用户输入了姓名，则返回使用输入的信息，如果用户没有输入，直接回车，则返回customer.getName(); String name = CMUtility.readString(5, customer.getName()); System.out.println(&quot;性别(&quot; + customer.getGender() + &quot;):&quot;); char gender = CMUtility.readChar(customer.getGender()); System.out.println(&quot;年龄(&quot; + customer.getAge() + &quot;):&quot;); int age = CMUtility.readInt(customer.getAge()); System.out.println(&quot;电话(&quot; + customer.getPhone() + &quot;):&quot;); String phone = CMUtility.readString(13, customer.getPhone()); System.out.println(&quot;邮箱(&quot; + customer.getEmail() + &quot;):&quot;); String email = CMUtility.readString(20, customer.getEmail()); // 获取用户输入的属性以后，得到最新的Customer对象 customer = new Customer(name, gender, age, phone, email); // 对于用户来讲，我们让index默认从1开始 boolean flag = customerList.replanceCustomer(index -1, customer); if(flag)&#123; System.out.println(&quot;---------------------修改完成---------------------&quot;); &#125;else&#123; System.out.println(&quot;---------------------修改失败---------------------&quot;); &#125; &#125; /** * 3 删除客户 */ public void deleteCustomer()&#123; System.out.println(&quot;---------------------删除客户---------------------&quot;); Customer customer; int index; for(;;)&#123; System.out.println(&quot;请选择待删除客户编号(-1退出)：&quot;); // 针对普通用户来讲：此index从1开始 index = CMUtility.readInt(); if(index == -1)&#123; return; &#125; customer = customerList.getCustomer(index -1); if(customer == null)&#123; System.out.println(&quot;无法找到指定的客户！&quot;); &#125;else&#123; break; &#125; &#125; // 一旦找到相应的索引位置的customer以后，让用户决定是否确定删除 System.out.println(&quot;确认是否删除(Y/N)：&quot;); char deleOrNot = CMUtility.readChar(); if(deleOrNot == &#x27;Y&#x27;)&#123; boolean flag = customerList.deleteCustomer(index -1); if(flag)&#123; System.out.println(&quot;---------------------删除完成---------------------&quot;); &#125;else&#123; System.out.println(&quot;---------------------删除失败---------------------&quot;); &#125; &#125;else&#123; return; &#125; &#125; public void listAllCustomer()&#123; System.out.println(&quot;---------------------------客户列表---------------------------&quot;); // 获取所有的客户 Customer[] customers = customerList.getAllCustomers(); if(customers.length == 0)&#123; System.out.println(&quot;没有任何客户记录！&quot;); &#125;else&#123; System.out.println(&quot;编号\\t\\t姓名\\t\\t性别\\t\\t年龄\\t\\t电话\\t\\t\\t\\t邮箱&quot;); for(int i = 0; i &lt; customers.length; i++)&#123; Customer cust = customers[i]; System.out.println((i + 1) + &quot;\\t\\t&quot; + cust.getName() + &quot;\\t\\t&quot; + cust.getGender() + &quot;\\t\\t&quot; + cust.getAge() + &quot;\\t\\t&quot; + cust.getPhone() + &quot;\\t\\t&quot; + cust.getEmail()); //方式二： //System.out.println((i + 1) + &quot;\\t&quot; + cust.info()); &#125; &#125; System.out.println(&quot;-------------------------客户列表完成-------------------------&quot;); &#125; public static void main(String[] args)&#123; CustomerView view = new CustomerView(); view.enterMainMenu(); &#125;&#125; 【util】 CMUtility.java 工具类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126import java.util.*;/**CMUtility工具类：将不同的功能封装为方法，就是可以直接通过调用方法使用它的功能，而无需考虑具体的功能实现细节。*/public class CMUtility &#123; private static Scanner scanner = new Scanner(System.in); /** 用于界面菜单的选择。该方法读取键盘，如果用户键入’1’-’5’中的任意字符，则方法返回。返回值为用户键入字符。 */ public static char readMenuSelection() &#123; char c; for (; ; ) &#123; String str = readKeyBoard(1, false); c = str.charAt(0); if (c != &#x27;1&#x27; &amp;&amp; c != &#x27;2&#x27; &amp;&amp; c != &#x27;3&#x27; &amp;&amp; c != &#x27;4&#x27; &amp;&amp; c != &#x27;5&#x27;) &#123; System.out.print(&quot;选择错误，请重新输入：&quot;); &#125; else break; &#125; return c; &#125; /** 从键盘读取一个字符，并将其作为方法的返回值。 */ public static char readChar() &#123; String str = readKeyBoard(1, false); return str.charAt(0); &#125; /** 从键盘读取一个字符，并将其作为方法的返回值。 如果用户不输入字符而直接回车，方法将以defaultValue 作为返回值。 */ public static char readChar(char defaultValue) &#123; String str = readKeyBoard(1, true); return (str.length() == 0) ? defaultValue : str.charAt(0); &#125; /** 从键盘读取一个长度不超过2位的整数，并将其作为方法的返回值。 */ public static int readInt() &#123; int n; for (; ; ) &#123; String str = readKeyBoard(2, false); try &#123; n = Integer.parseInt(str); break; &#125; catch (NumberFormatException e) &#123; System.out.print(&quot;数字输入错误，请重新输入：&quot;); &#125; &#125; return n; &#125; /** 从键盘读取一个长度不超过2位的整数，并将其作为方法的返回值。 如果用户不输入字符而直接回车，方法将以defaultValue 作为返回值。 */ public static int readInt(int defaultValue) &#123; int n; for (; ; ) &#123; String str = readKeyBoard(2, true); if (str.equals(&quot;&quot;)) &#123; return defaultValue; &#125; try &#123; n = Integer.parseInt(str); break; &#125; catch (NumberFormatException e) &#123; System.out.print(&quot;数字输入错误，请重新输入：&quot;); &#125; &#125; return n; &#125; /** 从键盘读取一个长度不超过limit的字符串，并将其作为方法的返回值。 */ public static String readString(int limit) &#123; return readKeyBoard(limit, false); &#125; /** 从键盘读取一个长度不超过limit的字符串，并将其作为方法的返回值。 如果用户不输入字符而直接回车，方法将以defaultValue 作为返回值。 */ public static String readString(int limit, String defaultValue) &#123; String str = readKeyBoard(limit, true); return str.equals(&quot;&quot;)? defaultValue : str; &#125; /** 用于确认选择的输入。该方法从键盘读取‘Y’或’N’，并将其作为方法的返回值。 */ public static char readConfirmSelection() &#123; char c; for (; ; ) &#123; String str = readKeyBoard(1, false).toUpperCase(); c = str.charAt(0); if (c == &#x27;Y&#x27; || c == &#x27;N&#x27;) &#123; break; &#125; else &#123; System.out.print(&quot;选择错误，请重新输入：&quot;); &#125; &#125; return c; &#125; private static String readKeyBoard(int limit, boolean blankReturn) &#123; String line = &quot;&quot;; while (scanner.hasNextLine()) &#123; line = scanner.nextLine(); if (line.length() == 0) &#123; if (blankReturn) return line; else continue; &#125; if (line.length() &lt; 1 || line.length() &gt; limit) &#123; System.out.print(&quot;输入长度（不大于&quot; + limit + &quot;）错误，请重新输入：&quot;); continue; &#125; break; &#125; return line; &#125;&#125; 提取码：qrj3 下载源码","categories":[{"name":"项目实战","slug":"项目实战","permalink":"http://blog.oy6090.top/categories/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/"}],"tags":[{"name":"java","slug":"java","permalink":"http://blog.oy6090.top/tags/java/"},{"name":"java项目","slug":"java项目","permalink":"http://blog.oy6090.top/tags/java%E9%A1%B9%E7%9B%AE/"}]},{"title":"SpringMVC基础（上篇）","slug":"SpringMVC基础(上篇)","date":"2020-07-29T16:00:00.000Z","updated":"2020-10-25T02:22:40.561Z","comments":true,"path":"posts/1905208898.html","link":"","permalink":"http://blog.oy6090.top/posts/1905208898.html","excerpt":"","text":"资料已经打包放在博客下面（文章末尾） 源码分析 源代码 一、SpringMVC 入门案例个人 CSDN 博客：CSDN 点击链接查看：SpringMVC 之永远的 Hello world 二、 @RequestMapping 注解1、@RequestMapping 概念 在控制器的类定义及方法定义处都可标注 @RequestMapping ​ ① 标记在类上：提供初步的映射信息。相对于 WEB 应用的根目录 ​ ② 标记在方法上：提供一步的细分映射信息。相对于标记在类的 URL 若类上未标注 @RequestMapping，则方法处标记的 URL 相对于 WEB 应用的根目录 作用：DispatcherServlet 截获请求后，就通过控制器上 @RequestMapping 提供的映射信息确定请求所对应的处理方法。 2、RequestMapping 可标注的位置@RequestMapping：设置请求映射，把请求和控制层中的方法设置映射关系 当请求路径和@RequestMapping 的 value 属性值一致时，则该注解的方法即为处理请求的方法 12345@RequestMapping(&quot;/hello&quot;)public String hello()&#123; System.out.println(&quot;hello&quot;); return &quot;hello&quot;;&#125; @RequestMapping 可以加在类上，也可加在方法上。 12345678910@Controller@RequestMapping(&quot;/test&quot;)public class ControllerTest &#123; @RequestMapping(&quot;/hello&quot;) public String hello()&#123; System.out.println(&quot;hello&quot;); return &quot;hello&quot;; &#125;&#125; 若类和方法上加得有，应该一层一层的访问，先访问类，在访问类中的方法 3、RequestMapping 映射请求方式 method：用来设置请求方式只有客户端发送请求方式和 method 的值一致，才能处理请求。 请求方式： GET（查询） POST（添加）PUT（修改）DELETE（删除） 1@RequestMapping(value = &quot;/hello&quot;, method = RequestMethod.GET) params: 用来设置客户端传到服务器的数据，支持表达式。 例如：username !username username=admin username!=admin 1@RequestMapping(value = &quot;/hello&quot;, params= &#123;&quot;username&quot;,&quot;age!=12&quot;&#125; ) headers: 用来设置请求头信息，所发送的请求的请求头信息一定要和 headers 属性中所设置的一致 1@RequestMapping(value = &quot;/hello&quot;, headers= &#123;&quot;Accept-Language=zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2&quot;&#125; ) 4、RequestMapping 支持 Ant 路径风格 Ant 风格资源地址支持 3 种匹配 ?：匹配文件名中的一个字符 *：匹配文件名中的任意字符 **：** 匹配多层路径 @RequestMapping 支持 Ant 风格的 URL 例如：/user/*/createUser 匹配 /user/aaa/createUser、/user/bbb/createUser 等 URL 例如：/user/**/createUser 匹配 /user/createUser、/user/**aaa/bbb/**createUser 等 URL 12345@RequestMapping(value = &quot;/*/ant??/**/testAnt&quot;)public String hello1()&#123; System.out.println(&quot;hello&quot;); return &quot;hello&quot;;&#125; 5、RequestMapping 映射请求占位符 PathVariable 注解​ 通过 @PathVariable 可以将 URL 中占位符参数绑定到控制器处理方法的入参中：URL 中的 {xxx} 占位符可以通过 @PathVariable(“xxx“) 绑定到操作方法的入参中。 12345@RequestMapping(&quot;/testREST/&#123;id&#125;/&#123;username&#125;&quot;)public String testREST(@PathVariable Integer id, @PathVariable String username)&#123; System.out.println(&quot;id=&quot; + id +&quot;,username=&quot;+username); return &quot;hello&quot;;&#125; 三、REST1、简介 RESTREST：即 Representational State Transfer 。（资源）表现层状态转化。是目前最流行的一种互联网软件架构。 2、配置 HiddenHTTPMethodFilter 过滤器在web.xml中配置 12345678&lt;filter&gt; &lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.HiddenHttpMethodFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 3、原理图 4、代码示例 GET 在 web 目录下创建 rest.jsp 文件 123&lt;body&gt; &lt;a href=&quot;testREST/100&quot;&gt;测试GET&lt;/a&gt;&lt;/body&gt; 12345@RequestMapping(value = &quot;/testREST/&#123;id&#125;&quot;,method = RequestMethod.GET)public String getUserById(@PathVariable(&quot;id&quot;) Integer id)&#123; System.out.println(&quot;GET,id=&quot;+id); return &quot;success&quot;;&#125; POST 【rest.jsp】 123&lt;form action=&quot;testREST&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;测试POST&quot;&gt;&lt;/form&gt; 12345@RequestMapping(value = &quot;/testREST&quot;, method = RequestMethod.POST)public String insertUser()&#123; System.out.println(&quot;POSt&quot;); return &quot;success&quot;;&#125; PUT 【rest.jsp】 1234&lt;form action=&quot;testREST&quot; method=&quot;POST&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;PUT&quot; /&gt; &lt;input type=&quot;submit&quot; value=&quot;测试PUT&quot; /&gt;&lt;/form&gt; 12345@RequestMapping(value = &quot;/testREST&quot;, method = RequestMethod.POST)public String insertUser()&#123; System.out.println(&quot;POSt&quot;); return &quot;success&quot;;&#125; DELETE 【rest.jsp】 1234&lt;form action=&quot;testREST/1001&quot; method=&quot;POST&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;DELETE&quot; /&gt; &lt;input type=&quot;submit&quot; value=&quot;测试DELETE&quot; /&gt;&lt;/form&gt; 12345@RequestMapping(value = &quot;/testREST/&#123;id&#125;&quot;, method = RequestMethod.DELETE)public String deleteUser(@PathVariable(&quot;id&quot;) Integer id)&#123; System.out.println(&quot;DELETE, id=&quot; + id); return &quot;success&quot;;&#125; 注意：测试 PUT 和 DELETE 中 Tomcat 为 8.0 或者以上，则会出现以下报错 解决方式：【 JSP 只允许 GET、POST 或 HEAD】 在你要跳转到的目标页面的下面这句代码里面添加**isErrorPage=”true”**即可，如下： 1&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt; 改为 1&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; isErrorPage=&quot;true&quot;%&gt; 四、处理请求数据请求参数：请求参数 cookie 信息 请求头信息…. JavaWEB: HttpServletRequest ​ Request.getParameter(参数名)； Request.getParameterMap(); ​ Request.getCookies(); ​ Request.getHeader(); 1、请求处理的方法签名 Spring MVC 通过分析处理方法的签名(方法名+ 参数列表)， HTTP 请 求信息绑定到处理方法的相应形参中。 Spring MVC 对控制器处理方法签名的限制是很宽松的，几乎可以按喜欢的任何方式对方法进行签名。 必要时可以对方法及方法入参标注相应的注解（ @PathVariable 、 @RequestParam、@RequestHeader 等） 、 Spring MVC 框架会将 HTTP 请求的信息绑定到相应的方法入参中，并根据方法的返回值类型做出相应的后续处理。 2、@RequestParam 注解 @RequestParam 可以把请求参数传递给请求方法 在处理请求的方法中，加入相对应的形参，保证形参数名和传递的数据的参数名保持一致，就可以自动赋值 value：当不满足赋值条件时，可以使用 value 属性，指定映射关系 required：设置形参是否赋被赋值，默认为 ture，必须赋值，若设置为 false，则不必须赋值，因此形参的值为 null defaultValue：若形参所获取得的值为 null,则设置一个默认值，用在分页和模糊查询中 代码示例： 【param.jsp】 12345678&lt;body&gt; &lt;form action=&quot;param&quot; method=&quot;post&quot;&gt; username:&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br&gt; password:&lt;input type=&quot;text&quot; name=&quot;password&quot;&gt;&lt;br&gt; age:&lt;input type=&quot;text&quot; name=&quot;age&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt; &lt;/form&gt;&lt;/body&gt; 【ParamController.java】 12345@RequestMapping(value = &quot;/param&quot;,method = RequestMethod.POST) public String param(@RequestParam(value = &quot;username&quot;,required =false, defaultValue = &quot;xiaoming&quot;) String name, String password, String age)&#123; System.out.println(&quot;name=&quot;+name+&quot;,password=&quot;+password+&quot;,age=&quot;+age); return &quot;success&quot;; &#125; 3、@RequsetHeader 注解 使用@RequestHeader 绑定请求头的属性值 请求头包含若干个属性，服务器可据此获知客户端的信息，通过@RequestHeader 即可将请求头的属性绑定到处理方法的入参中 12345@RequestMapping(value = &quot;/param&quot;, method = RequestMethod.POST)public String param(@RequestHeader(&quot;Accept-Language&quot;) String AcceptLanguage)&#123; System.out.println(&quot;AcceptLanguage=&quot;+AcceptLanguage); return &quot;success&quot;;&#125; 4、@CookieValue 注解 使用@CookieValue 绑定请求中的 cookie 值 @CookieValue 可让处理的方法入参绑定某个 Cookie 值 12345@RequestMapping(value = &quot;/param&quot;, method = RequestMethod.POST)public String param(@CookieValue(value =&quot;JSESSIONID&quot; ) String JSESSIONID)&#123; System.out.println(&quot;JSESSIONID&quot;+JSESSIONID); return &quot;success&quot;;&#125; 5、使用 POJO 作为参数 使用 POJO 对象绑定请求参数值 Spring MVC 会按请求参数名和 POJO 属性名进行自动匹配，自动为该对象填充属性值，支持级联赋值。 【param.jsp】 1234567891011&lt;body&gt; &lt;form action=&quot;param&quot; method=&quot;post&quot;&gt; username:&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br&gt; password:&lt;input type=&quot;text&quot; name=&quot;password&quot;&gt;&lt;br&gt; age:&lt;input type=&quot;text&quot; name=&quot;age&quot;&gt;&lt;br&gt; province:&lt;input type=&quot;text&quot; name=&quot;address.province&quot;&gt;&lt;br&gt; city:&lt;input type=&quot;text&quot; name=&quot;address.city&quot;&gt;&lt;br&gt; county:&lt;input type=&quot;text&quot; name=&quot;address.county&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt; &lt;/form&gt;&lt;/body&gt; 需要创建 User 类 和 Address 类 12345678910111213public class User &#123; private String username; private String password; private String age; private Address address; ....&#125;public class Address &#123; private String province; private String city; private String county; ...&#125; 【ParaController.java】 12345@RequestMapping(value = &quot;/param&quot;,method = RequestMethod.POST) public String param(User user)&#123; System.out.println(user); return &quot;success&quot;; &#125; 6、注意：如果中文出现乱码（idea）​ 需要配置字符编码过滤器， 且配置其他过滤器之前，如（HiddenHttpMethodFilter），否则不起作用。 1234567891011121314151617181920212223242526272829303132&lt;!-- 配置字符集 --&gt;&lt;filter&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;&lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 在修改 Tomcat 添加：**-Dfile.encoding=UTF-8** 7、使用 Servlet 原生 API 作为参数 MVC 的 Handler 方法可以接受的 ServletAPI 类型的参数 HttpServletRequest HttpServletResponse HttpSession java.security.Principal Locale InputStream OutputStream Reader Writer 代码示例： 需要导入 123456@RequestMapping(value = &quot;/param&quot;, method = RequestMethod.POST) public String param(HttpServletRequest request, HttpServletResponse response)&#123; String username = request.getParameter(&quot;username&quot;); System.out.println(username); return &quot;success&quot;; &#125; 123456@RequestMapping(value = &quot;/param&quot;,method = RequestMethod.POST)public void param(HttpServletRequest request, HttpServletResponse response, Writer out) throws IOException &#123; System.out.println(&quot;param&quot; + request +&quot;,&quot; + response); out.write(&quot;hello,world&quot;); // return &quot;success&quot;;&#125; 五、处理响应数据1、SpringMVC 输出模型数据的途径 ModelAndView: 处理方法返回值类型为 ModelAndView 时，方法体即可通过该对象添加模型数据。 Map 和 Model: 入参 org.springframework.ui.Model、org.springframework.ui.ModelMap 或 java.uti.Map 时，处理方法返回时， Map 中的数据会自动添加到模型中。 2、处理模型数据之 ModelAndView 两个重要的成员变量: private Object view; 视图信息 private ModelMap model; 模型数据 添加模型数据 MoelAndView addObject(String attributeName, Object attributeValue) 设置模型数据 ModelAndView addAllObject(Map&lt;String, ?&gt; modelMap) 设置视图 void setView(View view) 设置视图对象 void setViewName(String viewName) 设置视图名字 获取模型数据 protected Map&lt;String, Object&gt; getModelInternal() 获取模型数据 public ModelMap getModelMap() public Map&lt;String, Object&gt; getModel() 代码示例： 1234567@RequestMapping(value = &quot;/param&quot;, method = RequestMethod.POST)public ModelAndView param()&#123; ModelAndView mav = new ModelAndView(); mav.addObject(&quot;username&quot;, &quot;root&quot;);//往request作用域中放值 mav.setViewName(&quot;success&quot;);//设置视图名称，实现页面跳转 return mav;&#125; 【success.jsp】 1234&lt;body&gt; &lt;h1&gt;成功&lt;/h1&gt; $&#123;requestScope.username&#125;&lt;/body&gt; 3、处理模型数据之 Map Model第一种方式： 12345@RequestMapping(value = &quot;/param&quot;, method = RequestMethod.POST)public String param(Map&lt;String, Object&gt; map)&#123; map.put(&quot;username&quot;, &quot;root&quot;); // 往作用域中放值 return &quot;success&quot;;// 返回示图名称&#125; 第二种方式： 12345@RequestMapping(value = &quot;/param&quot;, method = RequestMethod.POST)public String param(Model model)&#123; model.addAttribute(&quot;username&quot;, &quot;张三&quot;);// 向作用域中放值 return &quot;success&quot;; // 返回试图的名称&#125; 六、视图解析1、SpringMVC 解析视图概述 2、视图和视图解析器 请求处理方法执行完成后，最终返回一个 ModelAndView 对象。对于那些返回 String，View 或 ModeMap 等类型的处理方法， Spring MVC 也会在内部将它们装配成一个 ModelAndView 对象，它包含了逻辑名和模型对象的视图。 Spring MVC 借助视图解析器（ViewResolver）得到最终的视图对象（View），最终的视图可以是 JSP。 3、常用的试图实现类 4、JstlView 若项目使用了 JSTL，则 SpringMVC 会自动把试图由 InternallResoureView 转为 JstlView （断点调试，将 JSTL 的 jar 包增加到项目中，视图解析器会自动修改为 JstlView） 代码示例：增加 jstl 标签 jar 包（断点调试，这时的 View 对象就是 JstlView） 5、试图解析器 SpringMVC 为逻辑视图名的解析提供了不同的策略，可以在 SpringMVC 上下文中配置一种或多种解析策略， 并指定他们之间的先后顺序。每一种映射策略对应一个具体的视图解析器实现类。 视图解析器的作用比较单一：将逻辑视图解析为一个具体的视图对象。 所有的视图解析器都必须实现 ViewResolver 接口： 6、常用的试图解析器实现类 可以选择一个试图解析器或混用多种试图解析器 每个试图解析器都实现了 Ordered 接口并开放一个order 属性，可以通过 order 属性指定解析器的优先顺序， order 越小优先级越高。 12345&lt;bean id=&quot;viewResolver&quot; class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/view/&quot;&gt;&lt;/property&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt; &lt;property name=&quot;order&quot; value=&quot;1&quot;&gt;&lt;/property&gt;&lt;/bean&gt; InternalResourceViewResolver JSP 是最常见的视图技术，可以使用 InternalResourceViewResolve 作为视图解析器： 7、重定向 一般情况下，控制器方法返回字符串类型的值会被当成逻辑试图处理 如果返回的字符串中带 forward: 或 redirect: 前缀时，SpringMVC 会对他们进行特殊的处理： 将 forward: 和 redirect: 当成指示符，其后的字符串作为 URL 来处理。 redirect:success.jsp：会完成一个到 success.jsp 的重定向的操作 forward:success.jsp：会完成一个到 success.jsp 的转发操作 代码示例： 【redirect.jsp】在 Web 目录下创建 12345&lt;body&gt; &lt;a href=&quot;redirect&quot;&gt;redirect测试&lt;/a&gt; &lt;br&gt; &lt;a href=&quot;forward&quot;&gt;forward测试&lt;/a&gt;&lt;/body&gt; 【RedirectTest.java】 123456789101112131415@Controllerpublic class RedirectTest &#123; @RequestMapping(value = &quot;/redirect&quot;, method = RequestMethod.GET) public String redirect()&#123; System.out.println(&quot;redirect测试&quot;); return &quot;redirect:/index.jsp&quot;; &#125; @RequestMapping(value = &quot;/forward&quot;,method = RequestMethod.GET) public String forward()&#123; System.out.println(&quot;forward测试&quot;); return &quot;forward:/index.jsp&quot;; &#125;&#125; 重定向原理： return “forward:/index.jsp” 提取码：pwbr 查看文档","categories":[{"name":"JavaEE框架","slug":"JavaEE框架","permalink":"http://blog.oy6090.top/categories/JavaEE%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"java","slug":"java","permalink":"http://blog.oy6090.top/tags/java/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://blog.oy6090.top/tags/SpringMVC/"}]},{"title":"Java之反射","slug":"java之反射","date":"2020-07-28T16:00:00.000Z","updated":"2021-01-22T03:53:03.335Z","comments":true,"path":"posts/31610.html","link":"","permalink":"http://blog.oy6090.top/posts/31610.html","excerpt":"","text":"一、反射的概念1、反射的理解Reflection(反射) 是被视为动态语言的关键，反射的机制允许程序在执行期间借助 Reflection API 取得任何类的内部信息，并能直接操作任意对象的内部属性方法。 框架 = 反射 + 注解 +设计模式 2、反射的”动态性”1234567891011121314151617181920212223242526272829@Test public void test1()&#123; for(int i = 0; i &lt; 100; i++)&#123; int num = new Random().nextInt(3); //0,1,2 String classPath = &quot;&quot;; switch (num)&#123; case 0: classPath = &quot;java.util.Date&quot;; break; case 1: classPath = &quot;java.lang.object&quot;; break; case 2: classPath = &quot;com.oy.online.reflect&quot;; break; &#125; try &#123; Object obj = getInstance(classPath); System.out.println(obj); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; public Object getInstance(String classPath) throws Exception &#123; Class clazz = Class.forName(classPath); return clazz.newInstance(); &#125; 3、反射机制提供的功能 在运行时判断一个对象所属的类 在运行时构造任意一个类的对象 在运行时判断一个类所具有的成员变量和方法 在运行时获取泛型信息 在运行时调用任意一个对象的成员变量和方法 在运行时处理注解 生成动态代理 4、相关 AIP java.lang.Class: 反射的源头 java.lang.reflect.Method java.lang.reflect.Field java.lang.reflect.Consructor 二、Class 类的理解和获取 Class 实例1、Class 类的理解 类的加载过程： 程序经过 javac.exe 命令以后，会生成一个多字节码文件（.class 结尾），接着我们使用 java.exe 对某个字节码文件进行解释运行。相当于将某个字节码文件记载到内存中。此过程就称为类的加载。加载到内存中的类，我们称为运行时类，就作为 Class 的一个实例。 class 的实例就对应着一个运行时类。 加载到内存中的运行时类，会缓存一定的时间，在此时间之内，我们可以通过不同的方式类获取运行类。 2、获取 Class 实例的方式方式一：调用运行时类的属性：.class 12Class&lt;Person&gt; clazz = Person.class;System.out.println(clazz); 方式二：通过运行时类的对象,调用 getClass() 123Person p1 = new Person();Class clazz = p1.getClass();System.out.println(clazz); 方式三：调用 Class 的静态方法：forName(String classPath) 12Class&lt;?&gt; clazz = Class.forName(&quot;com.oy.online.bean.Person&quot;);System.out.println(clazz); 方式四：使用类的加载器：ClassLoader 123ClassLoader classLoader = ReflectTest2.class.getClassLoader();Class&lt;?&gt; clazz = classLoader.loadClass(&quot;com.oy.online.bean.Person&quot;);System.out.println(clazz); 3、Class 实例化的结构 class：外部类、成员（成员内部类，静态内部类）、局部内部类、匿名内部类 interface：接口 []: 数组 enum: 枚举 annotation: 注解@interface primitive type : 基本数据类型 viod 三、了解 ClassLoad1、类的加载过程 2、类的加载器的作用 3、类的加载器的分类 4、Java 类编译、运行的执行的流程 5、试用 Classloader 加载 src 目录下的配置文件代码示例： 123456789101112131415161718 @Test public void test5() throws Exception &#123; Properties pros = new Properties(); // 此时的文件默认在当前module下。 // 读取配置文件的方式一：// FileInputStream fis = new FileInputStream(&quot;jdbc.properties&quot;);// pros.load(fis); // 读取配置二：使用ClassLoader // 配置文件默认识别为：当前module的src下 ClassLoader clazz = ReflectTest2.class.getClassLoader(); InputStream is = clazz.getResourceAsStream(&quot;jdbc.properties&quot;); pros.load(is); String user = pros.getProperty(&quot;user&quot;); String password = pros.getProperty(&quot;password&quot;); System.out.println(&quot;user =&quot;+ user + &quot;,password =&quot;+ password); &#125; 四、反射应用一：创建运行时类的对象123Class&lt;Person&gt; clazz = Person.class;Person obj = clazz.newInstance();System.out.println(obj); 说明： newInstance(): 调用此方法的运行类的对象。内部调用了运行类的空参的构造器。 要想方法正常的创建运行时类的对象，要求： 运行时必须是提供空参构造器 空参的构造器的访问权限的够。通常，设置为 public. 在 javabean 中要求提供一个 public 的空参构造器。原因： 便于通过反射，创建运行时类的对象 便于子类继承此运行类，默认调用 super()时，保证父类此构造器 五、反射应用二：获取运行时类的完整结构通过反射，获取对应的运行时类中所有的属性、方法、构造器、父类、接口、父类的泛型、包、注解、异常等… getFields()：获取当前运行时类及其父类中声明为 public 访问权限的属性 getDeclaredFields()：获取当前运行类中声明的属性。（不包含父类中声明的属性） 12345678910111213141516171819@Testpublic void test2()&#123; Class&lt;Person&gt; clazz = Person.class; // 获取属性结构 // getFields():获取当前运行时类及其父类中声明为public访问权限的属性 Field[] fields = clazz.getFields(); for (Field f : fields) &#123; System.out.println(f); &#125; System.out.println(); // getDeclaredFields():获取当前运行类中声明的属性。（不包含父类中声明的属性） Field[] declaredFields = clazz.getDeclaredFields(); for (Field f : declaredFields) &#123; System.out.println(f); &#125;&#125; getMethods(): 获取当前运行时类及其所父类中声明为 public 权限的方法 getDeclaredMethods():获取当前运行时类中声明的所方法。（不包含父类中声明的方法） 12345678910111213141516@Testpublic void test3()&#123; Class&lt;Person&gt; clazz = Person.class; //getMethods():获取当前运行时类及其所父类中声明为public权限的方法 Method[] methods = clazz.getMethods(); for (Method m : methods) &#123; System.out.println(m); &#125; System.out.println(&quot;***********************&quot;); //getDeclaredMethods():获取当前运行时类中声明的所方法。（不包含父类中声明的方法） Method[] declaredMethods = clazz.getDeclaredMethods(); for (Method f : declaredMethods) &#123; System.out.println(f); &#125;&#125; getConstructors(): 获取当前运行时类中声明为 public 的构造器 getDeclaredConstructors(): 获取当前运行时类中声明的所的构造器 1234567891011121314151617@Testpublic void test4()&#123; Class&lt;Person&gt; clazz = Person.class; //getConstructors():获取当前运行时类中声明为public的构造器 Constructor&lt;?&gt;[] constructors = clazz.getConstructors(); for (Constructor&lt;?&gt; c : constructors) &#123; System.out.println(c); &#125; System.out.println(&quot;**************************&quot;); //getDeclaredConstructors():获取当前运行时类中声明的所的构造器 Constructor&lt;?&gt;[] declaredConstructors = clazz.getDeclaredConstructors(); for (Constructor&lt;?&gt; d : declaredConstructors) &#123; System.out.println(d); &#125;&#125; getSuperclass()：获取运行时类的父类 123456@Testpublic void test5()&#123; Class&lt;Person&gt; clazz = Person.class; Class&lt;? super Person&gt; superclass = clazz.getSuperclass(); System.out.println(superclass);&#125; getGenericSuperclass()： 获取运行时类的带泛型的父类 123456@Testpublic void test6()&#123; Class&lt;Person&gt; clazz = Person.class; Type genericSuperclass = clazz.getGenericSuperclass(); System.out.println(genericSuperclass);&#125; 123456789@Testpublic void test7()&#123; Class&lt;Person&gt; clazz = Person.class; Type genericSuperclass = clazz.getGenericSuperclass(); ParameterizedType paramType = (ParameterizedType) genericSuperclass; // 获取泛型类型 Type[] actualTypeArguments = paramType.getActualTypeArguments(); System.out.println(((Class)actualTypeArguments[0]).getName());&#125; getInterfaces(): 获取运行时类实现的接口 123456789101112131415@Testpublic void test8()&#123; Class&lt;Person&gt; clazz = Person.class; Class&lt;?&gt;[] interfaces = clazz.getInterfaces(); for (Class&lt;?&gt; i : interfaces) &#123; System.out.println(i); &#125; System.out.println(&quot;****************&quot;); // 获取运行时类的父类实现接口 Class&lt;?&gt;[] interfaces1 = clazz.getSuperclass().getInterfaces(); for (Class&lt;?&gt; c : interfaces1) &#123; System.out.println(c); &#125; getPackage(): 获取运行时类所在的包 123456@Testpublic void test9()&#123; Class&lt;Person&gt; clazz = Person.class; Package pack = clazz.getPackage(); System.out.println(pack);&#125; getAnnotations(): 获取运行时类声明的注解 1234567@Testpublic void test10()&#123; Class&lt;Person&gt; clazz = Person.class; Annotation[] annotations = clazz.getAnnotations(); for (Annotation a : annotations) &#123; System.out.println(a); &#125; 六、反射应用三：调用运行时类的指定结构1、调用指定的属性123456789101112131415161718@Testpublic void test1() throws Exception &#123; Class&lt;Person&gt; clazz = Person.class; // 创建运行时类的对象 Person p = clazz.newInstance(); // 1. getDeclaredField(String fieldName):获取运行时类中指定变量名的属性 Field name = clazz.getDeclaredField(&quot;name&quot;); // 2. 保证当前属性是可访问的 name.setAccessible(true); // 3.获取、设置指定属性对象的此属性 name.set(p,&quot;Tom&quot;); System.out.println(name.get(p));&#125; 2、调用指定的方法123456789101112131415161718192021222324252627282930@Testpublic void test2() throws Exception &#123; Class&lt;Person&gt; clazz = Person.class; // 创建运行时类的对象 Person p = clazz.newInstance(); /* 1.获取指定的某个方法 getDeclaredMethod():参数1 ：指明获取的方法的名称 参数2：指明获取的方法的形参列表 */ Method show = clazz.getDeclaredMethod(&quot;show&quot;, String.class); // 2.保证当前方法时可访问的 show.setAccessible(true); /* 3. 调用方法的invoke():参数1：方法的调用者 参数2：给方法形参赋值的实参 invoke()的返回值即为对应类中调用的方法的返回值。 */ Object returnValue = show.invoke(p, &quot;CHN&quot;);//String nation = p.show(&quot;CHN&quot;); System.out.println(returnValue); System.out.println(&quot;********************&quot;); // private static void showDesc Method showDesc = clazz.getDeclaredMethod(&quot;showDesc&quot;); showDesc.setAccessible(true); // 如果调用的运行时类中的方法没返回值，则此invoke()返回null Object returnVal = showDesc.invoke(Person.class); System.out.println(returnVal);// null&#125; 3、调用指定的构造器123456789101112131415161718@Testpublic void test3() throws Exception &#123; Class&lt;Person&gt; clazz = Person.class; //private Person(String name) /* 1.获取指定的构造器 getDeclaredConstructor():参数：指明构造器的参数列表 */ Constructor&lt;Person&gt; constructor = clazz.getDeclaredConstructor(String.class); // 2.保证此构造器可访问的 constructor.setAccessible(true); // 3.调用此构造器创建运行时类的对象 Person per = constructor.newInstance(&quot;Tom&quot;); System.out.println(per);&#125; 七、反射应用四：动态代理1、代理模式的原理​ 使用一个代理将对象包装起来，然后用该代理对象去掉原始对象。任何对原始对象的调用都要通过代理。代理对象决定是否以及何时将方法调用转到原始对象上。 2、静态代理 举例 12345678实现Runnable接口的方法创建多线程。Class MyThread implements Runnable&#123;&#125;//相当于被代理类Class Thread implements Runnable&#123;&#125;//相当于代理类main()&#123; MyTread t = new MyThread(); Thread thread = new Thread(t); thresd.start();//启动线程；调用线程的run()&#125; 静态代理的缺点 代理类和目标对象的类都是在编译间确定下来的，不利于程序的扩展。 每一个代理类只能为一个接口服务，这样一来程序开发中必然产生过多的代理。 动态代理的特点 动态代理是指客户端通过代理类来调用其他对象的方法，并且是在程序运行时根据需要动态创建目标类的代理对象 3、动态代理的实现 需要解决的两个主要问题： 问题一：如何根据加载到内存中的被代理类，动态的创建一个代理类及其对象。（通过 Proxy.newProxyInstance()实现） 问题二：当通过代理类的对象调用方法 a 时，如何动态的去调用被代理类的同名方法 a。(通过 InvocationHandler 接口的实现类及其方法 invoke()) 代码示例 1234567interface Human&#123; String getBelief(); void eat(String food);&#125; 1234567891011121314//被代理类class SuperMan implements Human&#123; @Override public String getBelief() &#123; return &quot;I believe I can fly!&quot;; &#125; @Override public void eat(String food) &#123; System.out.println(&quot;我喜欢吃&quot; + food); &#125;&#125; 123456789101112class HumanUtil&#123; public void method1()&#123; System.out.println(&quot;====================通用方法一====================&quot;); &#125; public void method2()&#123; System.out.println(&quot;====================通用方法二====================&quot;); &#125;&#125; 1234567891011class ProxyFactory&#123; //调用此方法，返回一个代理类的对象。解决问题一 public static Object getProxyInstance(Object obj)&#123;//obj:被代理类的对象 MyInvocationHandler handler = new MyInvocationHandler(); handler.bind(obj); return Proxy.newProxyInstance(obj.getClass().getClassLoader(),obj.getClass().getInterfaces(),handler); &#125;&#125; 123456789101112131415161718192021222324252627class MyInvocationHandler implements InvocationHandler&#123; private Object obj;//需要使用被代理类的对象进行赋值 public void bind(Object obj)&#123; this.obj = obj; &#125; //当我们通过代理类的对象，调用方法a时，就会自动的调用如下的方法：invoke() //将被代理类要执行的方法a的功能就声明在invoke()中 @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; HumanUtil util = new HumanUtil(); util.method1(); //method:即为代理类对象调用的方法，此方法也就作为了被代理类对象要调用的方法 //obj:被代理类的对象 Object returnValue = method.invoke(obj,args); util.method2(); //上述方法的返回值就作为当前类中的invoke()的返回值。 return returnValue; &#125;&#125; 123456789101112131415161718192021public class ProxyTest &#123; public static void main(String[] args) &#123; SuperMan superMan = new SuperMan(); //proxyInstance:代理类的对象 Human proxyInstance = (Human) ProxyFactory.getProxyInstance(superMan); //当通过代理类对象调用方法时，会自动的调用被代理类中同名的方法 String belief = proxyInstance.getBelief(); System.out.println(belief); proxyInstance.eat(&quot;四川麻辣烫&quot;); System.out.println(&quot;*****************************&quot;); NikeClothFactory nikeClothFactory = new NikeClothFactory(); ClothFactory proxyClothFactory = (ClothFactory) ProxyFactory.getProxyInstance(nikeClothFactory); proxyClothFactory.produceCloth(); &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"http://blog.oy6090.top/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://blog.oy6090.top/tags/java%E5%9F%BA%E7%A1%80/"}]},{"title":"java之网络编程","slug":"java之网络编程","date":"2020-07-27T16:00:00.000Z","updated":"2021-01-22T03:52:59.170Z","comments":true,"path":"posts/17548.html","link":"","permalink":"http://blog.oy6090.top/posts/17548.html","excerpt":"","text":"一、InetAddress 类的使用1、实现网络通信需要解决的两个问题 如何准确的定位网络上一台或多台的主机;定位主机上的特定应用 找到主机后如何高效地进行数据传输 2、网络通信的两个要素 对应问题一：IP 和端口号 对应问题二：提供网络协议：TCP/IP 参考模型（应用层、传输层、网络层、物理+数据链路层） 3、通信要素一：IP 和端口号① IP 的解释 唯一的标识 Internet 上的计算机（通信载体） 在 Java 中使用 InternetAddress 类代表 IP IP 分类： IPV4 和 IPV6 ； 万维网 和 局域网 域名：www.baidu.com ; 域名解析：域名容易记忆。当在连接网络时输入一个主机的域名后，域名服务器（DNS）负责将域名转化为 IP 地址，这样才能和本地建立连接。– 域名解析 本地回路地址：127.0.0.1 对应着：localhost ② InetAddress 类 此类的一个对象就代表着一个具体的 IP 地址 实例化 1getByName(String host)、getLocalhost() 常用方法 1getHostName()/getHostAddress() 4、端口号要求：不同的进程不同的端口号 范围：被规定为一个 16 位的整数 0~65535 端口号与 IP 地址的组合得出一个网络套接字：Socket 5、通信要素二：网络通信协议① 分类模型 ② TCP 和 UDP 的区别 ③ TCP 三次握手和四次挥手 ④ 补充 12345678// geByName 确定主机名称的IP地址InetAddress.getByName(&quot;192.168.12.67&quot;);// 获取本地IPInetAddress.getLocalhost();// 获取此IP地址的主机名。inet2.getHostName()// 返回文本显示中的IP地址字符串inet2.getHostAddress() 二、TCP 网络编程代码示例：客户端发送信息给服务端，服务端将数据显示在控制台上 客户端： 1234567891011121314151617181920212223242526272829303132@Test public void client()&#123; Socket socket = null; OutputStream os = null; try &#123; // 1.创建Socket对象，指明服务器的ip和端口号 InetAddress inet = InetAddress.getByName(&quot;127.0.0.1&quot;); socket = new Socket(inet, 8899); // 获取一个输出流，用于输出数据 os = socket.getOutputStream(); os.write(&quot;你好，我是客户端&quot;.getBytes()); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; if(os != null)&#123; os.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; try &#123; if(socket != null)&#123; socket.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; 服务端： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162@Testpublic void Server()&#123; ServerSocket serverSocket = null; Socket socket = null; InputStream is = null; ByteArrayOutputStream baos = null; try &#123; // 1. 创建服务器=端的ServerSocket,指明自己的端口号 serverSocket = new ServerSocket(8899); // 2.调用accept()表示接口来自客户端的socket socket = serverSocket.accept(); // 3.获取输入流 is = socket.getInputStream(); // 4.读取输入流中的数据 baos = new ByteArrayOutputStream(); byte[] bt = new byte[1024]; int len; while((len = is.read(bt)) != -1)&#123; baos.write(bt, 0, len); &#125; System.out.println(baos.toString()); System.out.println(&quot;收到了来自：&quot;+socket.getInetAddress().getHostAddress()+&quot;的数据&quot;); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; if(serverSocket != null)&#123; serverSocket.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; try &#123; if(socket != null)&#123; socket.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; try &#123; if(is != null)&#123; is.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; try &#123; if(baos != null)&#123; baos.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 代码示例 2：客户端发送文件给服务端，服务端将文件保存在本地。 客户端： 1234567891011121314151617181920212223242526272829303132333435363738394041424344@Testpublic void client()&#123; Socket socket = null; OutputStream os = null; FileInputStream fis = null; try &#123; socket = new Socket(InetAddress.getByName(&quot;127.0.0.1&quot;), 8899); os = socket.getOutputStream(); fis = new FileInputStream(&quot;1.jpg&quot;); byte[] bt = new byte[1024]; int len; while((len = fis.read(bt)) != -1)&#123; os.write(bt, 0, len); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if(fis != null)&#123; try &#123; fis.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if(os != null)&#123; try &#123; os.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if(socket != null)&#123; try &#123; socket.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 服务端： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152@Testpublic void Server()&#123; ServerSocket ss = null; Socket socket = null; InputStream is = null; FileOutputStream fos = null; try &#123; ss = new ServerSocket(8899); socket = ss.accept(); is = socket.getInputStream(); fos = new FileOutputStream(new File(&quot;图片2.jpg&quot;)); byte[] bt = new byte[1024]; int len; while((len = is.read(bt)) != -1)&#123; fos.write(bt, 0,len); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if(ss != null)&#123; try &#123; ss.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if(socket != null)&#123; try &#123; socket.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if(is != null)&#123; try &#123; is.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if(fos != null)&#123; try &#123; fos.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 三、UDP 编程发送端： 123456789101112131415161718@Testpublic void sender()&#123; DatagramSocket socket = null; try &#123; socket = new DatagramSocket(); String str = &quot;我是UDP方式发送的导弹&quot;; byte[] data = str.getBytes(); InetAddress inet = InetAddress.getLocalHost(); DatagramPacket packet = new DatagramPacket(data, 0, data.length, inet, 9090); socket.send(packet); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; socket.close(); &#125;&#125; 接收端： 12345678910@Testpublic void receiver() throws IOException &#123; DatagramSocket socket = new DatagramSocket(9090); byte[] buffer = new byte[1024]; DatagramPacket packet = new DatagramPacket(buffer, 0, buffer.length); socket.receive(packet); System.out.println(new String(packet.getData(),0,packet.getLength()));&#125; 四、URL 编程1、URL(Uniform Resource Locator) 的理解​ 统一资源定位符，对应着互联网的某一资源地址 2、URL 的 5 个基本结构 http://localhost:8080/examples/beauty.jpg?username=Tom 协议 主机名 端口号 资源地址 参数列表 3、实例化1URL url = new URL(&quot;http://localhost:8080/examples/beauty.jpg?username=Tom&quot;); 4、常用方法 方法 描述 public String getProtocol() 获取该 URL 的协议名 public String getHost() 获取 URL 的主机名 public String getPort() 获取 URL 的端口号 public String getPath() 获取 URL 的文件路径 public String getFile() 获取 URL 的文件名 public String getQuery() 获取 URL 的查询名 五、可以读取、下载对应的 url 资源123456789101112131415161718192021222324252627282930313233343536373839404142434445public static void main(String[] args) &#123; HttpURLConnection urlConnection = null; InputStream is = null; FileOutputStream fos = null; try &#123; URL url = new URL(&quot;http://localhost:8080/examples/beauty.jpg&quot;); urlConnection = (HttpURLConnection) url.openConnection(); urlConnection.connect(); is = urlConnection.getInputStream(); fos = new FileOutputStream(&quot;day10\\\\beauty3.jpg&quot;); byte[] buffer = new byte[1024]; int len; while((len = is.read(buffer)) != -1)&#123; fos.write(buffer,0,len); &#125; System.out.println(&quot;下载完成&quot;); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; //关闭资源 if(is != null)&#123; try &#123; is.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if(fos != null)&#123; try &#123; fos.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if(urlConnection != null)&#123; urlConnection.disconnect(); &#125; &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"http://blog.oy6090.top/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://blog.oy6090.top/tags/java%E5%9F%BA%E7%A1%80/"}]},{"title":"Spring5之事务的操作","slug":"Spring5之事务的操作","date":"2020-07-26T16:00:00.000Z","updated":"2020-10-25T02:24:00.236Z","comments":true,"path":"posts/2817363972.html","link":"","permalink":"http://blog.oy6090.top/posts/2817363972.html","excerpt":"","text":"一、事务的操作（事务的概念）1、事务 事务是数据库操作的基本单元，逻辑上的一组操作，要么都成功，如果一个失败所有的操作都失败 典型场景：银行转账 lucy 转账 100 元 给 mary lucy 少 100 ， mary 多 100 2、事物四个特征（ACID） 原子性 一致性 隔离性 持久性 二、事务操作（搭建事务操作环境） 1、创建数据库表，添加记录 2、创建 service, 搭建 dao, 完成对象的创建和注入关系 service 注入 dao, 在 dao 注入 Jdbctemplate, 在 JdbcTemplate 注入 DataSource 123456789101112@Servicepublic class UserService &#123; //注入 dao @Autowired private UserDao userDao;&#125;@Repositorypublic class UserDaoImpl implements UserDao &#123; @Autowiredprivate JdbcTemplate jdbcTemplate;&#125; 3、在到创建两个方法：多钱和少钱的方法，在 service 创建方法（转账的方法）1234567891011121314151617@Repositorypublic class UserDaoImpl implements UserDao&#123; @Autowired private JdbcTemplate jdbcTemplate; @Override public void reduceMoney() &#123; String sql = &quot;update t_account set money=money-? where username=?&quot;; jdbcTemplate.update(sql, 100, &quot;lucy&quot;); &#125; @Override public void addMoney() &#123; String sql = &quot;update t_account set money = money + ? where username = ?&quot;; jdbcTemplate.update(sql, 100, &quot;mary&quot;); &#125;&#125; 123456789101112131415@Servicepublic class UserService &#123; // 注入dao @Autowired private UserDao userDao; // 转账的方法 public void accountMoney()&#123; //lucy 少 100 userDao.reduceMoney(); //mary 多 100 userDao.addMoney(); &#125;&#125; 4、模拟异常123456789101112131415161718@Servicepublic class UserService &#123; // 注入dao @Autowired private UserDao userDao; // 转账的方法 public void accountMoney()&#123; //lucy 少 100 userDao.reduceMoney(); //模拟异常 int i = 10/0; //mary 多 100 userDao.addMoney(); &#125;&#125; 三、事务的操作（Spring 事务管理介绍）1、事务添加到 JavaEE 三层结构里面 Service 层（业务逻辑层） 2、在 Spring 进行事务管理的操作 有两种方式：编程式事务管理和声明式事务管理（使用） 3、声明式事务管理 基于注解方式（使用） 基于 xml 配置文件方式 4、在 Spring 进行声明式事务管理，底层使用 AOP 原理 5、Spring 事务管理 API 提供一个接口，代表事务管理器，这个接口针对不同的框架提供不用的实现类 四、事务操作（注解声明式事务管理）1、在 Spring 配置文件配置事务管理器12345&lt;!--创建事务管理器--&gt;&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;!--注入数据源--&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;&lt;/bean&gt; 2、在 Spring 配置文件，开启事务注解 在 Spring 配置文件引入名称空间 tx xmlns:tx=”http://www.springframework.org/schema/tx&quot; 12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt; 开启事务的注解 12&lt;!--开启事务注解--&gt;&lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;&gt;&lt;/tx:annotation-driven&gt; 3、在 service 类上面（或者 service 类里面方法上面）添加事务注解 @Transactional, 这个注解添加到类上，也可以添加到方法上面 如果把这个注解添加类上面，这个类里面 所有的方法都添加事务 如果把这个注解添加方法上面，为这个方法添加事务 123@Service@Transactionalpublic class UserService &#123; 五、事务操作（声明式事务管理参数配置）1、在 service 类上面添加注解@Transactional,在这个注解里面可以配置事务相关参数 2、propagation: 事务传播行为​ （1）多事务方法直接进行调用以及管理 事务传播行为可以由传播属性指定。Spring 定义了 7 种类传播行为 123@Service@Transactional(propagation = Propagation.REQUIRED)public class UserService &#123; 3、ioslation: 事务的隔离级别 事务有特征成为隔离性，多事务操作之间不会产生影响。不考虑隔离性产生很多问题 有三个读问题：脏读、不可重复读、虚（幻）读 脏读：一个未提交事务读取到另一个未提交事务的数据 不可重复读：一个未提交的事务读取到另一个提交事务修改数据 虚读：一个未提交事务读取到另一个提交事务添加数据 解决：通过设置事务的隔离级别，解决读的问题 123@Service@Transactional(propagation = Propagation.REQUIRED,isolation = Isolation.REPEATABLE_READ)public class UserService &#123; 4、timeout：超时时间 事务需要在一定时间内进行提高，如果不提交进行回滚。 ，默认设置是：-1，设置时间以秒单位进行计算 5、readOnly: 是否只读 读：查询操作, 写：添加修改删除操作 readOnly 默认值 false,表示可以查询，可以添加修改删除操作 设置 readOnly 值是 true,设置成 true 之后，只能查询 6、rollbackFor: 回滚 设置出现哪些异常进行事务的回滚 7、noRollbackFor: 不回滚 设置出现哪些异常不进行事务回滚 六、事务操作（XML 声明式事务管理）1、在 Spring 配置文件中进行配置 ​ 第一步 配置事务管理器 ​ 第二步 配置通知 ​ 第三步 配置切入点和切面 123456789101112131415161718192021&lt;!--1 创建事务管理器--&gt;&lt;bean id=&quot;transactionManager&quot;class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;!--注入数据源--&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!--2 配置通知--&gt;&lt;tx:advice id=&quot;txadvice&quot;&gt; &lt;!--配置事务参数--&gt; &lt;tx:attributes&gt; &lt;!--指定哪种规则的方法上面添加事务--&gt; &lt;tx:method name=&quot;accountMoney&quot; propagation=&quot;REQUIRED&quot;/&gt; &lt;!--&lt;tx:method name=&quot;account*&quot;/&gt;--&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt;&lt;!--3 配置切入点和切面--&gt;&lt;aop:config&gt; &lt;!--配置切入点--&gt; &lt;aop:pointcut id=&quot;pt&quot; expression=&quot;execution(*com.atguigu.spring5.service.UserService.*(..))&quot;/&gt; &lt;!--配置切面--&gt; &lt;aop:advisor advice-ref=&quot;txadvice&quot; pointcut-ref=&quot;pt&quot;/&gt;&lt;/aop:config&gt; 七、事务操作（完全注解声明式事务管理）123456789101112131415161718192021222324252627282930313233@Configuration // 配置类@ComponentScan(basePackages = &quot;com.oy.online.Spring&quot;)// 组件扫描@EnableTransactionManagement // 开启事务public class TxConfig &#123; // 创建数据库连接池 @Bean public DruidDataSource getDruidSource()&#123; DruidDataSource dataSource = new DruidDataSource(); dataSource.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;); dataSource.setUrl(&quot;jdbc:mysql:///user_db&quot;); dataSource.setUsername(&quot;root&quot;); dataSource.setPassword(&quot;root&quot;); return dataSource; &#125; // 创建JdbcTemplate对象 @Bean public JdbcTemplate getJdbcTemplate(DataSource dataSource)&#123; // 到ioc容器中根据类型找到dataSource JdbcTemplate jdbcTemplate = new JdbcTemplate(); // 注入dataSource jdbcTemplate.setDataSource(dataSource); return jdbcTemplate; &#125; // 创建事务管理器 @Bean public DataSourceTransactionManager dataSourceTransactionManager(DataSource dataSource)&#123; DataSourceTransactionManager transactionManager = new DataSourceTransactionManager(); transactionManager.setDataSource(dataSource); return transactionManager; &#125;&#125;","categories":[{"name":"JavaEE框架","slug":"JavaEE框架","permalink":"http://blog.oy6090.top/categories/JavaEE%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"java","slug":"java","permalink":"http://blog.oy6090.top/tags/java/"},{"name":"Spring","slug":"Spring","permalink":"http://blog.oy6090.top/tags/Spring/"}]},{"title":"Spring5之JdbcTemplate","slug":"Spring5之JdbcTemplate","date":"2020-07-25T16:00:00.000Z","updated":"2020-10-25T02:24:12.348Z","comments":true,"path":"posts/1762820479.html","link":"","permalink":"http://blog.oy6090.top/posts/1762820479.html","excerpt":"","text":"一、JdbcTemplate(概念和准备)1、JdbcTemplate​ Spring 框架对 jdbc 进行封装， 使用 JdbcTemPlate 方便实现对数据库操作 2、过程准备 引入相关 jar 包 在 spring 配置文件配置数据库连接池 1234567&lt;!--数据库连接池--&gt;&lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot; destroy-method=&quot;close&quot;&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql:///user_db&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;6090&quot;/&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;&lt;/bean&gt; 配置 JdbcTemplate 对象，注入 DataSource 12345&lt;!--JdbcTemplate对象--&gt;&lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; &lt;!--注入 dateSource--&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;&lt;/bean&gt; 创建 service 类，创建 dao 类，在 dao 注入 jdbcTemplate 对象 配置文件 12&lt;!--组件扫描--&gt;&lt;context:component-scan base-package=&quot;com.oy.online.Spring&quot;&gt;&lt;/context:component-scan&gt; Service 1234567@Servicepublic class BookService &#123; // 注入dao @Autowired private BookDao bookDao;&#125; Dao 1234567@Repositorypublic class BookDaoImpl implements BookDao &#123; // 注入 JdbcTemplate @Autowired private JdbcTemplate jdbcTemplate;&#125; 二、JdbcTemplate 操作数据库（添加）1、对应数据库创建实体类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class Book &#123; private String userId; private String username; private String ustatus; public User() &#123; &#125; public User(String userId, String username, String ustatus) &#123; this.userId = userId; this.username = username; this.ustatus = ustatus; &#125; public String getUserId() &#123; return userId; &#125; public void setUserId(String userId) &#123; this.userId = userId; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getUstatus() &#123; return ustatus; &#125; public void setUstatus(String ustatus) &#123; this.ustatus = ustatus; &#125; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;userId=&#x27;&quot; + userId + &#x27;\\&#x27;&#x27; + &quot;, username=&#x27;&quot; + username + &#x27;\\&#x27;&#x27; + &quot;, ustatus=&#x27;&quot; + ustatus + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; 2、编写 service 和 dao 在 dao 进行数据库添加操作 调用 JdbcTemplate 对象里面 update 方法实现添加操作 第一个参数： sql 语句 第二个参数： 可变参数，设置 sql 语句值 123456789101112131415161718@Repositorypublic class BookDaoImpl implements BookDao &#123; // 注入 JdbcTemplate @Autowired private JdbcTemplate jdbcTemplate; // 添加方法 @Override public void add(Book book) &#123; // 1.创建sql语句 String sql = &quot;insert into t_book values(?,?,?)&quot;; // 2.调用方法实现 Object[] args = &#123;book.getUserId(), book.getUsername(), book.getUstatus()&#125;; jdbcTemplate.update(sql, args); &#125;&#125; 3、测试类12345678@Testpublic void jdbcTemplateTest()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean1.xml&quot;); BookService bookService = context.getBean(&quot;bookService&quot;, BookService.class); Book book = new Book(&quot;1&quot;, &quot;Java&quot;, &quot;a&quot;); bookService.addBook(book);&#125; 三、JdbcTemplate 操作数据库（修改和删除）1、修改12345678// 修改@Overridepublic void updateBook(Book book) &#123; String sql = &quot;update t_book set username=?, ustatus=? where user_id=?&quot;; Object[] args = &#123;book.getUsername(), book.getUstatus(), book.getUserId()&#125;; int update = jdbcTemplate.update(sql, args); System.out.println(update);&#125; 2、删除123456@Override public void deletes(String id) &#123; String sql = &quot;delete from t_book where user_id=?&quot;; int update = jdbcTemplate.update(sql, id); System.out.println(update); &#125; 四、JdbcTemplate 操作数据库（查询返回某个值）1、查询表里面有多少条记录，返回是某个值 2、使用 JdbcTemplate 实现查询返回某个值代码 第一个参数： sql 语句 第二个参数：返回类型 Class 123456@Overridepublic int selectCountBook() &#123; String sql = &quot;select count(*) from t_book&quot;; Integer count = jdbcTemplate.queryForObject(sql, Integer.class); return count;&#125; 五、JdbcTemplate 操作数据库（查询返回对象）1、场景：查询图书详情 2、JdbcTemplate 实现查询返回对象 第一个参数：sql 语句 第二个参数： RowMapper 是接口，针对返回不同的类型数据，使用这个接口里面实现类完成数据封装 第三个参数：sql 语句的值 1234567// 查询返回对象@Overridepublic Book findBookInfo(String id) &#123; String sql = &quot;select * from t_book where user_id = ?&quot;; Book book = jdbcTemplate.queryForObject(sql, new BeanPropertyRowMapper&lt;Book&gt;(Book.class),id); return book;&#125; 六、JdbcTemplate 操作数据库（查询返回集合）1、场景：查询图书列表分页 2、调用 JdbcTemplate 方法实现查询返回集合 第一个参数： sql 语句 第二个参数：RowMapper 是接口，针对返回不同类型数据，使的这个接口里面实现类完成数据封装 第三个参数：sql 语句 1234567@Overridepublic List&lt;Book&gt; findAllBook() &#123; String sql = &quot;select * from t_book&quot;; // 调用方法 List&lt;Book&gt; list = jdbcTemplate.query(sql, new BeanPropertyRowMapper&lt;Book&gt;(Book.class)); return list;&#125; 七、JdbcTemplate 操作数据库（批量操作）1、批量操作：操作表里面的多条记录 2、JdbcTemplate 实现批量添加操作 第一个参数： sql 语句 第二个参数： List 集合，添加多条记录数据 批量添加 123456@Override public void batchAddBook(List&lt;Object[]&gt; batchArgs) &#123; String sql = &quot;insert into t_book value(?,?,?)&quot;; int[] ints = jdbcTemplate.batchUpdate(sql, batchArgs); System.out.println(ints); &#125; 测试： 123456789List&lt;Object[]&gt; batchArgs = new ArrayList&lt;&gt;();Object[] o1 = &#123;&quot;3&quot;,&quot;java&quot;,&quot;a&quot;&#125;;Object[] o2 = &#123;&quot;4&quot;,&quot;c++&quot;,&quot;b&quot;&#125;;Object[] o3 = &#123;&quot;5&quot;,&quot;MySQL&quot;,&quot;c&quot;&#125;;batchArgs.add(o1);batchArgs.add(o2);batchArgs.add(o3);//调用批量添加bookService.bacthAdd(batchArgs); 3、JDBCTemplate 实现批量修改操作 123456@Overridepublic void batchUpdateBook(List&lt;Object[]&gt; batchArgs) &#123; String sql = &quot;update t_book set username=?,ustatus=? where user_id=?&quot;; int[] ints = jdbcTemplate.batchUpdate(sql, batchArgs); System.out.println(Arrays.toString(ints));&#125; 测试： 123456789List&lt;Object[]&gt; batchArgs = new ArrayList&lt;&gt;();Object[] o1 = &#123;&quot;java0909&quot;,&quot;a3&quot;,&quot;3&quot;&#125;;Object[] o2 = &#123;&quot;c++1010&quot;,&quot;b4&quot;,&quot;4&quot;&#125;;Object[] o3 = &#123;&quot;MySQL1111&quot;,&quot;c5&quot;,&quot;5&quot;&#125;;batchArgs.add(o1);batchArgs.add(o2);batchArgs.add(o3);//调用方法实现批量修改bookService.batchUpdate(batchArgs); 4、JdbcTemplate 实现批量删除操作 1234567// 批量删除@Overridepublic void batchdeleteBook(List&lt;Object[]&gt; batchArgs) &#123; String sql = &quot;delete from t_book where user_id = ?&quot;; int[] ints = jdbcTemplate.batchUpdate(sql, batchArgs); System.out.println(Arrays.toString(ints));&#125; 测试： 1234567//批量删除List&lt;Object[]&gt; batchArgs = new ArrayList&lt;&gt;();Object[] o1 = &#123;&quot;3&quot;&#125;;Object[] o2 = &#123;&quot;4&quot;&#125;;batchArgs.add(o1);batchArgs.add(o2);//调用方法实现批量删除bookService.batchDelete(batchArgs);","categories":[{"name":"JavaEE框架","slug":"JavaEE框架","permalink":"http://blog.oy6090.top/categories/JavaEE%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"java","slug":"java","permalink":"http://blog.oy6090.top/tags/java/"},{"name":"Spring","slug":"Spring","permalink":"http://blog.oy6090.top/tags/Spring/"}]},{"title":"Java之IO流","slug":"Java之IO流","date":"2020-07-24T16:00:00.000Z","updated":"2021-01-21T11:04:36.714Z","comments":true,"path":"posts/2120368839.html","link":"","permalink":"http://blog.oy6090.top/posts/2120368839.html","excerpt":"","text":"一、File 类的使用1、File 类的理解​ ① File 类的一个对象，代表一个文件或文件目录（俗称：文件夹） ​ ② File 类声明的砸 Java.io 包下 ​ ③ File 类中涉及关于文件或文件目录的创建、删除、重命名、修改时间、文件大小等方法，并涉及到写入的读取文件内容的操作。如果需要读取或写入的 ”终点“。 2、File 的实例化常用的构造器 123File(String filePath)File(String parenPath, String childPath)File(File parenFile, String childPath) 路径的分类 12相对路径：相对某个路径，指明的路径绝对路径：包含盘符在内的文件或文件目录的路径 路径分隔符 12windows 和 DOC 系统的默认使用“\\”来表示UNIX 和 URL 使用“/” 来表示 二、流的分类1、流的分类 操作数据的单位：字节流、字符流 数据的流向：输入流、输出流 流的角色：节点流、处理流 图示： 2、流的体系结构 说明： 红框对应的是 IO 流中的 4 个抽象基类。 3、输入、输出的标准化过程① 输入过程 创建 File 类的对象，指明读取数据的来源。（要求此文件一定存在） 创建相对应的输入流，将 File 类的对象作为参数，传入流的构造器中 具体的读入过程：创建相对应的 byte[ ] 或 char[ ] 关闭流资源 说明： 程序中出现的异常需要使用 try-catch-finally 处理。 ② 输入过程 创建 File 类对象，指明写出的数据的位置。(不要求此文件一定存在) 创建相对应的输出流，将 File 类的对象作为参数，传入流的构造器中。 具体的写入过程：write(byte[ ] 或 char[ ], 0, len) 关闭流资源 说明：程序中出现的异常需要使用 try-catch-finally 处理。 三、节点流（或文件流）1、FileReader/FileWirter 的使用① FileReader 的使用 read() 的理解：返回读入的一个字符。如果达到文件的末尾。返回-1 异常的处理：为了保证流的资源一定可以执行关闭操作。需要使用 try-catch-finally 处理 读入的文件一定要存在，否则就会报 FileNotExcption。 123456789101112131415161718192021222324252627282930@Testpublic void test() &#123; FileReader fr = null; try &#123; // 1. File的实例化 File file = new File(&quot;hello.txt&quot;); // 2.FileReader流的实例化 fr = new FileReader(file); // 3.读入的操作 // read(char[] ch):返回每次读入ch数组中的字符的个数。如果达到文件末尾 char[] ch = new char[1024]; int len; while((len = fr.read(ch)) != -1)&#123; String str = new String(ch, 0, len); System.out.println(str); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; if(fr != null)&#123; fr.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; ② FileWrite 的使用 输出操作，对应的 File 可以不存在的。并不会报异常 File 对应的硬盘中文件如果不存在，在输出的过程中，会自动创建此文件。 File 对应的硬盘中文件如果存在： ​ 如果流使用的构造器是：FileWriter(file, false)/ FileWriter(file): 对原文件的覆盖 ​ 如果流使用的构造器是：FileWriter(file,true): 不会对原文件覆盖，而是原文件基础上追加内容 1234567891011121314151617181920212223242526@Testpublic void test2() &#123; FileWriter fw = null; try &#123; // 1.提供File类的对象，指明写出到文件 File file = new File(&quot;hello.txt&quot;); // 2.提供FileWriter的对象，用于数据写出 fw = new FileWriter(file, false); // 3.写出的操作 fw.write(&quot;I have a dream!\\n&quot;); fw.write(&quot;you need to have a dream!&quot;); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; // 4.流资源关闭 try &#123; if (fw != null)&#123; fw.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; ③ 文本文件复制 12345678910111213141516171819202122232425262728293031323334353637383940414243@Testpublic void test3()&#123; FileReader fr = null; FileWriter fw = null; try &#123; // 1.创建File类的对象，指明读入和写入文件 File srcfile = new File(&quot;hello.txt&quot;); File dsrcfile1 = new File(&quot;hello1.txt&quot;); // 2.创建输入流和输出流 fr = new FileReader(srcfile); fw = new FileWriter(dsrcfile1); // 数据的读写和写入操作 char[] ch = new char[1024]; // 记录每次读入到ch数组中的字符串的个数 int len; while((len = fr.read(ch)) != -1)&#123; // 每次写出len个字符 fw.write(ch,0,len); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; // 4. 关闭流资源 try &#123; if(fw != null)&#123; fw.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; try &#123; if(fr != null)&#123; fr.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 2、FileInputStream / FileOutputStream 的使用 对于文本文件（**.txt**, .java, .c, .cpp）, 使用字符流处理 对于非文本文件（**.jpg** , .mp3, .mp4, .avi, .doc, .ppt），使用字节流处理 1234567891011121314151617181920212223242526272829303132333435363738394041@Testpublic void test1()&#123; FileInputStream fis = null; FileOutputStream fos = null; try &#123; // 1. 造文件 File srcfile = new File(&quot;图片.jpg&quot;); File desrfile = new File(&quot;图片2.jpg&quot;); // 2.造流 fis = new FileInputStream(srcfile); fos = new FileOutputStream(desrfile); // 3.复制的过程 byte[] bt = new byte[1024]; int len; while((len = fis.read(bt)) != -1)&#123; fos.write(bt,0,len); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; if(fis != null)&#123; fis.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; try &#123; if(fos != null)&#123; fos.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 【注意】 IDEA： 如果使用单元测试方法，相对路径当前 Module 的。 如果使用 main() 测试，相对路径基于当前 Project 的。 Eclipes： 单元测试方法还是 main(), 相对路径都是基于当前 Project 的。 四、缓冲流1、缓冲流涉及到的类 BufferedInputStream BufferedOutputStream BufferedReader BufferedWriter 2、作用作用：提高流的读取、写入的速度 提高读写速度的原因：内部提供了一个缓冲区。默认情况下是 8kb 3、代码演示① 使用 BufferadInputStream 和 BufferadOutputStream ：处理非文本 12345678910111213141516171819202122232425262728293031323334353637383940@Test public void test1()&#123; BufferedInputStream bis = null; BufferedOutputStream bos = null; try &#123; // 1.造文件 File srcfile = new File(&quot;图片.jpg&quot;); File dsrcfile = new File(&quot;图片3.jpg&quot;); // 2.造流 // 2.1节点流 FileInputStream fis = new FileInputStream(srcfile); FileOutputStream fos = new FileOutputStream(dsrcfile); // 2.2 节点流 bis = new BufferedInputStream(fis); bos = new BufferedOutputStream(fos); // 3.复制的细节：读取、写入 byte[] bt = new byte[1024]; int len; while((len = bis.read(bt)) != -1)&#123; bos.write(bt, 0, len); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; // 4. 关闭资源 try &#123; bos.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; try &#123; bis.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; ② 使用 BufferedReader 和 BufferedWriter：处理文本文件 12345678910111213141516171819202122232425262728293031323334353637@Test public void test2()&#123; BufferedReader br = null; BufferedWriter bw = null; try &#123; File srcfile = new File(&quot;hello.txt&quot;); File dsrcfile = new File(&quot;hello3.txt&quot;); // 造流 br = new BufferedReader(new FileReader(srcfile)); bw = new BufferedWriter(new FileWriter(dsrcfile)); // 3. 读取 // 第一种方式 String data; while((data = br.readLine()) != null)&#123; // data中不包含换行符 bw.write(data); // 提供换行符 bw.newLine(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; // 4. 关闭流资源 try &#123; br.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; try &#123; bw.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; 1234567//读取的第二种方式char[] cbuf = new char[1024];int len;while((len = br.read(cbuf)) != -1)&#123; bw.write(cbuf,0,len); bw.flush();&#125; 五、转换流1、转换流涉及到的类：属于字符流 InputStreamReader: 将一个字节的输入转换为字符的输入流 解码：字节、字节组 –&gt; 字符数组、字符串 OutputStreamWriter: 将一个字符的输入流转换字节的输出流 编码：字符数组、字符串 –&gt; 字节、字节数组 说明：编码决定了解码的的方式 2、方式提供字节流与字符流之间的转换 3、图示 4、典型案例123456789101112131415161718192021222324252627@Testpublic void test1() &#123; InputStreamReader isr = null; try &#123; FileInputStream fis = new FileInputStream(&quot;hello.txt&quot;); isr = new InputStreamReader(fis, &quot;UTF-8&quot;); char[] ch = new char[1024]; int len; while((len = isr.read(ch)) != -1)&#123; String str = new String(ch, 0, len); System.out.println(str); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; if (isr != null)&#123; isr.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 处理异常使用 try-catch 综合使用 InputStreamReader 和 OutputStreamWriter 123456789101112131415161718192021222324252627282930313233343536373839404142@Testpublic void test2() &#123; InputStreamReader isr = null; OutputStreamWriter osw = null; try &#123; // 1.造文件、造流 File file1 = new File(&quot;hello.txt&quot;); File file2 = new File(&quot;hello_gbk.txt&quot;); FileInputStream fis = new FileInputStream(file1); FileOutputStream fos = new FileOutputStream(file2); isr = new InputStreamReader(fis, &quot;UTF-8&quot;); osw = new OutputStreamWriter(fos, &quot;gbk&quot;); // 2.读写过程 char[] ch = new char[1024]; int len; while((len = isr.read(ch)) != -1)&#123; osw.write(ch, 0, len); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; if(isr != null)&#123; isr.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; try &#123; if(osw != null)&#123; osw.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 六、对象流1、对象流 ObjectInputStream 和 ObjectOutputStream 2、作用ObjectInputStream: 内存中的对象 –&gt; 存储中的文件、通过网路传输过去：序列化过程 ObjectOutputStream: 存储中文件、通过网络接收过来 –&gt; 内存中的对象：反序列化的过程 3、对象的序列化机制 对象序列化机制允许把内存中的 Java 对象转换成平台无关的二进制流，从而允许把这二进制流持久保存在硬盘上，或通过网路将这种二进制流输入到另一个网络节点 当其他程序获取到这种二进制流，就可以恢复原来的 java 对象 4、序列化代码创建 Person 类(实现 Serializable 接口，添加序列号)： 12345678910111213141516171819202122232425262728293031323334353637383940public class Person implements Serializable &#123; /** * 序列号 */ public static final long serialVersionUID = 475463534532L; private String name; private int id; public Person() &#123; &#125; public Person(String name, int id) &#123; this.name = name; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; @Override public String toString() &#123; return &quot;Person&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, id=&quot; + id + &#x27;&#125;&#x27;; &#125;&#125; 1234567891011121314151617181920212223@Test public void test1() &#123; ObjectOutputStream oos = null; try &#123; oos = new ObjectOutputStream(new FileOutputStream(&quot;object.dat&quot;)); oos.writeObject(new String(&quot;你好&quot;)); oos.flush();//刷新操作 oos.writeObject(new Person(&quot;小明&quot;,23)); oos.flush(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; if (oos != null)&#123; oos.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; 5、反序列化代码123456789101112131415161718192021222324252627@Testpublic void test2()&#123; ObjectInputStream ois = null; try &#123; ois = new ObjectInputStream(new FileInputStream(&quot;object.dat&quot;)); Object obj = ois.readObject(); String str = (String) obj; Person p = (Person) ois.readObject(); System.out.println(str); System.out.println(p); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; if (ois != null)&#123; ois.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 6、实现序列化的对象所属的类需要满足： 需要实现接口：Serializable 当前类提供一个全局常量：SeriaVersionUID 除了当前 Person 类需要实现 Serializable 接口之外，还需要保证其内部类所属性也必须是可序列化。(默认情况下，基本数据类型可序列化) ObjectOutputStream 和 ObjectInputStream 不能序列化 static 修饰的成员变量。 七、其他流的使用1、标准输入输出流 System.in : 标准的输入流，默认从键盘输入 System.out : 标准的输出流，默认从控制台输出 修改默认的输入和输出行为： ​ System 类的 setIn(InputStream is) / setOut(prinStream ps) 方式重新指定输入和输出流。 2、打印流 PrinStream 和 PrintWriter 说明： 提供一系列重载的 print()的方法，用于多种数据类型的输出 System.out 返回的是 PrintStream 的实例 3、数据流 DataInputStream 和 DataOutputStream 作用：用于读取或写出基本数据类型的变量或字符串 实例 1：将内存中的字符串、基本数据类型的变量写到文件中。 12345678910111213141516171819202122232425262728 @Test public void test1()&#123;// DataInputStream dis = new DataInputStream(new FileInputStream(&quot;hello.txt&quot;)); DataOutputStream dos = null; try &#123; dos = new DataOutputStream(new FileOutputStream(&quot;data.txt&quot;)); dos.writeUTF(&quot;OY&quot;); // 刷新操作，将内存中的数据写入文件 dos.flush(); dos.writeInt(19); dos.flush(); dos.writeBoolean(true); dos.flush(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; if(dos != null)&#123; dos.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; 实例 2：将文件中存储的基本数据类型变量和字符串读取到内存中，保存在变量中。 12345678910111213141516171819202122232425@Testpublic void test2() &#123; DataInputStream dis = null; try &#123; dis = new DataInputStream(new FileInputStream(&quot;data.txt&quot;)); String name = dis.readUTF(); int age = dis.readInt(); Boolean isMale = dis.readBoolean(); System.out.println(&quot;name=&quot; + name); System.out.println(&quot;age=&quot; + age); System.out.println(&quot;isMale=&quot; + isMale); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; if(dis != null)&#123; dis.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 八、RandomAccesFile 的使用1、随机存储文件流 RondomAccessFile 直接继承于 java.Object 类，实现 DataInput 和 DataOutput 接口 RandomAccessFile 既可以作为输入流，又可以作为一个输出流 如果 RandomAccessFile 作为输出流时，写出到的文件如果不存在，则在执行的过程中自动创建。 如果写出到的文件存在，则也对原文件内容进行覆盖。（默认情况下，从头覆盖） 可以通过相关的操作，实现 RandomAccessFile”插入”数据的效果。seek（int pos）。 1234567891011121314151617181920212223242526272829303132333435@Testpublic void test1()&#123; RandomAccessFile raf1 = null; RandomAccessFile raf2 = null; try &#123; raf1 = new RandomAccessFile(new File(&quot;图片.jpg&quot;), &quot;r&quot;); raf2 = new RandomAccessFile(new File(&quot;图片4.jpg&quot;), &quot;rw&quot;); byte[] bt = new byte[1024]; int len; while((len = raf1.read(bt)) != -1)&#123; raf2.write(bt, 0, len); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; if (raf1 != null)&#123; raf1.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; try &#123; if (raf2 != null)&#123; raf2.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"http://blog.oy6090.top/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://blog.oy6090.top/tags/java%E5%9F%BA%E7%A1%80/"}]},{"title":"Java集合之Collections工具类","slug":"Java集合之Collections工具类","date":"2020-07-23T16:00:00.000Z","updated":"2021-01-22T03:50:56.903Z","comments":true,"path":"posts/12372.html","link":"","permalink":"http://blog.oy6090.top/posts/12372.html","excerpt":"","text":"一、Collections 工具类作用：操作 colleaction 和 Map 的工具类 二、常用方法 方法 描述 reverse(List) 反转 List 中元素的顺序 shuffle(List) 对 List 集合元素进行随机排序 sort(List) 根据元素的自然顺序对指定 List 集合元素升序排序 sort(List，Comparator) 根据指定的 Comparator 产生的顺序对 List 集合元素进行排序 swap(List，int， int) 将指定 list 集合中的 i 处元素和 j 处元素进行交换 Object max(Collection) 根据元素的自然顺序，返回给定集合中的最大元素 Object max(Collection，Comparator) 根据 Comparator 指定的顺序，返回给定集合中的最大元素 Object min(Collection) 根据元素的自然顺序，返回给定集合中的最小元素 Object min(Collection，Comparator) 根据 Comparator 指定的顺序，返回给定集合中的最小元素 int frequency(Collection，Object) 返回指定集合中指定元素的出现次数 void copy(List dest,List src) 将 src 中的内容复制到 dest 中 boolean replaceAll(List list，Object oldVal，Object newVal) 使用新值替换 List 对象的所旧值 注：copy 特别注意 123456789101112@Testpublic void test1()&#123; List list = new ArrayList(); list.add(123); list.add(43); list.add(765); list.add(-97); list.add(0); List list1 = Arrays.asList(new Object[list.size()]); Collections.copy(list1,list); System.out.println(list1);&#125; 说明： ArrayList 和 HashMap 都是线程不安全的，如果程序要求线程安全，我们可以将 ArrayList、HashMap 转换为线程的。 使用： sysnchronizedList(List list) 和 sysnchronizedMap(Map map) 123//返回的list1即为线程安全的List List list = new ArrayList();List list1 = Collections.synchronizedList(list);","categories":[{"name":"java","slug":"java","permalink":"http://blog.oy6090.top/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://blog.oy6090.top/tags/java%E5%9F%BA%E7%A1%80/"}]},{"title":"Spring5之AOP","slug":"Spring5之AOP","date":"2020-07-23T16:00:00.000Z","updated":"2020-10-25T02:25:02.412Z","comments":true,"path":"posts/1738458658.html","link":"","permalink":"http://blog.oy6090.top/posts/1738458658.html","excerpt":"","text":"一、AOP（概念）（1）面向切面编程（方面），利用 AOP 可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分的耦合度降低，提高程序的可重用性，同时提高了开发的效率。 （2）通俗的描述：不通修改源代码方式，在主功能里面添加新功能 （3）使用登录例子说明 AOP 图示： 二、AOP (底层原理)1、AOP 底层使用动态代理（1）有两种情况动态代理 ​ 第一种 有接口情况，使用 JDK 动态代理 创建接口实现类代理对象，增强类的方法 第二种没有接口情况，使用 CGLIB 动态代理 创建子类代理对象，增强类的方法 三、AOP(JDK 动态代理)1、使用 JDK 动态代理，使用 Proxy 类里面的方法创建代理对象 （1）调用 newProxyInstance 方法 方法有三个参数： 第一参数：类加载器 第二参数：增强方法所在的类，这个类实现的接口，支持多个接口 第三参数，实现这个接口 InvocationHandler, 创建代理对象，写增强的部分 2、编写 JDK 动态代理代码（1）创建接口，定义方法 1234public interface UserDao &#123; public int add(int a,int b); public String update(String id);&#125; （2）创建接口实现类，实现方法 12345678910public class UserDaoImpl implements UserDao &#123; @Override public int add(int a, int b) &#123; return a+b; &#125; @Override public String update(String id) &#123; return id; &#125;&#125; （3）使用 Proxy 类创建接口代理对象 123456789101112131415161718192021222324252627282930313233343536public class JDKProxy &#123; public static void main(String[] args)&#123; //创建接口实现类代理对象 Class[] interfaces = &#123;UserDao.class&#125;;// Proxy.newProxyInstance(JDKProxy.class.getClassLoader(), interfaces,new InvocationHandler() &#123;// @Override// public Object invoke(Object proxy, Method method, Object[] args)throws Throwable &#123;// return null;// &#125;// &#125;); UserDaoImpl userDao = new UserDaoImpl(); UserDao dao = (UserDao) Proxy.newProxyInstance(JDKProxy.class.getClassLoader(), interfaces, new UserDaoProxy(userDao)); int result = dao.add(1,2); System.out.println(&quot;result=&quot;+result); &#125;&#125;// 创建代理对象的代码class UserDaoProxy implements InvocationHandler&#123; // 1.把创建的是谁的代理对象，把谁传递过来 // 有参数构造传递 private Object obj; public UserDaoProxy(Object obj)&#123; this.obj = obj; &#125; // 增强的逻辑 @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; // 方法之前 System.out.println(&quot;方法执行....&quot;+method.getName()+&quot;:传递的参数...&quot;+ Arrays.toString(args)); // 被增强的方法执行 Object res = method.invoke(obj, args); // 方法之后 System.out.println(&quot;方法之后执行...&quot;+obj); return res; &#125;&#125; 三、AOP 术语1、连接点​ 类里面哪些方法可以被增强，这些方法称为连接点 2、切入点​ 实际被真正增强的方法，称之切入点 3、通知（增强）​ （1） 实际增强的逻辑部分称为通知 ​ （2）通知的多种类型 ​ ① 前置通知 ② 后置通知 ③ 环绕通知 ④ 异常通知 ⑤ 最终通知 4、切面​ 把通知应用到切入点的过程 四、AOP 操作1、Spring 框架一般都是基于 AspectJ 实现 AOP 操作​ AspectJ 不是 Spring 组成部分，独立 AOP 框架， 一般把 AspectJ 和 Spring 框架一起使用，进行 AOP 操作 2、基于 AspectJ 实现 AOP 操作​ （1）基于 xml 配置文件实现 ​ （2）基于注解方式实现（使用） 3、在项目工程里面引入 AOP 相关依赖​ 4、切入点表达式​ （1）切入点表达式作用：知道对哪个类里面的哪个方法进行增强 ​ （2）语法结构：execution([权限修饰符][返回值类型][类全路径][方法名称][参数列表]) 举例 1: 对 com.oy.dao.BookDao 类里面的 add 进行增强 1execution(* com.oy.dao.BookDao.add(..)) 举例 2：对 com.oy.dao.BookDao 类里面的所有的方法进行增强 1execution(*.com.oy.dao.BookDao.*(..)) 举例 3：对 com.atguigu.dao 包里面所有类，类里面所有方法进行增强 1execution(* com.atguigu.dao.*.* (..)) 五、AOP 操作（AspectJ 注解） 1、创建类，再类里面定义方法12345public class User &#123; public void add()&#123; System.out.println(&quot;add....&quot;); &#125;&#125; 2、创建增强类（编写增强逻辑）​ （1）在增强类里面，创建方法，让不同的代表不同的通知类型 123456//增强的类public class UserProxy &#123; public void before() &#123;//前置通知 System.out.println(&quot;before......&quot;); &#125;&#125; 3、进行配置的通知（1）在 Spring 配置文件中，开始注解扫描 12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt; &lt;!--开启注解扫描--&gt; &lt;context:component-scan base-package=&quot;com.oy.online.Spring.aopanno&quot;&gt;&lt;/context:component-scan&gt; ​ (2) 使用注解创建类 User 和 UserProxy 对象 ​ （3）在增强类上面添加注解 @Aspect 1234//增强的类@Component@Aspect //生成代理对象public class UserProxy &#123; ​ （4）在 spring 配置文件中华开启生成代理对象 12&lt;!-- 开启 Aspect 生成代理对象--&gt;&lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt; 4、配置不同类型的通知​ （1）在增强类里面，在作为通知方法上面添加通知类型的注解，使用切入点表达式配置 12345678910111213141516171819202122232425262728293031323334353637@Component@Aspectpublic class UserProxy &#123; // 前置通知 // @Before 注解表示作为前置通知 @Before(value = &quot;execution(* com.oy.online.Spring.aopanno.User.add(..))&quot;) public void before()&#123;// 前置通知 System.out.println(&quot;before....&quot;); &#125; //后置通知（返回通知） @AfterReturning(value = &quot;execution(* com.oy.online.Spring.aopanno.User.add(..))&quot;) public void afterReturning()&#123;// 前置通知 System.out.println(&quot;afterReturning....&quot;); &#125; //最终通知 @After(value = &quot;execution(* com.oy.online.Spring.aopanno.User.add(..))&quot;) public void after()&#123;// 前置通知 System.out.println(&quot;after....&quot;); &#125; //异常通知 @AfterThrowing(value = &quot;execution(* com.oy.online.Spring.aopanno.User.add(..))&quot;) public void afterThrowing()&#123; System.out.println(&quot;afterThrowing.........&quot;); &#125; // 环绕通知 @Around(value = &quot;execution(* com.oy.online.Spring.aopanno.User.add(..))&quot;) public void around(ProceedingJoinPoint proceedingJoinPoint)throws Throwable&#123; System.out.println(&quot;环绕之前.........&quot;); //被增强的方法执行 proceedingJoinPoint.proceed(); System.out.println(&quot;环绕之后.........&quot;); &#125;&#125; 5、相同的切入点抽取12345678910// 相同切入点 @Pointcut(value = &quot;execution(* com.oy.online.Spring.aopanno.User.add(..))&quot;) public void pointdemo()&#123; &#125; // 前置通知 // @Before 注解表示作为前置通知 @Before(value = &quot;pointdemo()&quot;) public void before()&#123;// 前置通知 System.out.println(&quot;before....&quot;); &#125; 6、有多个增强类同一个方法进行增强，设置增强类优先级​ （1）在增强类上面添加注释 @Order（数字类型值），数字类型值越小优先级越高 123456789@Component@Aspect@Order(1)public class PersonProxy &#123; @Before(value = &quot;execution(* com.oy.online.Spring.aopanno.User.add(..))&quot;) public void before()&#123;// 前置通知 System.out.println(&quot;PersonProxy before....&quot;); &#125;&#125; 7、完全使用注解开发​ （1）创建配置类，不需要创建 xml 配置文件 12345@Configuration@ComponentScan(basePackages = &#123;&quot;com.oy.online.Spring.aopanno&quot;&#125;)@EnableAspectJAutoProxy(proxyTargetClass = true)public class ConfigAOP &#123;&#125; 测试： 1234567@Testpublic void test2()&#123; ApplicationContext context = new AnnotationConfigApplicationContext(ConfigAOP.class); User user = context.getBean(&quot;user&quot;, User.class); user.add();&#125; 六、AOP 操作（AspectJ 配置文件）1、创建两个类，增强类和被增强类，创建方法123456// 被增强类public class Book &#123; public void buy()&#123; System.out.println(&quot;add.....&quot;); &#125;&#125; 123456// 增强类public class BookProxy &#123; public void before()&#123; System.out.println(&quot;before.....&quot;); &#125;&#125; 2、在 Spring 配置文件中创建两个类的对象123&lt;!--创建对象--&gt; &lt;bean id=&quot;book&quot; class=&quot;com.oy.online.Spring.aopxml.Book&quot;&gt;&lt;/bean&gt; &lt;bean id=&quot;bookProxy&quot; class=&quot;com.oy.online.Spring.aopxml.BookProxy&quot;&gt;&lt;/bean&gt; 3、在 Spring 配置文件中配置切入点123456789&lt;!--配置aop增强--&gt; &lt;aop:config&gt; &lt;aop:pointcut id=&quot;p&quot; expression=&quot;execution(* com.oy.online.Spring.aopxml.Book.buy(..))&quot;/&gt; &lt;!--配置切面--&gt; &lt;aop:aspect ref=&quot;bookProxy&quot;&gt; &lt;!--增强作用在具体的方法上--&gt; &lt;aop:before method=&quot;before&quot; pointcut-ref=&quot;p&quot;&gt;&lt;/aop:before&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; 4、测试类1234567@Testpublic void test3()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean2.xml&quot;); Book book = context.getBean(&quot;book&quot;, Book.class); book.buy();&#125;","categories":[{"name":"JavaEE框架","slug":"JavaEE框架","permalink":"http://blog.oy6090.top/categories/JavaEE%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"java","slug":"java","permalink":"http://blog.oy6090.top/tags/java/"},{"name":"Spring","slug":"Spring","permalink":"http://blog.oy6090.top/tags/Spring/"}]},{"title":"java之泛型","slug":"java泛型","date":"2020-07-22T16:00:00.000Z","updated":"2021-01-22T03:50:35.159Z","comments":true,"path":"posts/3994269159.html","link":"","permalink":"http://blog.oy6090.top/posts/3994269159.html","excerpt":"","text":"一、泛型概念所谓泛型，就是允许自定义类，接口通过一个标识类中的某个属性的类型或者是某个方法的返回值及参数类型。 这个类型参数将在使用时.(例如，继承或实现这个接口，用这个类型声明变量、创建对象时确定(即传入实际类型参数，也称类型实参))。 二、泛型的引用背景​ 集合容器类在设计阶段/声明阶段不能确定这个容器到底实际存的是什么类型的对象，所以在 JDK1.5 之前只能把元素类型设计为 object,JDK1.5 之后使用泛型类解决。因为这个时候除了元素的类型不确定，其他的部分是确定的，例如关于这个这个元素如何保存的，如何管理等使确定的，因此此时把元素的类型设计成一个参数，这个类型参数叫做泛型。Collection，List 这个就是类型参数，即泛型。 三、泛型在集合中的使用1、没有使用泛型之前图示： 1234567891011121314151617 @Test public void test1()&#123; ArrayList list = new ArrayList(); //需求：存放学生的成绩 list.add(78); list.add(76); list.add(89); list.add(88); // 问题一：类型不安全// list.add(&quot;Tom&quot;); for (Object obj : list) &#123; // 问题二：强转时，可能出现ClassCastException int stuScore = (Integer) obj; System.out.println(stuScore); &#125; &#125; 2、使用泛型图示： 12345678910111213141516@Test public void test2()&#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(78); list.add(87); list.add(99); list.add(65); // 编译时，就会进行类型检查，保证数据的安全 // 使用迭代器遍历 Iterator&lt;Integer&gt; iterator = list.iterator(); while(iterator.hasNext())&#123; Integer next = iterator.next(); System.out.println(next); &#125; &#125; 1234567891011121314151617181920@Test public void test3()&#123; // 在集合中使用泛型的情况：以HashMap为例 // JDK 7 新特性：类型判断 HashMap&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); map.put(&quot;Tom&quot;,87); map.put(&quot;Jerry&quot;,87); map.put(&quot;Jack&quot;,67); // 泛型的嵌套 Set&lt;Map.Entry&lt;String, Integer&gt;&gt; entries = map.entrySet(); Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; iterator = entries.iterator(); while(iterator.hasNext())&#123; Map.Entry&lt;String, Integer&gt; e = iterator.next(); String key = e.getKey(); Integer value = e.getValue(); System.out.println(key +&quot;--&gt;&quot; + value); &#125; &#125; 3、集合中使用泛型总结 集合接口或集合类在 JDk 5.0 时都修改带泛型的结构。 在实例化集合类时，可以指明具体的泛型类型 指明完以后，在集合或接口中凡是定义类或接口时，内部结构（比如：方法、构造器、属性等）使用到类的泛型的位置，都指定为实例化的泛型类型。 比如：add（E e） —&gt; 实例化必须是类，不能是基本数据类型。需要用到基本数据类型的位置，拿包装类替换 如果实例化时，没指明泛型的类型。默认类型为 java.Object 类型。 四、自定义泛型类、泛型接口、泛型方法【Order.java】 12345678910111213141516171819202122232425262728293031323334353637383940414243public class Order&lt;T&gt; &#123; String orderName; int orderId; // 类的内部结构就可以使用类的泛型 T orderT; public Order()&#123; T[] arr = (T[]) new Object[10]; &#125; public Order(String orderName, int orderId, T orderT) &#123; this.orderName = orderName; this.orderId = orderId; this.orderT = orderT; &#125; // 如下的方法不是泛型方法 public T getOrderT() &#123; return orderT; &#125; public void setOrderT(T orderT) &#123; this.orderT = orderT; &#125; @Override public String toString() &#123; return &quot;Order&#123;&quot; + &quot;orderName=&#x27;&quot; + orderName + &#x27;\\&#x27;&#x27; + &quot;, orderId=&quot; + orderId + &quot;, orderT=&quot; + orderT + &#x27;&#125;&#x27;; &#125; public static &lt;E&gt;List&lt;E&gt; copyFormArrayTolist(E[] arr)&#123; ArrayList&lt;E&gt; list = new ArrayList&lt;&gt;(); for(E e : arr)&#123; list.add(e); &#125; return list; &#125;&#125; 注意： 静态方法中不能使用类的泛型。 泛型方法：在方法中出现了泛型的结构，泛型参数与类的泛型参数没任何关系。 换句话说，泛型方法所属的类是不是泛型类都没关系。 泛型方法，可以声明为静态的。原因：泛型参数是在调用方法时确定的。并非在实例化类时确定。 【SubOrder.java】 1234567891011121314public class SubOrder extends Order&lt;Integer&gt; &#123;//SubOrder:不是泛型类 public static &lt;E&gt; List&lt;E&gt; copyFromArrayToList(E[] arr)&#123; ArrayList&lt;E&gt; list = new ArrayList&lt;&gt;(); for(E e : arr)&#123; list.add(e); &#125; return list; &#125;&#125; 注意：实例化时，如下的代码是错误的 1SubOrder&lt;Integer&gt; o &#x3D; new SubOrder&lt;&gt;(); 【测试】 1234567891011121314151617181920212223242526272829303132public class OrderTest &#123; @Test public void test1()&#123; // 如果定义了泛型，实例化没指明类的泛型，则认为此泛型类型为Object类型 // 要求：如果大家定义类是带泛型的，建议在实例化时要指明类的泛型。 Order order = new Order(); order.setOrderT(123); order.setOrderT(&quot;abc&quot;); // 建议：实例化时指明类的泛型 Order&lt;String&gt; order1 = new Order&lt;&gt;(&quot;orderAA&quot;,1001,&quot;order:AA&quot;); order1.setOrderT(&quot;AA:hello&quot;); &#125; @Test public void test2()&#123; SubOrder sub1 = new SubOrder(); // 由于子类在继承带泛型时，指明了泛型的类型。则实例化子类对象，不在需要指明泛型。 sub1.setOrderT(1122); &#125; @Test public void test3()&#123; Order&lt;String&gt; order = new Order&lt;&gt;(); Integer[] arr = &#123;1, 2, 3, 4, 5&#125;; // 泛型方法在调用时，指明泛型参数的类型。 List&lt;Integer&gt; list = order.copyFormArrayTolist(arr); System.out.println(list); &#125;&#125; 五、注意点 六、通配符的使用通配符：？ ​ 类 A 是类 B 的父类，G&lt;A&gt;和 G&lt;B&gt;是没关系的，二者共同的父类是：G&lt;?&gt; 12345678910111213@Test public void test()&#123; List&lt;Object&gt; list1 = null; List&lt;String&gt; list2 = null; List&lt;?&gt; list = null; list = list1; list = list2; System.out.println(list1); System.out.println(list2); &#125; 运行结果： 12nullnull 有限制条件的通配符的使用 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/* 限制条件的通配符的使用。 ? extends A: G&lt;? extends A&gt; 可以作为G&lt;A&gt;和G&lt;B&gt;的父类，其中B是A的子类 ? super A: G&lt;? super A&gt; 可以作为G&lt;A&gt;和G&lt;B&gt;的父类，其中B是A的父类 */ @Test public void test4()&#123; List&lt;? extends Person&gt; list1 = null; List&lt;? super Person&gt; list2 = null; List&lt;Student&gt; list3 = new ArrayList&lt;Student&gt;(); List&lt;Person&gt; list4 = new ArrayList&lt;Person&gt;(); List&lt;Object&gt; list5 = new ArrayList&lt;Object&gt;(); list1 = list3; list1 = list4;// list1 = list5;// list2 = list3; list2 = list4; list2 = list5; //读取数据： list1 = list3; Person p = list1.get(0); //编译不通过 //Student s = list1.get(0); list2 = list4; Object obj = list2.get(0); ////编译不通过// Person obj = list2.get(0); //写入数据： //编译不通过// list1.add(new Student()); //编译通过 list2.add(new Person()); list2.add(new Student()); &#125;","categories":[{"name":"java","slug":"java","permalink":"http://blog.oy6090.top/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://blog.oy6090.top/tags/java%E5%9F%BA%E7%A1%80/"}]},{"title":"Java集合之Map","slug":"Java集合之Map","date":"2020-07-21T16:00:00.000Z","updated":"2021-01-22T03:51:17.510Z","comments":true,"path":"posts/37805.html","link":"","permalink":"http://blog.oy6090.top/posts/37805.html","excerpt":"","text":"一、常用实现类结构 Map：双列数据：存储 key-value 键值对的数据 HashMap: 在作为 Map 的主要实现类：线程不安全，效率高；存储 null 的 key 和 value LinkedMap：保证在遍历 map 元素时，可以照添加的顺序实现遍历。 原因：在原来的 HashMap 底层结构基础上，添加了一对指针，指向前一个和后一个元素。对于频繁的遍历操作，此类执行的效率高于 HashMap。 TreeMap: 保证照添加的 key-value 对进行排序，实现排序遍历。此时考虑 key 的自然排序或定制排序，底层使用红黑树 Hashtable：作为古老实现类，线程是安全的，效率低；不能存储 null 的 key 和 value properties:常用类处理配置文件。key 和 value 都是 String 类型 HashMap 的底层： 数组 + 链表 （JDK 7.0 及之前） 数组 + 链表 + 红黑树 （JDK 8.0） 二、存储结构的理解 Map 中 key：无序的、不可重复的，使用 Set 存储的 key —》 key 所在的类要重写 equals() 和 hashCode() () （以 HashMap 为例) Map 中的 value：无序的、可重复的，使用 collection 存储所在的类要重写 equals() 一个键值对：key - value 构成一个 Entry 对象。 Map 中的 entry：无序的、不可重复的，使用 Set 存储所在的 entry 图示： 三、常用方法 方法 描述 put(Object key, Object value) 添加 remove(Object key) 删除 put(Object key, Object value) 修改 get(Object key) 查询 size() 长度 keySet()/value()/entrySet() 遍历 ① keySet() 12345678910111213141516public void test1()&#123; /** * Set keySet()：返回所有key构成的Set集合 */ HashMap map = new HashMap(); map.put(&quot;AA&quot;,123); map.put(45,1234); map.put(&quot;BB&quot;,56); // Set keySet():返回所有的key构成的Set集合 Set set = map.keySet(); Iterator iterator = set.iterator(); while(iterator.hasNext())&#123; System.out.println(iterator.next()); &#125;&#125; ② value() 12345678910111213141516 @Test public void test2()&#123; /** * Collection values()：返回所有value构成的Collection集合 */ HashMap map = new HashMap(); map.put(&quot;AA&quot;,123); map.put(45,1234); map.put(&quot;BB&quot;,56); Collection values = map.values(); Iterator iterator = values.iterator(); while(iterator.hasNext())&#123; System.out.println(iterator.next()); &#125;&#125; ③ entrySet() 123456789101112131415161718@Test public void test3()&#123; /** * Set entrySet()：返回所有key-value对构成的Set集合 */ HashMap map = new HashMap(); map.put(&quot;AA&quot;,123); map.put(45,1234); map.put(&quot;BB&quot;,56); Set set = map.entrySet(); Iterator iterator = set.iterator(); while (iterator.hasNext())&#123; Object next = iterator.next(); Map.Entry entry = (Map.Entry) next; System.out.println(entry.getKey()+&quot;--&gt;&quot;+entry.getValue()); &#125;&#125; 四、内存结构说明1、HashMap 在 JDK 7.0 中实现的原理1234567891011HashMap map = new HashMap(); 在实例化以后，底层创建了长度为16的一维数组Entry[] table. ....可能已经执行多次put... map.put(key1， value1); 首先，调用Key所在类的HashCode()计算Key1的哈希值，此哈希值经过某种算法计算以后，得到entry数组中的存放位置。 如果此位置上的数据为空，此时Key1-value1添加成功。 --&gt; 情况1 如果位置上的数据不为空，（意味着此位置上存在一个或多个数据（以链表的形式存在））,比较Key1和已经存在的一个或多个的哈希值： ① 如果key1的哈希值与已经存在的数据的哈希值不相同，此时key1-value1添加成功。 --&gt; 情况2 ② 如果Key1的哈希值和已经存在的某一个数据(key2-value2)的哈希值相同，继续比较：调用key1所在类的equals(Key2)方法比较： ①如果equlas()返回false：此时key1-value1添加成功。--&gt;情况3 ②如果equals()返回true：使用value1替换value2. 补充： 关于情况 2 和情况 3：此时 key1-value1 和 原来的数据以链表的方式存储 在不断的添加过程中，会涉及的问题，当超出临界值（且要存放的位置非空）时，扩容。 默认的扩容方式：扩容为原来的 2 倍，并将原来的数组复制过来。 2、HashMap 在 JDK 8.0 中的实现原理HashMap 在 Jdk8 中相较于 jdk7 在底层实现方面不同： ​ ① new HashMap(); 底层没创建一个长度为 16 的数组 ​ ② jdk 8 底层数组是：Node[ ]， 而非 Entry[ ] ​ ③ 首次调用 put() 方法时，底层创建长度为 16 的数组 ​ ④ jdk 7 底层结构是： 数组加链表。 jdk 8 中底层结构： 数组 + 链表 + 红黑树。 ​ &lt;1&gt; 当形成链表时，七上八下（jdk7: 新的元素指向旧的元素。jdk8: 旧的元素指向新的元素） ​ &lt;2&gt; 当数组的某一个索引位置上的元素以链表形式存在的数据个数 &gt; 8 且当前元素数组的长度 &gt; 64 时，此时此索引位置上的所有数据改为使用红黑树存储。 3、HashMap 底层典型属性说明 方法 描述 DEFAULT_INITIAL_CAPACITY HashMap 的默认容量，16 DEFAULT_LOAD_FACTOR HashMap 的默认加载因子：0.75 threshold 扩容的临界值，=容量*填充因子：16 * 0.75 =&gt; 12 TREEIFY_THRESHOLD Bucket 中链表长度大于该默认值，转化为红黑树:8 MIN_TREEIFY_CAPACITY 桶中的 Node 被树化时最小的 hash 表容量:64 4、LinkedHashMap 的底层实现原理​ LinkedMap 底层使用的结构是与 HashMap 相同，因为 LinkHashMap 继承 HashMap ​ 区别在于：LinkHashMap 内部提供了 Entry，替换 HashMap 中的 Node 五、TreeMap 的使用​ 向 TreeMap 中添加 key-value,要求 key 必须是由一个类创建的对象，因为要照 key 进行排序：自然排序、定制排序。 ① 自然排序 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public class User implements Comparable&#123; private String name; private int age; public User() &#123; &#125; public User(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; User user = (User) o; return age == user.age &amp;&amp; name.equals(user.name); &#125; @Override public int hashCode() &#123; return Objects.hash(name, age); &#125; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &#x27;&#125;&#x27;; &#125; @Override public int compareTo(Object o) &#123; if(o instanceof User)&#123; User user = (User) o; if(this.name.equals(user.name))&#123; return this.age - user.age; &#125; return this.name.compareTo(user.name); &#125; throw new RuntimeException(&quot;输入的值无法判断&quot;); &#125;&#125; 12345678910111213141516171819202122@Test public void test()&#123; TreeMap map = new TreeMap(); User u1 = new User(&quot;Tom&quot;,23); User u2 = new User(&quot;Jerry&quot;,32); User u3 = new User(&quot;Jack&quot;,20); User u4 = new User(&quot;Rose&quot;,18); map.put(u1,98); map.put(u2,78); map.put(u3,90); map.put(u4,67); // 元示图遍历 Set set = map.entrySet(); Iterator iterator = set.iterator(); while(iterator.hasNext())&#123; Object next = iterator.next(); Map.Entry e = (Map.Entry) next; System.out.println(e.getKey()+&quot;-----&quot;+e.getValue()); &#125; &#125; ② 定制排序 12345678910111213141516171819202122232425262728293031323334@Test public void test2()&#123; Comparator comparator = new Comparator() &#123; @Override public int compare(Object o1, Object o2) &#123; if(o1 instanceof User &amp;&amp; o2 instanceof User)&#123; User user1 = (User) o1; User user2 = (User) o2; return user1.getAge() - user2.getAge(); &#125; throw new RuntimeException(&quot;输入的数值错误!!!!&quot;); &#125; &#125;; TreeMap map = new TreeMap(comparator); User u1 = new User(&quot;Tom&quot;,23); User u2 = new User(&quot;Jerry&quot;,32); User u3 = new User(&quot;Jack&quot;,20); User u4 = new User(&quot;Rose&quot;,18); map.put(u1,98); map.put(u2,78); map.put(u3,90); map.put(u4,67); Set set = map.entrySet(); Iterator iterator = set.iterator(); while(iterator.hasNext())&#123; Object next = iterator.next(); Map.Entry e = (Map.Entry) next; System.out.println(e.getKey() +&quot;---&gt;&quot; + e.getValue()); &#125; &#125; 六、使用 Properties 读取配置文件创建 jdbc.properties 文件 12name=OYpassword=123456 123456789101112131415161718//Properties:常用里处理配置文件.key和value都是String类类型public static void main(String[] args) &#123; FileInputStream fis = null; try &#123; Properties pro = new Properties(); fis = new FileInputStream(&quot;jdbc.properties&quot;); //加载流对应的文件 pro.load(fis); String name = pro.getProperty(&quot;name&quot;); String password = pro.getProperty(&quot;password&quot;); System.out.println(&quot;name:&quot;+name+&quot;password&quot;+password); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"http://blog.oy6090.top/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://blog.oy6090.top/tags/java%E5%9F%BA%E7%A1%80/"}]},{"title":"Java常用类","slug":"Java常用类（基础）","date":"2020-07-21T16:00:00.000Z","updated":"2021-01-22T03:49:38.585Z","comments":true,"path":"posts/34875.html","link":"","permalink":"http://blog.oy6090.top/posts/34875.html","excerpt":"","text":"今天的努力只为更好的明天。 String 类一、概述String: String 声明为 fianl 的，不可被继承。 String 实现了 Serializable 接口，表示字符串是支持序列化的。实现了 Comparable 接口，表示 String 可以进行比较大小。 String 内部定义的 fianl char[ ] value 用于储存字符串数据。 通过字面量的方式（区别new给一个字符串赋值，此时得到字符串声明在字符串常量池中）。 字符串常量池是不会存储相同的内容（使用 String 类的equals()**比较，返回true**）的字符串的。 二、String 的不可变性 说明：① 当对字符串重新赋值，需要重写指定内存中区域赋值，不能使用原有的 value 进行赋值② 当对现有的字符串进行操作时，也需要重新指定内存区域的赋值，不能使用原有的 value 进行赋值。③ 当调用 String 的 replace（）方式修改指定字符串时，也需要重新指定区域赋值，不能使用原有的 value 进行赋值。 12345678910111213141516@Test public void test()&#123; // 字面量的定义 String s1 = &quot;abc&quot;; String s2 = &quot;abc&quot;; //比较s1和s2的地址值 System.out.println(s1 == s2); // true System.out.println(&quot;*****************&quot;); String s4 = &quot;abc&quot;; String s5 = s4.replace(&#x27;a&#x27;, &#x27;m&#x27;); System.out.println(s4);//abc System.out.println(s5);//mbc &#125; 三、String 实例化的不同方式 方式说明：方式一：通过字面量定义的方式方式二：通过 new+构造器的方式 1234567891011121314@Test public void test1()&#123; // 通过字面定义的方式：此时的s1和s2的数据javaEE声明在方法区中字符串常量池 String s1 = &quot;JavaEE&quot;; String s2 = &quot;JavaEE&quot;; // 通过new + 构造器的方式：此时的s3和s4保存地址，是数据在堆空间以后对应的地址值。 String s3 = new String(&quot;javaEE&quot;); String s4 = new String(&quot;javaEE&quot;); System.out.println(s1 == s2);// true System.out.println(s1 == s3);// false System.out.println(s1 == s4);// false System.out.println(s3 == s4);// false &#125; 图示：问题： 12String s = new String(&quot;abc&quot;); 方式创建对象，在内存中创建了几个对象？ 两个：一个是堆空间&quot;new&quot;结构，另一个是char[] 对应的常量池中的数据：&quot;abc&quot; 四、字符串拼接方式赋值的对比 说明： 1.常量与常量的拼接结果在常量池，且常量池中不会存在相同的常量 2.只要其中一个是变量，结果就在堆中。 3.如果拼接的结果调用 **intern()**方法，返回值就是在常量池中。 代码示例： 123456789101112131415161718192021222324@Test public void test2()&#123; String s1 = &quot;javaEE&quot;; String s2 = &quot;hadoop&quot;; String s3 = &quot;javaEEhadoop&quot;; String s4 = &quot;javaEE&quot;+&quot;hadoop&quot;; String s5 = s1 + &quot;hadoop&quot;; String s6 = &quot;javaEE&quot; + s2; String s7 = s1 + s2; System.out.println(s3 == s4);//true System.out.println(s3 == s5);//false System.out.println(s3 == s6);//false System.out.println(s3 == s7);//false System.out.println(s5 == s6);//false System.out.println(s5 == s7);//false System.out.println(s6 == s7);//false System.out.println(&quot;**********************************&quot;); String s8 = s6.intern(); // 返回值得到的s8使用的常量值中已经存在的&quot;javaEEhadoop&quot;; System.out.println(s3 == s8); // true &#125; 1234567891011@Test public void test3()&#123; String s1 = &quot;javaEEhadoop&quot;; String s2 = &quot;javaEE&quot;; String s3 = s2 + &quot;hadoop&quot;; System.out.println(s1 == s3);// false final String s4 = &quot;javaEE&quot;; // s4:常量 String s5 = s4 + &quot;hadoop&quot;; System.out.println(s1 == s5); // true &#125; 五、常用方法 int length()：返回字符串的长度： return value.length char charAt(int index)： 返回某索引处的字符 return value[index] boolean isEmpty()：判断是否是空字符串：return value.length == 0 1234String str = &quot;abc&quot;;System.out.println(str.length());// 3System.out.println(str.charAt(2));// cSystem.out.println(str.isEmpty());// false String toLowerCase()：使用默认语言环境，将 String 中的所字符转换为小写 String toUpperCase()：使用默认语言环境，将 String 中的所字符转换为大写 String trim()：返回字符串的副本，忽略前导空白和尾部空白 12345String str1 = &quot;abcdefg&quot;;String str2 = &quot; abcdefg &quot;;System.out.println(str1.toLowerCase());// abcdefgSystem.out.println(str1.toUpperCase());// ABCDEFGSystem.out.println(str2.trim());// abcdefg boolean equals(Object obj)：比较字符串的内容是否相同 boolean equalsIgnoreCase(String anotherString)：与 equals 方法类似，忽略大小写 String concat(String str)：将指定字符串连接到此字符串的结尾。 等价于用“+” 1234567String str3 = &quot;abcdefg&quot;;String str4 = &quot;ABCDEFG&quot;;String str5 = &quot;abcd&quot;;String str6 = &quot;efg&quot;;System.out.println(str3.equals(str4)); // falseSystem.out.println(str3.equalsIgnoreCase(str4)); // trueSystem.out.println(str5.concat(str6));// abcdefg int compareTo(String anotherString)：比较两个字符串的大小 String substring(int beginIndex)：返回一个新的字符串，它是此字符串的从 beginIndex 开始截取到最后的一个子字符串。 String substring(int beginIndex, int endIndex) ：返回一个新字符串，它是此字符串从 beginIndex 开始截取到 endIndex(不包含)的一个子字符串。 int indexOf(String str, int fromIndex)：返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始 1234567String str7 = &quot;abcdefg&quot;;String str8 = &quot;abcdefg&quot;;String str9 = &quot;abcd&quot;;System.out.println(str7.compareTo(str8)); // 0 表示相等System.out.println(str7.substring(2));// cdefgSystem.out.println(str7.substring(0,5)); // abcdeSystem.out.println(str7.indexOf(&quot;d&quot;,0)); // 3 boolean endsWith(String suffix)：测试此字符串是否以指定的后缀结束 boolean startsWith(String prefix)：测试此字符串是否以指定的前缀开始 boolean startsWith(String prefix, int toffset)：测试此字符串从指定索引开始的子字符串是否以指定前缀开始 1234567String str1 = &quot;helloworld&quot;;boolean b1 = str1.endsWith(&quot;rld&quot;);boolean b2 = str1.startsWith(&quot;hel&quot;);boolean b3 = str1.startsWith(&quot;ll&quot;,2);System.out.println(b1); //tureSystem.out.println(b2); //tureSystem.out.println(b3); //ture boolean contains(CharSequence s)：当且仅当此字符串包含指定的 char 值序列时，返回 true 123String str1 = &quot;helloworld&quot;;String str2 = &quot;wor&quot;;System.out.println(str1.contains(str2)); // true int indexOf(String str)：返回指定子字符串在此字符串中第一次出现处的索引 12System.out.println(str1.indexOf(&quot;ll&quot;)); // 2System.out.println(str1.indexOf(&quot;lo&quot;,5));// -1 int lastIndexOf(String str)：返回指定子字符串在此字符串中最右边出现处的索引 int lastIndexOf(String str, int fromIndex)：返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始反向搜索 123String str3 = &quot;hellorworld&quot;;System.out.println(str3.lastIndexOf(&quot;or&quot;)); // 7System.out.println(str3.lastIndexOf(&quot;or&quot;,2)); // -1 注：indexOf 和 lastIndexOf 方法如果未找到都是返回-1 替换： String replace(char oldChar, char newChar)：返回一个新的字符串，它是通过用 newChar 替换此字符串中出现的所 oldChar 得到的。 String replace(CharSequence target, CharSequence replacement)：使用指定的字面值替换序列替换此字符串所匹配字面值目标序列的子字符串。 String replaceAll(String regex, String replacement)：使用给定的 replacement 替换此字符串所匹配给定的正则表达式的子字符串。 String replaceFirst(String regex, String replacement)：使用给定的 replacement 替换此字符串匹配给定的正则表达式的第一个子字符串。 123456789String str1 = &quot;中国湖南&quot;; // String replace(char oldChar, char newChar)：返回一个新的字符串，它是通过用 newChar 替换此字符串中出现的所有 oldChar 得到的。 String str2 = str1.replace(&quot;湖南&quot;,&quot;湖北&quot;); System.out.println(str2); // 中国湖北 System.out.println(&quot;*********************************************&quot;); // String replace(CharSequence target, CharSequence replacement)：使用指定的字面值替换序列替换此字符串所有匹配字面值目标序列的子字符串。 String str3 = &quot;12hello34world5java7891mysql456&quot;; String str4 = str3.replaceAll(&quot;\\\\d+&quot;, &quot;,&quot;).replaceAll(&quot;^,|,$&quot;, &quot;&quot;); System.out.println(str4); // hello,world,java,mysql 匹配: boolean matches(String regex)：告知此字符串是否匹配给定的正则表达式。 1234String str5 = &quot;12345&quot;; //判断str字符串中是否全部有数字组成，即有1-n个数字组成 boolean matches = str5.matches(&quot;\\\\d+&quot;); System.out.println(matches); // true 切片： String[] split(String regex)：根据给定正则表达式的匹配拆分此字符串。 String[] split(String regex, int limit)：根据匹配给定的正则表达式来拆分此字符串，最多不超过 limit 个，如果超过了，剩下的全部都放到最后一个元素中。 1234567891011String str6 = &quot;hello|world|java&quot;; String[] strs = str6.split(&quot;\\\\|&quot;); for (int i = 0; i &lt; strs.length; i++) &#123; System.out.println(strs[i]); // hello world java &#125; System.out.println(); String str7 = &quot;hello.world.java&quot;; String[] strs2 = str7.split(&quot;\\\\.&quot;); for (int i = 0; i &lt; strs.length; i++) &#123; System.out.println(strs2[i]); // hello world java &#125; String 与其他结构的替换 ① 与基本的数据类型、包装类之间的装换 String ---- 基本数据类型、包装类：调用包装类的静态方法：parse**XXX**(str) 基本数据类型、包装类 — String：调用 String 重载的 valueof(XXX) 代码示例 1234567public void test1()&#123; String str = &quot;123&quot;; int num = Integer.parseInt(str); System.out.println(num); String str1 = String.valueOf(num); System.out.println(str1); &#125; String ====》char[ ]: 调用 String 的 toCharArray();char[ ] ===》 String :调用 String 的构造器 代码示例 12345678910111213 public void test2()&#123;// String --&gt; char[] :调用String的toCharArray(); String str = &quot;abc123&quot;; char[] ch = str.toCharArray(); for(int i = 0; i &lt; ch.length; i++)&#123; System.out.println(ch[i]); &#125; System.out.println(&quot;***************************&quot;);// char[] --&gt; String：调用String的构造器 char[] arr = new char[]&#123;&#x27;h&#x27;,&#x27;l&#x27;,&#x27;l&#x27;&#125;; String str2 = new String(arr); System.out.println(str2); &#125; ② 与字数组之间的转换 编码：String ===》 byte[ ]:调用 String 的 getBytes();解码：byte[ ] ===》 String :调用 String 的构造器编码：字符串 ===》 字节（二进制）解码：编码的逆过程，字节 ===》 字符串说明：解码时，要求解码的使用的字符集必须与编码的字符集一致，否则会出现乱码。 代码示例： 1234567public void test3() throws UnsupportedEncodingException &#123; String str = &quot;abc&quot;; byte[] bytes = str.getBytes(); // 使用默认字符集，进行编码 System.out.println(bytes); byte[] gbks = str.getBytes(&quot;gbk&quot;); System.out.println(Arrays.toString(gbks)); &#125; 运行结果：补充：与 StringBuffer、StringBuilder 之间的转换String === 》 StringBuffer、StringBuilder：调用 StringBuffer、StringBuilder 构造器；StringBuffer、StringBuilder ===》 String: ① 调用 String 构造器 ② StringBuffer、StringBuilder 的 toString(); JVM 中字符串常量池存放位置说明： JDK 1.6： (jdk 6.0 , java 6.0):字符串常量池存储在方法区（永久区）JDK 1.7： 字符串常量池存储在堆空间JDK 1.8： 字符串常量池存储在方法区（云空间） StringBuffer、StringBuilder一、String、String、StringBuilder 三者的对比123String：不可变的字符序列：底层使用char[] 储存StringBuffer： 可变的字符序列：线程安全的，效率低：底层使用char[]存储StringBuilder： 可变的字符序列：jdk5.0：新增的，线程不安全，效率高；底层使用char[] 存储 可变类型： 比如列表：列表名（或称为列表引用）指向堆空间中的一个列表。列表引用当中存储的内容为地址，可以指向堆内存中的具体对象. 一方面，该列表可以保证在地址不变的前提下，改变列表内容;另一方面，该引用也可以直接指向堆空间中的另外一个列表.. 不可变序列: 比如数字、字符、（元祖）：对于基础数据类型，变量地址即变量本身，所以值发生变化了，内存地址就一定也变了。 比如字符串：被称为不可变的字符序列，每个字符底层均有规范的Unicode码对应，内存规定无法对单一的一个字符进行修改，要修改字符串必须重新指向一个全新的字符串 二、StringBuffer 与 StringBuilder 的内存解析12345678910以Stringuffer为例：String str = new String();//char[] value = new char[0];String str1 = new String(&quot;abc&quot;);//char[] value = new char[]&#123;&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;&#125;;StringBuffer sb1 = new StringBuffer();//char[] value = new char[16];底层创建了一个长度是16的数组。System.out.println(sb1.length());//sb1.append(&#x27;a&#x27;);//value[0] = &#x27;a&#x27;;sb1.append(&#x27;b&#x27;);//value[1] = &#x27;b&#x27;;StringBuffer sb2 = new StringBuffer(&quot;abc&quot;);//char[] value = new char[&quot;abc&quot;.length() + 16]; 扩容问题：如果添加的数组底层数组盛不下，那就需要扩容底层的数组默认的情况,扩容为原来的 2 倍+2;同时将原来的数组复制到新数组中。在开发中优先使用：StringBuffer、StringBuilder 三、对比 String、StringBuffer 、StringBuilder 三者的执行效率 从高到低排序：StringBuiler &gt; StringBuffer &gt; String 四、StringBuffer、StringBuilder 中常用的方法1234567增：oppend（XXX）删：delete（int start, int end）改：setCharAt(int n , char ch) / replance(int start, int end , Sting str)查：charAt(int n)插： insert（int offset , XXX）;长度：Lenght();*遍历：for（） + charAt() / toString（） JDK 8 之前日期时间 API一、获取系统之前当前时间 System 类中的 CurrentTimeMills() 1234long time = Sysem.cuurenTimeMillis()//返回当前时间与1970年1月1日0时0分之间以毫秒为单位的时间差。//称为时间戳System.out.println(time); 二、java.util.Date 类与 java.sql.Date 类1234567891011java.util.Date类 |---java.sql.Date类1.两个构造器的使用 &gt;构造器一：Date()创建一个对应当前时间的Date对象 &gt;构造器二：创建指定毫秒数的Date对象2.两个方法的使用 &gt;toString() 显示当前的年、月、日、分、秒 &gt;getTime() 获取当前Date对象对应的毫秒数。(时间戳)3.java.sql.Date对应着数据中日期类型的变量 &gt; 实例化 &gt; 将java.util.Date 转为 java.sql.Date 代码示例： 12345678910111213141516171819202122232425262728293031323334353637@Test public void test1()&#123; long time = System.currentTimeMillis(); System.out.println(time); &#125; @Test public void test2()&#123; // 构造器一：Date()：创建一个对应当前时间的Date对象 Date date = new Date(); System.out.println(date.toString()); // Sat Jun 13 17:07:02 CST 2020 System.out.println(date.getTime()); // 1592039273009 &#125; @Test public void test3()&#123; // 构造器二：创建指定毫秒数的Date对象 Date date = new Date(1592039273009L); System.out.println(date.toString()); // Sat Jun 13 17:07:53 CST 2020 System.out.println(&quot;***********************&quot;); // 创建java.sql.Date对象 java.sql.Date date1 = new java.sql.Date(1592039273009L); System.out.println(date1); // 2020-06-13 &#125; @Test /** * 将java.util.Date对象转换为java.sql.Date对象 */ public void test4()&#123; // 情况一： Date date = new java.sql.Date(1592039273009L); java.sql.Date date1 = (java.sql.Date) date; // 情况二： Date date2 = new Date(); java.sql.Date date3 = new java.sql.Date(date2.getTime()); &#125; 三、java.text.SimpleDateFormat 类12345simpleDateFormat 对日期Date类的格式化和解析1.两个操作 1.1 格式化：日期 --&gt; 字符串 1.2 解析： 格式化的逆过程，字符串 --&gt; 日期2.SimpleDateFormat 1234567891011121314 @Test public void test5() throws ParseException &#123;// 照指定的方式格式化和解析：调用带参的构造器 SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd hh:mm aaa&quot;); // 格式化 Date date = new Date(); String format = sdf.format(date); System.out.println(format); // 2020-06-13 05:23 下午 //解析:要求字符串必须是符合SimpleDateFormat识别的格式(通过构造器参数体现), //否则，抛异常 Date parse = sdf.parse(&quot;2020-06-13 05:23 下午&quot;); System.out.println(parse); // Sat Jun 13 17:23:00 CST 2020 &#125; 四、Calendar 类：日历类、抽象类12345678910111213141516171819202122232425262728293031323334@Test public void test6()&#123; //1.实例化 //方式一：创建其子类（GregorianCalendar的对象 //方式二：调用其静态方法getInstance() Calendar calendar = Calendar.getInstance();// System.out.println(calendar); //2 常用方法 // get int days = calendar.get(Calendar.DAY_OF_MONTH); System.out.println(days);// 13 System.out.println(calendar.get(Calendar.DAY_OF_YEAR)); // 165 // set() calendar.set(Calendar.DAY_OF_MONTH,22); int days1 = calendar.get(Calendar.DAY_OF_MONTH); System.out.println(days1); // 22 //add() calendar.add(Calendar.DAY_OF_MONTH,-3); days = calendar.get(Calendar.DAY_OF_MONTH); System.out.println(days); // 19 // getTime() 日历类 ---&gt; Date Date time = calendar.getTime(); System.out.println(time);// Fri Jun 19 17:41:29 CST 2020 //setTime():Date ---&gt; 日历类 Date date = new Date(); calendar.setTime(date); days = calendar.get(Calendar.DAY_OF_MONTH); System.out.println(days); // 13 &#125; JDK8 中新日期时间 API一、日期时间的迭代 第一代：jdk 1.0 Date 类第二代：jdk 1.1 Calender 类，一定的程度上替代了 Date 类第三代：jdk 1.8 提出了新的一套 API 二、前两代存在的问题举例： 可变性：像时间和日期这样的类应该是吧不可变的。偏移性：Date 中的年份是从 1900 年开始的，月份是从 0 开始的。格式化：格式话只对 Date 有用，calender 则不行。此外，它们也不是线程安全的，不能处理闰秒等。 三、java 8 中新的日期时间 API 涉及到的包 四、本地日期、本地时间、本地日期时间的使用：LocalDate/LocalTime/LocalDateTime 一、说明 ① 分别表示使用 ISO-8601 日历系统的日期、时间、和时间。它们提供了简单的本地时间信息，也不包含当前的时间信息，也不包含与时区相关的信息。② LocalDatetime 相较于 LocalDate、LocalTIme,使用频率高③ 类似于 Calender 二、常用方法 五 时间点：Instant 一、说明 ① 时间线上的一个瞬时点，概念上讲。它只是简单的表示自 1970 年 1 月 1 日 0 时 0 秒（UTC 开始的秒数）② 类似于 java.util.Date 类 二、常用方法 六、时间日期格式化类：DateTimeFormatter 一、说明 ① 格式化或解析日期、时间② 类似于 SimpleDateFormat 二、常用方法① 实例化方式： 预定义的标准格式，如：ISO_LOCAL_DATE_TIME; ISO_LOCAL_DATE;ISO_DATE;ISO_LOCAL_TIME本地相关的格式：如：ofLocalizedDateTime(FormatStyle.LONG)自定义的格式：如：ofPattern（“yyyy-MM-dd hh:mm:ss”） ② 常用方法 1234567891011public void test1()&#123; DateTimeFormatter formatter = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd hh:mm:ss&quot;); // 格式化 String str = formatter.format(LocalDateTime.now()); System.out.println(str); // 2020-06-20 03:38:37 // 解析 TemporalAccessor accessor = formatter.parse(&quot;2020-06-20 03:38:37&quot;); System.out.println(accessor); // &#123;MinuteOfHour=38, HourOfAmPm=3, MilliOfSecond=0, MicroOfSecond=0, NanoOfSecond=0, SecondOfMinute=37&#125;,ISO resolved to 2020-06-20 &#125; 七、其他 带时区的日期时间：ZonedDateTime / ZoneId 12345678910111213141516171819202122232425262728/** * ZoneId:类中包含的失去信息 */ @Test public void test3()&#123; // getAvailableZoneIds():获取所有的ZoneId Set&lt;String&gt; zoneIds = ZoneId.getAvailableZoneIds(); for (String s : zoneIds) &#123; System.out.println(s); &#125; System.out.println(&quot;***********************&quot;); LocalDateTime localDateTime = LocalDateTime.now(ZoneId.of(&quot;Asia/Tokyo&quot;)); System.out.println(localDateTime); // 2020-06-20T16:53:34.885 &#125; /** * ZonedDateTime: 带时区的时间 */ @Test public void test4()&#123; // now() 获取本时区的ZoneDateTime对象 ZonedDateTime now = ZonedDateTime.now(); System.out.println(now); // 2020-06-20T15:57:00.163+08:00[Asia/Shanghai] // now(ZoneId id) 获取指定时区的ZonedTime对象 ZonedDateTime zonedDateTiem = ZonedDateTime.now(ZoneId.of(&quot;Asia/Shanghai&quot;)); System.out.println(zonedDateTiem); &#125; 时间间隔：Duration–用于计算两个“时间”间隔，以秒和纳秒为基准 123456789101112131415public void test5()&#123; LocalTime localTime = LocalTime.now(); LocalTime localTime2 = LocalTime.of(15, 23, 32); // between() 静态方法，返回Duration对象，表示两个时间间隔 Duration between = Duration.between(localTime, localTime2); System.out.println(between); System.out.println(between.getSeconds()); System.out.println(between.getNano()); LocalDateTime localdatetime = LocalDateTime.of(2016, 6, 12, 15, 23, 32); LocalDateTime localdatetime1 = LocalDateTime.of(2017, 6, 12, 15, 23, 32); Duration between1 = Duration.between(localdatetime, localdatetime1); System.out.println(between1.toDays()); // 365 &#125; 日期间隔：Period –用于计算两个“日期”间隔，以年、月、日衡量 1234567891011121314public void test6()&#123; LocalDate localdate = LocalDate.now(); LocalDate localdate1 = LocalDate.of(2028, 3, 18); Period period = Period.between(localdate, localdate1); System.out.println(period); // P7Y8M27D System.out.println(period.getYears()); // 7 System.out.println(period.getMonths()); // 8 System.out.println(period.getDays()); // 27 Period period1 = period.withYears(2); System.out.println(period1); // P2Y8M27D &#125; 日期时间校正器：TemporalAdjuster 12345678910111213141516171819202122public void test7()&#123; // 获取当前日期的下一个周日是哪天？ TemporalAdjuster temporalAdjuster = TemporalAdjusters.next(DayOfWeek.SUNDAY); LocalDateTime localDateTime = LocalDateTime.now().with(temporalAdjuster); System.out.println(localDateTime); // 2020-06-21T16:42:13.229 // 获取下一个工作日食哪天 LocalDate localDate = LocalDate.now().with(new TemporalAdjuster() &#123; @Override public Temporal adjustInto(Temporal temporal) &#123; LocalDate date = (LocalDate) temporal; if (date.getDayOfWeek().equals(DayOfWeek.FRIDAY)) &#123; return date.plusDays(3); &#125; else if (date.getDayOfWeek().equals(DayOfWeek.SATURDAY)) &#123; return date.plusDays(2); &#125; else &#123; return date.plusDays(1); &#125; &#125; &#125;); System.out.println(&quot;下一个工作日是:&quot;+localDate); &#125; Java 比较器一、java 比较器的使用背景 ① Java 中的对象，正常情况下，只能进行比较： == 或 ！= ，不能使用 &gt; 或 &lt; 但是在开发场景中，我们需要对多个对象进行排序，言外之意，就需要比较对象的大小。使用两个接口中的任何一个: Comparable 或 Compartor 二、自然排序：使用 comparable 接口 说明 ① 像 String、包装类等实现了 Comparable 接口，重写了 comparaTo（obj）方法，给出了比较两个对象大小的方式。② String、包装类重写了 comparaTo(）的规则：如果当前的对象 this 大于形参对象 obj，则返回正整数.如果当前对象 this 小于形参 obj，则返回负整数如果当前对象 this 等于形对象 obj,则返回零。③ 对于自定义类来说，如果需要排序，我们可以自定义类实现 Comparablej 接口，重写 comparaTo（obj）方法。在 comparaTo()方法中指明如何排序 123456789101112131415161718192021222324252627282930public class Goods implements Comparable&#123; private Sting name; private double price; //指明商品比较大小的方式：照价格从低到高排序，在照产品名称从高到低排序 @Override public int compareTo(Object o) &#123;// System.out.println(&quot;**************&quot;); if(o instanceof Goods)&#123; Goods goods = (Goods)o; //方式一： if(this.price &gt; goods.price)&#123; return 1; &#125;else if(this.price &lt; goods.price)&#123; return -1; &#125;else&#123;// return 0; return -this.name.compareTo(goods.name); &#125; //方式二：// return Double.compare(this.price,goods.price); &#125;// return 0; throw new RuntimeException(&quot;传入的数据类型不一致！&quot;); &#125;// getter、setter、toString()、构造器：省略&#125; &#125;&#125; 三、定制排序：使用 Comparator 接口说明： ① 背景： 当元素的类型没实现 java.lang.comparable 接口而又不方便修改代码，或实现了 java.lang.Comparable接口的排序规则不适合当前的操作，那么可以考虑使用 Comparator 的对象类排序 ② 重写 comparator(Object o1, Object o2)方法，比较 o1 和 o2 的大小： 重写方法返回正整数，则表示 o1 大于 o2如果返回 0,表示相等返回负整数，表示 o1 小于 o2 代码示例： 12345678910111213141516Comparator com = new Comparator() &#123; //指明商品比较大小的方式:照产品名称从低到高排序,再照价格从高到低排序 @Override public int compare(Object o1, Object o2) &#123; if(o1 instanceof Goods &amp;&amp; o2 instanceof Goods)&#123; Goods g1 = (Goods)o1; Goods g2 = (Goods)o2; if(g1.getName().equals(g2.getName()))&#123; return -Double.compare(g1.getPrice(),g2.getPrice()); &#125;else&#123; return g1.getName().compareTo(g2.getName()); &#125; &#125; throw new RuntimeException(&quot;输入的数据类型不一致&quot;); &#125;&#125; 使用： 123Arrays.sort(goods,com);Collections.sort(coll,com);new TreeSet(com); 123456789101112131415161718192021222324252627 public void test3()&#123; Goods[] arr = new Goods[6]; arr[0] = new Goods(&quot;lenovoMouse&quot;,34.0); arr[1] = new Goods(&quot;dellMouse&quot;,43.0); arr[2] = new Goods(&quot;xiaomiMouse&quot;,12.0); arr[3] = new Goods(&quot;huaweiMouse&quot;,65.0); arr[4] = new Goods(&quot;huaweiMouse&quot;,224.0); arr[5] = new Goods(&quot;microsoftMouse&quot;,43.0); Arrays.sort(arr); System.out.println(&quot;Comparable排序&quot;+Arrays.toString(arr)); // 使用匿名内部类，可以在一定的程度上优化代码 new Comparator&lt;T&gt;()&#123;&#125; Arrays.sort(arr, new Comparator&lt;Goods&gt;() &#123; @Override public int compare(Goods o1, Goods o2) &#123; // name 相同 就比较 价格（降序） if(o1.getName().equals(o2.getName()))&#123; return -Double.compare(o1.getPrice(),o2.getPrice()); &#125;else&#123; return o1.getName().compareTo(o2.getName()); &#125; &#125; &#125;); System.out.println(&quot;Comparator:&quot;+Arrays.toString(arr)); &#125;&#125; 其他类一、System 类 ① System 类代表系统，系统级的很多属性和控制方法都放置在该类的内部。该类位于 java.lang 包。② 由于该类的构造器是 private 的，所以无法创建该类的对象，也就是无法实例化该类。其内部的成员变量和成员方法都是 static 的，所以也可以很方便的进行调用。 方法： 1234native long currentTimeMillis()void exit(int status)void gc()String getProperty(String key) 二、Math 类1java.lang.Math提供了一系列静态方法用于科学计算。其方法的参数和返回值类型一般为double型。 三、BigInteger 类、BigDecimal 类说明： ① java.math 包的 BigInteger 可以表示不可变的任意精度的整数。② 要求数字精度比较高，用到 java.math.BigDecimal 类 123456789101112public class BigIntegerTest &#123; @Test public void test1()&#123; BigInteger bi = new BigInteger(&quot;12323443544535&quot;); BigDecimal bd = new BigDecimal(&quot;233434.35445&quot;); BigDecimal bd2 = new BigDecimal(&quot;2113&quot;); System.out.println(bi); // 12323443544535 System.out.println(bd.divide(bd2,BigDecimal.ROUND_HALF_UP)); // 110.47532 System.out.println(bd.divide(bd2,15,BigDecimal.ROUND_HALF_UP)); // 110.475321557027922 &#125;&#125;","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://blog.oy6090.top/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"java","slug":"java","permalink":"http://blog.oy6090.top/tags/java/"}]},{"title":"Spring5之IOC","slug":"Spring5之IOC","date":"2020-07-21T16:00:00.000Z","updated":"2020-10-25T02:19:13.978Z","comments":true,"path":"posts/3979597380.html","link":"","permalink":"http://blog.oy6090.top/posts/3979597380.html","excerpt":"","text":"Spring5 介绍 Spring 是轻量级的开源的 JavaEE 框架 Spring 可以解决企业应用开发的复杂性 Spring 有两个核心部分：IOC 和 Aop (1) IOC : 控制反转，把创建对象过程给 Spring 进行管理 (2) Aop: 面向切面，不修改源代码进行功能增强 Spring 特点 （1）方便解耦，简化开发 （2）Aop 编程支持 （3）方便程序测试 （4） 方便和其他框架进行整合 （5）方便进行事务操作 （6）降低 API 开发难度 Spring5 入门案例 使用 idea 创建一个普通的 java 工程 导入 Spring5 相关的 jar 包（先去 Spring 官网下载） 创建普通类，在这个类创建普通方法 12345public class User&#123; public void add()&#123; System.out.println(&quot;add....&quot;); &#125;&#125; 创建 Spring 配置文件，在配置文件配置创建的对象（bean1.xml） 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!--配置User对象的创建--&gt; &lt;bean id=&quot;user&quot; class=&quot;com.oy.online.spring.User&quot;&gt;&lt;/bean&gt;&lt;/beans&gt; 5.进行测试代码编写 12345678910@Testpublic void userTest()&#123; // 1.加载Spring配置文件 ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean1.xml&quot;); // 2.获取配置创建的对象 User user = context.getBean(&quot;user&quot;, User.class); System.out.println(user); user.add();&#125; 一、IOC(概念和原理)1、IOC 控制反转，把对象创建和对象之间的调用过程，交给 Spring 进行管理 使用 IOC 目的：为了耦合度降低 2、IOC 底层原理 xml 解析、工厂模式、反射 二、 IOC(BeanFactory 接口) IOC 思想基于 IOC 容器完成，IOC 容器底层就是对象工厂 Spring 提供 IOC 容器实现的两种方式:（两个接口） (1) BeanFactory: IOC 容器基本实现，是 Spring 内部的使用接口，不提供开发人员进行使用 ​ 加载配置文件时候不会加载，在获取对象（使用）才会去创建对象 (2)ApplicationContext: BeanFactory 接口的子接口，提供更多更强大的功能，一般有开发人员进行使用 ​ 加载配置文件时候就会把配置文件对象进行创建 ApplicationContext 接口有实现类 三、IOC 操作 Bean 管理（概念）1、Bean 管理 Bean 管理指的是两个操作 Spring 创建对象 Spring 注入属性 2、Bean 管理的操作的两种方式 基于 xml 配置文件方式实现 基于注解方式实现 四、IOC 操作 Bean 管理（基于 xml 方式）1、基于 xml 方式创建对象12&lt;!--配置User对象的创建--&gt;&lt;bean id=&quot;user&quot; class=&quot;com.oy.online.spring.User&quot;&gt;&lt;/bean&gt; (1) 在 spring 配置文件中，使用 bean 标签，标签里面添加对应属性，就可以实现对象的创建 (2) 在 bean 标签有很多属性，介绍常用属性 Id 属性 ： 唯一标识符 class 属性：类全路径（包类路径） (3) 创建对象时候，默认也是执行无参构造器完成对象的创建 2、基于 xml 方式注入属性（1）DI：依赖注入，就是注入属性 3、第一种注入方式：使用 set 方法进行注入​ (1) 创建类，定义属性和对应的 set 方法 1234567891011121314151617public class Book &#123; // 创建属性 private String bname; private String bauthor; // 创建属性对应的set方法 public void setBname(String bname)&#123; this.bname = bname; &#125; public void setBauthor(String bauthor)&#123; this.bauthor = bauthor; &#125; // 测试方法 public void show()&#123; System.out.println(bname+&quot;::&quot;+bauthor); &#125;&#125; ​ (2) 在 spring 配置文件配置对象创建，配置属性注入 12345678910&lt;!--配置Book对象的创建--&gt; &lt;!--set 方法注入属性--&gt; &lt;bean id=&quot;book&quot; class=&quot;com.oy.online.spring.Book&quot;&gt; &lt;!--使用property 完成属性的注入 name : 类里面属性名称 value: 向属性注入的值 --&gt; &lt;property name=&quot;bname&quot; value=&quot;Java编程之美&quot;&gt;&lt;/property&gt; &lt;property name=&quot;bauthor&quot; value=&quot;Java&quot;&gt;&lt;/property&gt; &lt;/bean&gt; 4、第二种注入方式：使用有参数构成进行注入​ (1) 创建类，定义属性，创建属性对应有参数构造方法 12345678910111213141516public class Order &#123; // 属性 private String oname; private String address; // 有参数构造 public Order(String oname, String address)&#123; this.oname = oname; this.address = address; &#125; // 测试方法 public void show()&#123; System.out.println(oname+&quot;::&quot;+address); &#125;&#125; ​ (2) 在 spring 配置文件中的进行配置 12345&lt;!--有参构造函数注入属性--&gt; &lt;bean id=&quot;order&quot; class=&quot;com.oy.online.spring.Order&quot;&gt; &lt;constructor-arg name=&quot;oname&quot; value=&quot;电脑&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=&quot;address&quot; value=&quot;China&quot;&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; 5、p 空间名称注入（了解）​ (1) 使用 p 名称空间注入，可以简化基于 xml 配置方式 第一步 添加 p 名称空间在配置文件中 xmlns:p=”http://www.springframework.org/schema/p&quot; 12345&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;&lt;/beans&gt; 第二步 进行属性注入，在 bean 标签里面进行操作 12&lt;!--set 方法注入属性--&gt;&lt;bean id&#x3D;&quot;book&quot; class&#x3D;&quot;com.oy.online.spring.Book&quot; p:bname&#x3D;&quot;java编程之美&quot; p:bauthor&#x3D;&quot;java&quot;&gt;&lt;&#x2F;bean&gt; 五、IOC 操作 Bean 管理（xml 注入其他类型属性）1、 字面量（1）null 值 123 &lt;property name=&quot;address&quot;&gt; &lt;null/&gt;&lt;/property&gt; ​ (2) 属性包含特殊符号 1234567&lt;!--属性值包含特殊符号1 把&lt;&gt;进行转义 &amp;lt; &amp;gt;2 把带特殊符号内容写到 CDATA--&gt;&lt;property name=&quot;address&quot;&gt; &lt;value&gt;&lt;![CDATA[&lt;&lt;南京&gt;&gt;]]&gt;&lt;/value&gt;&lt;/property&gt; 2、注入属性-外部 bean(1) 创建两个类 service 类 和 dao 类 (2) 在 service 调用 dao 里面的方法 (3) 在 spring 配置文件中进行配置 1234567891011public class UserService &#123; //创建 UserDao 类型属性，生成 set 方法 private UserDao userDao; public void setUserDao(UserDao userDao) &#123; this.userDao = userDao; &#125; public void add() &#123; System.out.println(&quot;service add...............&quot;); userDao.update(); &#125;&#125; 123456789&lt;!--1 service 和 dao 对象创建--&gt;&lt;bean id=&quot;userService&quot; class=&quot;com.atguigu.spring5.service.UserService&quot;&gt; &lt;!--注入 userDao 对象 name 属性：类里面属性名称 ref 属性：创建 userDao 对象 bean 标签 id 值 --&gt; &lt;property name=&quot;userDao&quot; ref=&quot;userDaoImpl&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id=&quot;userDaoImpl&quot; class=&quot;com.atguigu.spring5.dao.UserDaoImpl&quot;&gt;&lt;/bean&gt; 3、注入属性-内部 bean（1） 一对多关系：部门和员工 ​ 一个部门有多个员工，一个员工属于一个部门 ​ 部门是一，员工是多 （2）在实体类之间表示一对多关系，员工表示所属部门，使用对象类型属性进行表示 ​ 部门： 1234567891011121314public class Dept &#123; private String dname; public void setDname(String dname) &#123; this.dname = dname; &#125; @Override public String toString() &#123; return &quot;Dept&#123;&quot; + &quot;dname=&#x27;&quot; + dname + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; ​ 员工： 12345678910111213141516171819202122public class Emp &#123; private String ename; private String gender; // 员工属于某一个部门，使用对象形式表示 private Dept dept; public void setEname(String ename) &#123; this.ename = ename; &#125; public void setGender(String gender) &#123; this.gender = gender; &#125; public void setDept(Dept dept) &#123; this.dept = dept; &#125; public void show()&#123; System.out.println(ename + &quot;::&quot; + gender + &quot;::&quot; + dept); &#125;&#125; ​ (3) 在 Spring 配置文件中进行配置 123456789101112&lt;!--内部bean--&gt; &lt;bean id=&quot;emp&quot; class=&quot;com.oy.online.spring.bean.Emp&quot;&gt; &lt;!--设置两个普通属性--&gt; &lt;property name=&quot;ename&quot; value=&quot;jack&quot;&gt;&lt;/property&gt; &lt;property name=&quot;gender&quot; value=&quot;女&quot;&gt;&lt;/property&gt; &lt;!--设置对象类型属性--&gt; &lt;property name=&quot;dept&quot;&gt; &lt;bean id=&quot;dept&quot; class=&quot;com.oy.online.spring.bean.Dept&quot;&gt; &lt;property name=&quot;dname&quot; value=&quot;设计部&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;/property&gt; &lt;/bean&gt; ​ 测试： 12345678910 @Testpublic void EmpTest()&#123; // 加载Spring配置文件 ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean3.xml&quot;); // 获取创建对象 Emp emp = context.getBean(&quot;emp&quot;, Emp.class); System.out.println(emp); emp.show();&#125; 4、注入属性-级联赋值 第一种写法 1234567891011&lt;!--级联赋值--&gt;&lt;bean id=&quot;emp&quot; class=&quot;com.oy.online.spring.bean.Emp&quot;&gt; &lt;!--设置两个普通属性--&gt; &lt;property name=&quot;ename&quot; value=&quot;lucy&quot;&gt;&lt;/property&gt; &lt;property name=&quot;gender&quot; value=&quot;女&quot;&gt;&lt;/property&gt; &lt;!--级联赋值--&gt; &lt;property name=&quot;dept&quot; ref=&quot;dept&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id=&quot;dept&quot; class=&quot;com.oy.online.spring.bean.Dept&quot;&gt; &lt;property name=&quot;dname&quot; value=&quot;技术部&quot;&gt;&lt;/property&gt;&lt;/bean&gt; 第二种写法 123456789101112 &lt;!--级联赋值--&gt;&lt;bean id=&quot;emp&quot; class=&quot;com.oy.online.spring.bean.Emp&quot;&gt; &lt;!--设置两个普通属性--&gt; &lt;property name=&quot;ename&quot; value=&quot;lucy&quot;&gt;&lt;/property&gt; &lt;property name=&quot;gender&quot; value=&quot;女&quot;&gt;&lt;/property&gt; &lt;!--级联赋值--&gt; &lt;property name=&quot;dept&quot; ref=&quot;dept&quot;&gt;&lt;/property&gt; &lt;property name=&quot;dept.dname&quot; value=&quot;财务部&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id=&quot;dept&quot; class=&quot;com.oy.online.spring.bean.Dept&quot;&gt; &lt;property name=&quot;dname&quot; value=&quot;技术部&quot;&gt;&lt;/property&gt;&lt;/bean&gt; 六、IOC 操作 Bean 管理（xml 注入集合属性） 1、注入数组类型属性2、注入 List 集合类型属性3、注入 Map 集合属性（1） 创建类，定义属性、list、map、set 类型属性，生成对应的 set 方法 123456789101112131415161718192021222324252627282930313233343536public class Stu &#123; // 1.数组类型属性 private String[] courses; // 2. list集合类型属性 private List&lt;String&gt; list; // 3.map 集合类型属性 private Map&lt;String, String&gt; maps; // 4.set集合类型属性 private Set&lt;String&gt; set; public void setCourses(String[] courses) &#123; this.courses = courses; &#125; public void setList(List&lt;String&gt; list) &#123; this.list = list; &#125; public void setMaps(Map&lt;String, String&gt; maps) &#123; this.maps = maps; &#125; public void setSet(Set&lt;String&gt; set) &#123; this.set = set; &#125; @Override public String toString() &#123; return &quot;Stu&#123;&quot; + &quot;courses=&quot; + Arrays.toString(courses) + &quot;, list=&quot; + list + &quot;, maps=&quot; + maps + &quot;, set=&quot; + set + &#x27;&#125;&#x27;; &#125;&#125; ​ （2）在 Spring 配置文件进行配置 12345678910111213141516171819202122232425262728293031&lt;!--集合类型属性注入--&gt; &lt;bean id=&quot;stu&quot; class=&quot;com.oy.online.Spring.Stu&quot;&gt; &lt;!--数组类型属性注入--&gt; &lt;property name=&quot;courses&quot;&gt; &lt;array&gt; &lt;value&gt;java课程&lt;/value&gt; &lt;value&gt;数据库课程&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;!--list 类型属性注入--&gt; &lt;property name=&quot;list&quot;&gt; &lt;list&gt; &lt;value&gt;张三&lt;/value&gt; &lt;value&gt;李四&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;!--Map 类型属性注入--&gt; &lt;property name=&quot;maps&quot;&gt; &lt;map&gt; &lt;entry key=&quot;Java&quot; value=&quot;java&quot;&gt;&lt;/entry&gt; &lt;entry key=&quot;PHP&quot; value=&quot;php&quot;&gt;&lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;!--set 类型属性注入--&gt; &lt;property name=&quot;set&quot;&gt; &lt;set&gt; &lt;value&gt;MySql&lt;/value&gt; &lt;value&gt;Redis&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;/bean&gt; 4、在集合里面设置对象类型值​ 在 Stu 中添加属性和方法： 123456//学生所学多门课程 private List&lt;Course&gt; courseList; public void setCourseList(List&lt;Course&gt; courseList) &#123; this.courseList = courseList; &#125; 在 Spring 配置文件中 1234567&lt;!--注入 list 集合类型，值是对象--&gt;&lt;property name=&quot;courseList&quot;&gt; &lt;list&gt; &lt;ref bean=&quot;course1&quot;&gt;&lt;/ref&gt; &lt;ref bean=&quot;course2&quot;&gt;&lt;/ref&gt; &lt;/list&gt;&lt;/property&gt; 1234567&lt;!--创建多个 course 对象--&gt;&lt;bean id=&quot;course1&quot; class=&quot;com.oy.online.Spring.Course&quot;&gt; &lt;property name=&quot;cname&quot; value=&quot;Spring5框架&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id=&quot;course2&quot; class=&quot;com.oy.online.Spring.Course&quot;&gt; &lt;property name=&quot;cname&quot; value=&quot;Mybaits框架&quot;&gt;&lt;/property&gt;&lt;/bean&gt; 5、把集合注入部分提取出来（1）在 Spring 配置文件中引入名称 util http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd 12345&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:util=&quot;http://www.springframework.org/schema/util&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd&quot;&gt; (2) 使用 util 标签完成 list 集合注入提取 12345678910&lt;!--1、提取list集合类型属性注入使用--&gt; &lt;util:list id=&quot;bookList&quot;&gt; &lt;value&gt;java编程之美&lt;/value&gt; &lt;value&gt;java核心卷&lt;/value&gt; &lt;value&gt;MYSQL必知必会&lt;/value&gt; &lt;/util:list&gt; &lt;!--2、提取list集合类型属性注入使用--&gt; &lt;bean id=&quot;book&quot; class=&quot;com.oy.online.Spring.book&quot;&gt; &lt;property name=&quot;list&quot; ref=&quot;bookList&quot;&gt;&lt;/property&gt; &lt;/bean&gt; 七、IOC 操作 Bean 管理（FactoryBean） Spring 有两种类型 bean， 一种普通 bean, 另外一种工厂 bean(FactroyBean) 普通 bean: 在配置文件中定义 bean 类型就是返回类型 工厂 bean：在配置文件定义 bean 类型可以和返回类型不一样 第一步 创建类，让这个类为工厂 bean,实现接口 FactoryBean 第二步 实现接口里面的方法，在实现的方法中定义返回的 bean 类型 12345678910111213141516171819public class Mybean implements FactoryBean &#123; @Override public Course getObject() throws Exception &#123; Course course = new Course(); course.setCname(&quot;abc&quot;); return course; &#125; @Override public Class&lt;?&gt; getObjectType() &#123; return null; &#125; @Override public boolean isSingleton() &#123; return false; &#125;&#125; 1&lt;bean id=&quot;myBean&quot; class=&quot;com.oy.online.Spring.bean.Mybean&quot;&gt;&lt;/bean&gt; 123456789@org.junit.Test public void FactoryTest()&#123; // 加载Spring配置文件 ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean2.xml&quot;); // 获取创建对象 Course course = context.getBean(&quot;myBean&quot;, Course.class); System.out.println(course); &#125; 八、IOC 操作 Bean 管理（bean 作用域）1.在 Spring 里面，默认情况下，bean 是单实例对象1234567891011@org.junit.Testpublic void BookTest()&#123; // 加载Spring配置文件 ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean2.xml&quot;); // 获取创建对象 book book1 = context.getBean(&quot;book&quot;, book.class); book book2 = context.getBean(&quot;book&quot;, book.class); System.out.println(book1); System.out.println(book2);&#125; 2.设置单实例或多实例 在 Spring 配置文件 bean 标签里面有属性**(scope)**用于设置单实例还是多实例 scope 属性值 第一个值 默认值，singleton，表示是单实例 第二个值 prototype, 表示第多实例对象 123&lt;bean id=&quot;book&quot; class=&quot;com.oy.online.Spring.book&quot; scope=&quot;prototype&quot;&gt; &lt;property name=&quot;list&quot; ref=&quot;bookList&quot;&gt;&lt;/property&gt;&lt;/bean&gt; singleton 和 prototype 区别 第一 singleton 单实例，prototype 多实例 第二 设置 scope 值是 singleton 时候，加载 spring 配置文件时候就会创建单实例对象。 ​ 设置 scope 值是 prototype 时候，不是加载 spring 配置文件时候创建 对象，在调用 getBean 方法时候创建多实例对象。 九、IOC 操作 Bean 管理（bean 生命周期）1、生命周期 从对象创建到对象销毁的过程 2、bean 生命周期 通过构造器创建 bean 实例（无参数构造） 为 bean 的属性设置值 和 对其他 bean 引用（调用 set 方法） 调用 bean 的初始化的方法（需要进行配置初始化方法） bean 可以使用了（对象获取到了） 当容器关闭时候，调用 bean 的销毁方法（需要进行配置销毁的方法） 3、演示 bean 生命周期1234567891011121314151617181920212223public class Orders &#123; private String oname; // 无参构造器 public Orders()&#123; System.out.println(&quot;第一步 执行无参构造创建 bean 实例&quot;); &#125; public void setOname(String oname) &#123; this.oname = oname; System.out.println(&quot;第二步 调set方法设置属性值&quot;); &#125; // 创建执行的初始化的方法 public void initMethod()&#123; System.out.println(&quot;第三步 执行初始化的方法&quot;); &#125; // 创建执行的销毁的方法 public void destroyMethod()&#123; System.out.println(&quot;第五步 执行销毁的方法&quot;); &#125;&#125; 123&lt;bean id=&quot;orders&quot; class=&quot;com.oy.online.Spring.bean.Orders&quot; init-method=&quot;initMethod&quot; destroy-method=&quot;destroyMethod&quot;&gt; &lt;property name=&quot;oname&quot; value=&quot;手机&quot;&gt;&lt;/property&gt;&lt;/bean&gt; 1234567891011 @org.junit.Test public void OrdersTest()&#123;// ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean3.xml&quot;); ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean3.xml&quot;); Orders orders = context.getBean(&quot;orders&quot;, Orders.class); System.out.println(&quot;第四步 获取创建Bean 实例对象&quot;); System.out.println(orders); // 手动让bean实例销毁 context.close(); &#125; 4、bean 的后置处理器，bean 生命周期 通过构造器创建 bean 实例（无参构造器） 为 bean 的属性设置值和其他 bean 引用（调用 set 方法） **把 bean 的实例传递 bean 后置处理器的方法 **postProcessBefoInitialization 调用 bean 的初始化的方法 把 bean 实例传递 bean 后置处理器的方法 postProcessAfterInitialization bean 可以使用（对象获取到了） 当前容器关闭时，调用 bean 的销毁方法（需要精心配制销毁的方法） 5、添加后置处理器12345678910111213public class MybeanPost implements BeanPostProcessor &#123; @Override public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123; System.out.println(&quot;在初始化之前执行的方法&quot;); return bean; &#125; @Override public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123; System.out.println(&quot;在初始化之后执行的方法&quot;); return bean; &#125;&#125; 12&lt;!--配置后置处理器--&gt;&lt;bean id=&quot;myBeanPost&quot; class=&quot;com.oy.online.Spring.bean.MybeanPost&quot;&gt;&lt;/bean&gt; 十、IOC 操作 Bean 管理（XML 自动装配）1、自动装配 根据指定装配规则（属性名称或者属性类型），Spring 自动将匹配的属性值进行注入 2、自动装配过程（1）根据属性名称自动注入 1234567891011121314151617public class Emp &#123; private Dept dept; public void setDept(Dept dept) &#123; this.dept = dept; &#125; @Override public String toString() &#123; return &quot;Emp&#123;&quot; + &quot;dept=&quot; + dept + &#x27;&#125;&#x27;; &#125; public void test()&#123; System.out.println(dept); &#125;&#125; 123456public class Dept &#123; @Override public String toString() &#123; return &quot;Dept&#123;&#125;&quot;; &#125;&#125; 123456789&lt;!--实现自动装配 bean标签属性autowire,配置自动装配 autowire 属性常用两个值： byName 根据属性名称注入，注入值bean的id值和类型性名称一样 byType 根据属性类型注入--&gt;&lt;bean id=&quot;emp&quot; class=&quot;com.oy.online.Spring.autowire.Emp&quot; autowire=&quot;byName&quot;&gt;&lt;/bean&gt;&lt;bean id=&quot;dept&quot; class=&quot;com.oy.online.Spring.autowire.Dept&quot;&gt;&lt;/bean&gt; (2) 根据属性类型自动注入 123456789&lt;!--实现自动装配 bean标签属性autowire,配置自动装配 autowire 属性常用两个值： byName 根据属性名称注入，注入值bean的id值和类型性名称一样 byType 根据属性类型注入--&gt;&lt;bean id=&quot;emp&quot; class=&quot;com.oy.online.Spring.autowire.Emp&quot; autowire=&quot;byType&quot;&gt;&lt;/bean&gt;&lt;bean id=&quot;dept&quot; class=&quot;com.oy.online.Spring.autowire.Dept&quot;&gt;&lt;/bean&gt; 十一、IOC 操作 Bean 管理（外部属性文件） 直接配置数据库信息 （1）配置德鲁伊连接池 （2）引入德鲁伊连接池依赖 jar 包 1234567&lt;!--直接配置连接池--&gt;&lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;&gt;&lt;/property&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:8080/test&quot;&gt;&lt;/property&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot;&gt;&lt;/property&gt;&lt;/bean&gt; 引入外部属性文件配置数据库连接池 (1) 创建外部属性文件，properties 格式文件，写数据库信息 1234prop.driverClass=com.mysql.jdbc.Driverprop.url=jdbc:mysql://localhost:8080/testprop.username=rootprop.password=root ​ (2) 把外部 properties 属性文件引入到 spring 配置文件中 引入 context 名称空间 xmlns:context=”http://www.springframework.org/schema/context&quot; http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd 12345&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; 在 spring 配置文件使用标签引入外部属性文件 12345678910&lt;!--引入外部属性文件--&gt; &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt; &lt;!--配置连接池--&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;prop.driverClass&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;prop.url&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;prop.username&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;prop.password&#125;&quot;&gt;&lt;/property&gt; &lt;/bean&gt; 十二、IOC 操作 Bean 管理（基于注解方式） 1、注解​ （1）注解是代码的特殊标记，格式：@注解名称(属性名称=属性值，属性名称=属性值…) ​ （2）使用注解，注解作用在类上面，方法上面，属性上面 ​ （3）使用注解目的：简化 xml 配置 2、Spring 针对 Bean 管理中创建对象提供注解​ （1）@Component ​ （2）@Service ​ （3）@Controller ​ （4）@Repository 上面四个注解功能是一样的，都可以用来创建 bean 实例 3、基于注解方式实现对象创建第一步 引入依赖 第二步：开始组件扫描 12345&lt;!--开启组件扫描 1.如果扫描多个包，多个包使用逗号隔开 2.扫描包上的目录 --&gt; &lt;context:component-scan base-package=&quot;com.oy.online.Spring&quot;&gt;&lt;/context:component-scan&gt; 第三步 创建类，在类上面添加创建对象的注解 123456789//在注解里面 value 属性值可以省略不写，//默认值是类名称，首字母小写//UserService -- userService@Component(value = &quot;userService&quot;) //&lt;bean id=&quot;userService&quot; class=&quot;..&quot;/&gt;public class UserService &#123; public void add() &#123; System.out.println(&quot;service add.......&quot;); &#125;&#125; 4、开启组件扫描细节设置1234567&lt;!--示例 1 use-default-filters=&quot;false&quot; 表示现在不使用默认 filter，自己配置 filter context:include-filter ，设置扫描哪些内容--&gt;&lt;context:component-scan base-package=&quot;com.oy.online.Spring&quot; use-defaultfilters=&quot;false&quot;&gt; &lt;context:include-filter type=&quot;annotation&quot;expression=&quot;org.springframework.stereotype.Controller&quot;/&gt;&lt;/context:component-scan&gt; 1234567&lt;!--示例 2 下面配置扫描包所有内容 context:exclude-filter： 设置哪些内容不进行扫描--&gt;&lt;context:component-scan base-package=&quot;com.oy.online.Spring&quot;&gt; &lt;context:exclude-filter type=&quot;annotation&quot;expression=&quot;org.springframework.stereotype.Controller&quot;/&gt;&lt;/context:component-scan&gt; 5、基于注解方式实现属性注入（1）**@Autowired**: 根据属性类型进行自动装配 ​ 第一步：把 service 和 dao 对象创建，在 service 和 dao 类创建对象注解 ​ 第二步：把 service 注入 dao 对象， 在 service 类添加 dao 类型属性，在属性上面使用注解 123public interface UserDao &#123; public void add();&#125; 1234567@Repositorypublic class UserDaoImpl implements UserDao&#123; @Override public void add() &#123; System.out.println(&quot;dao add...&quot;); &#125;&#125; 12345678910111213@Servicepublic class UserService &#123; // 定义dao 类型属性 // 不需要添加 set 方法 // 添加注入属性注解 @Autowired private UserDao userDao; public void add()&#123; System.out.println(&quot;service add....&quot;); userDao.add(); &#125;&#125; 测试： 12345678@Test public void test()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean6.xml&quot;); UserService userService = context.getBean(&quot;userService&quot;, UserService.class); System.out.println(userService); userService.add(); &#125; （2）**@Qualifier**：根据名称进行注入 这个@Qualifier 注解的使用 ，和上面@Autowired 一起使用 123456//定义 dao 类型属性//不需要添加 set 方法//添加注入属性注解@Autowired //根据类型进行注入@Qualifier(value = &quot;userDaoImpl1&quot;) //根据名称进行注入private UserDao userDao; （3）**@Resource**: 可以根据类型注入，可以根据名称注入 123//@Resource //根据类型进行注入@Resource(name = &quot;userDaoImpl1&quot;) //根据名称进行注入private UserDao userDao; （4）**@Value**：注入普通类型的属性 12@Value(value = &quot;abc&quot;)private String name; 6、完全注解开发（1）创建配置类，替代 xml 配置文件 1234@Configuration // 作为配置类，替代xml 配置文件@ComponentScan(basePackages = &#123;&quot;com.oy.online.Spring&quot;&#125;)public class SpringConfig &#123;&#125; （2）测试类 123456789@Test public void SpringConfigTest()&#123; // 加载配置类 ApplicationContext context = new AnnotationConfigApplicationContext(SpringConfig.class); UserService userService = context.getBean(&quot;userService&quot;, UserService.class); System.out.println(userService); userService.add(); &#125;","categories":[{"name":"JavaEE框架","slug":"JavaEE框架","permalink":"http://blog.oy6090.top/categories/JavaEE%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"java","slug":"java","permalink":"http://blog.oy6090.top/tags/java/"},{"name":"Spring","slug":"Spring","permalink":"http://blog.oy6090.top/tags/Spring/"}]},{"title":"java集合之List、Set","slug":"java集合之List、Set","date":"2020-07-20T16:00:00.000Z","updated":"2021-01-22T03:51:06.496Z","comments":true,"path":"posts/28765.html","link":"","permalink":"http://blog.oy6090.top/posts/28765.html","excerpt":"","text":"Collection 子接口：List 接口一、存储的数据特点​ 有序的、可重复的数据 二、常用的方法 方法 描述 add(Object) 增加 remove（int index）/ remove(Object obj) 删除 set(int index , object ele) 修改 get(int index) 查找 add(int index， Object ele) 插入 size() 长度 ① Itertor 迭代器 ②foreach ③ for 遍历 三、常用的实现类 Collection 接口：单例集合，用来存储一个一个对象 List 接口；存储有序的，可重复的数据。 ArrayList: 作为 List 接口的主要的实现类：线程不安全，效率高：底层使用 Objecet[] elementDate 存储 LinkedList: 对于频繁的插入、删除操作，使用此类效率比 ArraList 高：底层使用双向链表存储。 Vector: 作为 List 接口的古老实现类：线程安全，效率低：底层使用 object[] elementDate 存储 四、源码分析 ArrayList 的源码分析 JDK 7 情况下： ArrayList list = new ArrayList(); 底层创建长度是 10 的 object[ ]数组 elementDate List.add(123); elementDate[0] = new Integer(123) …. list.add(11); 如果此次的添加导致底层 elementDate 数组容量不够，则扩容。 默认情况下：扩容为原来的 1.5 倍，同时需要将原有的数组中的数据复制到新的数组中。 结论：建议开发中使用带参的构造器：ArrayList list = new ArrayList(int capacity) JDK 8 中的 ArrayList 的变化： ArrayList list = new ArrayList(); 底层 object[ ] elementDate 初始化为{}，并没有创建长度为 10 的数组 list.add(123); 第一次调用 add()时，底层创建了长度为 10 的数组，并将数组 123 添加 dao elementDate[0] …. 后续的添加和扩容与 jdk 7 无异。 结论：jdk 7 中的 ArrayList 的对象的创建类似于单例的饿汉式，而 jdk 8 中的 ArrayList 的对象的创建类似于单例模式的懒汉式延迟了数组的创建，节省了空间。 LinkedList 的源码分析 LinkedList list = new LinkedList(); 内部声明的 Node 类型的 first 和 last 属性，默认值 null。 list.add(123); 将 123 封装到 Node 中，创建 Node 其中 Node 定义为：体现了 linkedList 的双向链表的说法 1234567891011private static class Node&lt;E&gt; &#123; E item; Node&lt;E&gt; next; Node&lt;E&gt; prev;//前 Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125;&#125; Vector 的源码分析 jdk 7 和 jdk 8 中通用 Vector() 构造器创建对象，底层都是创建 10 的数组。 在扩容方面。默认扩容为原数组的 2 倍。 五、存储元素的要求​ 添加对象，所在的类要重写 equals()方法 Collection 子接口：set 接口一、存储的数据特点​ 无序的，不可重复的元素 以 HashSet 为例说明 无序性：不等于随机性。存储的数据在底层数组中并非按照数组索引的顺序添加，而是根据数组的哈希值决定的。 不可重复性：保证添加的元素按照 equals()判断时，不能返回 true，即，相同的元素只能添加一个。 二、元素添加的过程：（以 HashSet 为例） 我们向 HashSet 中添加元素 a,首先调用元素 a 所在类的 hashcode()方法，计算元素 a 的哈希值，此哈希值接着某种算法在 HashSet 底层数组中的存放位置（即为：索引位置） 接着判断数组位置上是否已经有元素： 如果此位置上没有其他元素，则元素 a 添加成功。 —-》 情况 1 如果此位置上有其他元素 b(获以链表形式存在的多个元素，则比较元素 a 与元素 b 的 hash 值) 如果 hash 值不相同，则元素 a 添加成功。 —》 情况 2 如果 hash 值相同，进而需要调用元素的 a 所在类的 equals()方法 equals() 返回 true, 元素 a 添加失败 equals() 返回 false, 元素 a 添加成功。 —》 情况 3 对于添加成功的情况 2 和情况 3 而言：元素 a 与已经存在指定索引上数据以链表的方式存储。 JDK 7 ：元素 a 放大数组中，指向元素 a。 JDK 8 : 原来的元素在数组中，指向元素 a。 总结：七上八下 HashSet 底层：数组加链表的结构。(前提：jdk7) 三、常用的方法​ set 接口没有定义新的方法，使用的都是 collection 声明方法。 四、常用实现类 Collection 接口：单例集合，用来存储一个一个的对象、 set 接口：存储无序的、不可重复的数据 HashSet : 作为 Set 接口主要实现类；可以存储 null 值 LinkedHashSet: 作为 HashSet 的子类；遍历其内部数据时，可以按照添加的顺序遍历，造添加数据的同时，每一个数据还在维护两个引用。记录此数据的前一个和后一个数据。对于频繁的遍历操作，LinkedHashSetLinkedHashSet 效率高于 HashSet. TreeSet:可以添加对象的指定属性，进行排序。 五、存储对象所在类的要求 HashSet/LinkedHashSet： 要求:向 Set(主要指：HashSet、LinkedHashSet)中添加数据，其所在的类一定要重写hashcode()**和equals()**。 要求:重写的 HashCode() 和 equals() 尽可能保持一致：相等的对象必须具体的相等的散列码 ​ 重写的两个方法的小技巧：对象中用作 equals()方法比较的 Field，都应该用来计算 hashcode 值。 TreeSet: 自然排序中，比较两个对象是否相等的标准为：compareTo() 返回 0，不再是 equals() 定制排序中，比较两个对象是否相同的标准为：compare()返回 0.不再是 equals(). 六、TreeSet 的使用 向 TreeSet 中添加的数据，要求是相同类的对象。 两种排序方式：自然排序（实现 Comparable 接口 和 定制排序（Comparator） 自然排序： 创建 User 类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public class User implements Comparable&#123; private String name; private int age; public User() &#123; &#125; public User(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; User user = (User) o; return age == user.age &amp;&amp; name.equals(user.name); &#125; @Override public int hashCode() &#123; return Objects.hash(name, age); &#125; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &#x27;&#125;&#x27;; &#125; @Override public int compareTo(Object o) &#123; if(o instanceof User)&#123; User user = (User) o; if(this.name.equals(user.name))&#123; return this.age - user.age; &#125; return this.name.compareTo(user.name); &#125; throw new RuntimeException(&quot;输入的值无法判断&quot;); &#125;&#125; 1234567891011121314@Testpublic void test1() &#123; TreeSet set = new TreeSet(); set.add(new User(&quot;hunan&quot;, 12)); set.add(new User(&quot;beijing&quot;, 12)); set.add(new User(&quot;hunan&quot;, 9)); set.add(new User(&quot;fujian&quot;, 15)); set.add(new User(&quot;lingxia&quot;, 18)); Iterator iterator = set.iterator(); while(iterator.hasNext())&#123; System.out.println(iterator.next()); &#125;&#125; 定制排序 1234567891011121314151617181920212223242526272829@Testpublic void test2()&#123; Comparator com = new Comparator() &#123; @Override public int compare(Object o1, Object o2) &#123; if(o1 instanceof User &amp;&amp; o2 instanceof User)&#123; User user1 = (User) o1; User user2 = (User) o2; return Integer.compare(user1.getAge(), user2.getAge()); &#125;else&#123; throw new RuntimeException(&quot;输入的数据类型不匹配&quot;); &#125; &#125; &#125;; TreeSet set = new TreeSet(com); set.add(new User(&quot;Tom&quot;,12)); set.add(new User(&quot;Jerry&quot;,32)); set.add(new User(&quot;Jim&quot;,2)); set.add(new User(&quot;Mike&quot;,65)); set.add(new User(&quot;Mary&quot;,33)); set.add(new User(&quot;Jack&quot;,33)); set.add(new User(&quot;Jack&quot;,56)); Iterator iterator = set.iterator(); while(iterator.hasNext())&#123; System.out.println(iterator.next()); &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"http://blog.oy6090.top/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://blog.oy6090.top/tags/java%E5%9F%BA%E7%A1%80/"}]},{"title":"java集合之Collection","slug":"java集合之Collection","date":"2020-07-19T16:00:00.000Z","updated":"2021-01-22T03:50:45.267Z","comments":true,"path":"posts/30673.html","link":"","permalink":"http://blog.oy6090.top/posts/30673.html","excerpt":"","text":"数组与集合一、集合与数组存储数据的概述集合：数组都是对数据进行存储操作的结构，简称 Java 容器 说明：此时的存储，主要指的是内存层面的存储，不涉及到持久化的储存（.text,.jpg,avi,数据库中） 二、数组存储的特点一旦初始化以后，其长度就确定了。 数组一旦定义好，其元素的类型也就搞定了。我们也就只能操作指定类型的数据了。 比如：String[] arr; int[] arr1; Object[] arr2; 三、数组存储的弊端 一旦初始化以后，其长度就不可修改。 数组中提供的方法非常有限，对于添加、插入数据等操作，非常不便，同时效率不高。 获取数组中实际元素的个数的需求，数组没有规定的属性方法可用 数组存储的特点：有序、可重复性、对于无序、不可重复的需求，不能满足。 四、集合存储的优点​ 解决数组存储数据方面的弊端。 Collection 接口一、单列集合框架结构 Collection接口：单列集合，用来存储一个一个的对象 list接口：存储有序的、可重复的数据。(动态数组) ArrayList、LinkedList、Vector set接口：存储无序的、不可重复的数据 （集合） HashSet、LinkedHashSet、TreeSet 对应图示 二、Collection 接口常用方法 方法 描述 add(Object obj) 将元素 obj 添加到集合 coll 中 addAll(Collection coll) 将 coll1 集合中的元素添加到当前的集合中 isEmpty() 判断当前集合是否为空 clear() 清空集合元素 contains(Object obj) 判断当前集合中是否包含 obj containsAll(Collection coll) 判断形参 coll1 中的所有元素是否都存在于当前集合中。 remove(Object obj) 当前集合中移除 obj 元素 removeAll(Collection coll) 从当前集合中移除 coll1 中所有的元素 retainsAll(Collection coll) 获取当前集合和 coll1 集合的交集，并返回给当前集合 equals(Object obj) 相同返回 true，需要当前集合和形参集合的元素都相同。 hasCode() 返回当前对象的哈希值 toArray() 返回一个包含此集合中所有元素的数组。 iterator() 迭代器遍历 size() 获取添加的元素的个数 三、Collection 集合与数组的转换12345//集合 ---&gt; 数组：toArray()Object[] arr =coll.toArray();for(int i =0; i &lt; arr.length; i++)&#123; System.out.println(arr[i]);&#125; 123456789//拓展：数组 --&gt; 集合：调用Arrays类的静态方法asList(T ... t)List&lt;String&gt; list = Arrays.asList(new String[] &#123;&quot;AA&quot;,&quot;BB&quot;,&quot;CC&quot;&#125;);System.out.println(lis.size()); // 3List arr1 = Arrays.asList(new int[]&#123;123,456&#125;);System.oout.println(arr1.size());//1List arr2 = Arrays.asList(new Integer[]&#123;123,456&#125;);System.out.println(arr2.size());//2 四 、使用 Collection 集合存储对象，要求所属对象的类吗，满足​ 向 collection 接口的实现类的对象中添加数据 obj,要求 obj 所在类要重写 equals(); Iteratorj 接口与 foreach 循环一、遍历 Collection 的两种方式 使用迭代器 iterator foreach 循环（或增强 for 循环） 二、说明Iterator 对象成为迭代器（设计模式的一种），主要用于遍历 collection 集合中的元素。 GOF 给迭代器模式定义为：提供一个方法访问一个容器（container）对象中各个元素，而又不需要暴露该对象的内部细节。迭代器模式，就是为容器而生。 作用：遍历集合 Collection 元素 获取示例： coll.iterator()返回一个迭代器实例 遍历的代码实现： 123456Iterator iterator = coll.iterator();// hasNext():判断是否还有下一个元素while(iterator.hasNext())&#123; // next();①指针下移 ②将下移的以后的集合位置上的元素返回 System.out.prinln(iterator.next());&#125; 图示： remove()使用说明 测试 Iterator 中的 remove（） 如果还未调用 next（）或在上一次调用 next()方法之后已经调用 remove 方法，在调用 remove 报 IllegalStateException。 内部定义了 remove（）,可以在遍历的时候，删除集合中的元素。此方法不同于集合调用 remove() 代码示例： 1234567891011121314151617181920212223242526@Test public void test3()&#123; Collection coll = new ArrayList(); coll.add(123); coll.add(456); coll.add(new Person(&quot;Jerry&quot;,20)); coll.add(new String(&quot;Tom&quot;)); coll.add(false); //删除集合中&quot;Tom&quot; Iterator iterator = coll.iterator(); while (iterator.hasNext())&#123;// iterator.remove(); Object obj = iterator.next(); if(&quot;Tom&quot;.equals(obj))&#123; iterator.remove();// iterator.remove(); &#125; &#125; //遍历集合 iterator = coll.iterator(); while (iterator.hasNext())&#123; System.out.println(iterator.next()); &#125; &#125; 三、JDK5.0 新特性 – 增强 for 循环：（forech 循环） 遍历集合举例 123456789101112131415@Testpublic void test1()&#123; Collection coll = new ArrayList(); coll.add(123); coll.add(456); coll.add(new Person(&quot;Jerry&quot;,20)); coll.add(new String(&quot;Tom&quot;)); coll.add(false); //for(集合元素的类型 局部变量 : 集合对象) for(Object obj : coll)&#123; System.out.println(obj); &#125;&#125; 说明： ​ 内部仍调用了迭代器。 遍历数组举例： 12345678@Testpublic void test2()&#123; int[] arr = new int[]&#123;1,2,3,4,5,6&#125;; //for(数组元素的类型 局部变量 : 数组对象) for(int i : arr)&#123; System.out.println(i); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.oy6090.top/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://blog.oy6090.top/tags/Java/"}]},{"title":"Linux之Shell编程","slug":"Linux之Shell编程","date":"2020-07-17T16:00:00.000Z","updated":"2020-10-25T02:20:18.787Z","comments":true,"path":"posts/427140827.html","link":"","permalink":"http://blog.oy6090.top/posts/427140827.html","excerpt":"","text":"Shell 编程1.1 shell示例图： ​ ​ Shell 是一个命令行解释器， 它为用户提供了一个向 Linux 内核发送请求以便运行程序的界面系统级程序， 用户可以用 Shell 来启动、 挂起、 停止甚至是编写一些程序. 1.2 shell 编程快速入门-shell 脚本的执行方式1.2.1 脚本格式要求 脚本以#!/bin/bash 开头 执行脚本需要有执行的权限 1.2.2 编写第一个 shell 脚本 需求说明 创建一个 shell 脚本， 输出 hello world! 案例 12#!/bin/bashecho &quot;hello world&quot; 1.2.3 脚本的常用执行方式 方式 1(输入脚本的绝对路径或相对路径) 首先要赋予 helloworld.sh 脚本的+x 权限 执行脚本 方式 2(sh+脚本)， 不推荐 说明： 不用赋予脚本+x 权限， 直接执行即可 1.3 shell 的变量1.3.1 shell 的变量的介绍 linux shell 变量分为，系统变量和用户自定义变量 系统变量 ： $HOME、$PWD、 $SHELL、 $USER 等等 比如： echo $HOME 等等 显示当前 shell 中所有变量： set 1.3.2 shell 变量的定义 定义变量： 变量=值 撤销变量： unset 变量 声明静态变量： readonly 变量， 注意： 不能 unset 快速入门 案例 1： 定义变量 A 案例 2： 撤销变量 A 案例 3： 声明静态的变量 B=2， 不能 unset 1.3.3 定义变量的规则 变量名称可以由字母、 数字和下划线组成， 但是不能以数字开头。 等号两侧不能有空格 变量名称一般习惯为大写 1.3.4 将命令的返回值赋给变量（重点） A=`ls -la` 反引号， 运行里面的命令， 并把结果返回给变量 A A=$(ls -la) 等价于反引号 1.4 设置环境变量1.4.1 基本语法 export 变量名=变量值 （功能描述： 将 shell 变量输出为环境变量） source 配置文件 （功能描述： 让修改后的配置信息立即生效） echo $变量名 （功能描述： 查询环境变量的值） 快速入门 在/etc/profile 文件中定义 TOMCAT_HOME 环境变量 查看环境变量 TOMCAT_HOME 的值 1echo $TOMCAT_HOME 在另外一个 shell 程序中使用 TOMCAT_HOME 注意：在输出 TOMCAT_HOME 环境变量前，需要让其生效 1source /etc/profile 1.5 位置参数变量1.5.1 介绍​ 当我们执行一个 shell 脚本时， 如果希望获取到命令行的参数信息， 就可以使用到位置参数变量， 比如 ： ./myshell.sh 100 200 , 这个就是一个执行 shell 的命令行， 可以在 myshell 脚本中获取到参数信息 1.5.2 基本语法 指令 描述 $n 功能描述： n 为数字， $0 代表命令本身， $1-$9 代表第一到第九个参数， 十以上的参数， 十以上的参数需要用大括号包含， 如${10}） $* （功能描述： 这个变量代表命令行中所有的参数， $*把所有的参数看成一个整体） $@ （功能描述： 这个变量也代表命令行中所有的参数， 不过$@把每个参数区分对待） $# （功能描述： 这个变量代表命令行中所有参数的个数） 1.5.3 位置参数变量应用实例​ 案例： 编写一个 shell 脚本 positionPara.sh ， 在脚本中获取到命令行的各个参数信息 ​ 1.6 预定义变量1.6.1 基本语法 指令 描述 $$ （功能描述： 当前进程的进程号（PID） ） $! （功能描述： 后台运行的最后一个进程的进程号（PID） ） $？ （功能描述： 最后一次执行的命令的返回状态。 如果这个变量的值为 0， 证明上一个命令正确执行； 如果这个变量的值为非 0（具体是哪个数， 由命令自己来决定） ， 则证明上一个命令执行不正确了。 ） 1.6.2 应用实例在一个 shell 脚本中简单使用一下预定义变量 1.7 运算符1.7.1 基本语法 “$((运算式))” 或“$[运算式]” expr m + n 注意 expr 运算符间要有空格 expr m - n expr *, /, % 乘， 除， 取余 应用实例 案例 1： 计算（2+3） X4 的值 $((运算式)) $[运算式] expr 案例 2： 请求出命令行的两个参数[整数]的和 1.8 条件判断1.8.1 基本语法​ **[ condition ]**（注意 condition 前后要有空格） ​ #非空返回 true， 可使用$?验证（0 为 true， &gt;1 为 false） 1.8.2 应用实例​ [ atguigu ] 返回 true ​ [] 返回 false ​ [condition] &amp;&amp; echo OK || echo notok 条件满足， 执行后面的语句 ​ 1.8.3 常用判断条件 两个整数的比较 方法 描述 = 字符串比较 -lt 小于 -le 小于等于 -eq 等于 -gt 大于 -ge 大于等于 -ne 不等于 按照文件的权限进行判断 方法 描述 -r 有读的权限[-r 文件] -w 有写的权限 -x 有执行的权限 按照文件类型进行判断 方法 描述 -f 文件存在并且是一个常规的文件 -e 文件存在 -d 文件存在并是一个目录 1.8.4 应用实例​ 案例 1： “ok”是否等于”ok” ​ 判断语句： 案例 2： 23 是否大于等于 22 判断语句： 案例 3： /root/install.log 目录中的文件是否存在 判断语句： 1.9 流程控制1.9.1 if 判断 基本语法 123if[ 条件测试 ];then 程序fi 或者 1234567if[ 条件判断式 ]then 程序elif[ 条件判断式 ]then 程序fi 注意事项： （1） [ 条件判断式 ]， 中括号和条件判断式之间必须有空格 ​ (2) 推荐使用第二种方式 应用实例 案例： 请编写一个 shell 程序， 如果输入的参数， 大于等于 60， 则输出 “及格了”， 如果小于 60,则输出 “不及格” 1.9.2 case 语句 基本语法 123456789101112case $变量名 in&quot;值 1&quot;）如果变量的值等于值 1， 则执行程序 1;;&quot;值 2&quot;）如果变量的值等于值 2， 则执行程序 2;;…省略其他分支…*）如果变量的值都不是以上的值， 则执行此程序 Linux 课程;;esac 应用实例 案例 1 ： 当命令行参数是 1 时， 输出 “周一”, 是 2 时， 就输出”周二”， 其它情况输出 “other” 1.9.3 for 循环 基本语法 1 1234for 变量值 in 值1 值2 值3...do 程序done 应用实例 案例 1 ： 打印命令行输入的参数 【会使用到$* $@】 基本语法 2 1234567for(( 初始值:循环控制条件;变量变化))do 程序done 应用实例 案例 1 ： 从 1 加到 100 的值输出显示 1.10 while 循环 基本语法 1234while [ 条件判断式 ]do 程序done 应用实例 案例 1 ： 从命令行输入一个数 n， 统计从 1+..+ n 的值是多少？ 1.11 read 读取控制台输入1.11.1 基本语法1read(选项)(参数) 选项： 指令 描述 -p 指定读取值时的提示符； -t 指定读取值时等待的时间（秒） ， 如果没有在指定的时间内输入， 就不再等待了 参数： 变量：指定读取值的变量名 1.11.2 应用实例案例 1： 读取控制台输入一个 num 值案例 2： 读取控制台输入一个 num 值， 在 10 秒内输入 1.12 函数1.12.1 函数介绍​ shell 编程和其它编程语言一样， 有系统函数， 也可以自定义函数。 系统函数中， 我们这里就介绍两个。 1.12.2 系统函数 basename 基本语法 功能： 返回完整路径最后 / 的部分， 常用于获取文件名 basename [pathname] [suffix] basename [string] [suffix] （功能描述： basename 命令会删掉所有的前缀包括最后一个（‘/’ ）字符， 然后将字符串显示出来。 选项：suffix 为后缀， 如果 suffix 被指定了， basename 会将 pathname 或 string 中的 suffix 去掉。 dirname 基本语法 功能： 返回完整路径最后 / 的前面的部分， 常用于返回路径部分 dirname 文件绝对路径 （功能描述： 从给定的包含绝对路径的文件名中去除文件名（非目录的部分） ， 然后返回剩下的路径（目录的部分） ） 1.12.3 应用实例案例 1： 请返回 /home/aaa/test.txt 的 “test.txt” 部分 案例 2： 请返回 /home/aaa/test.txt 的 /home/aaa 1.12.4 自定义函数 基本语法 123456[ function ] funname[()]&#123; Action; [return int;]&#125;调用直接写函数名： funname [值] 应用实例 案例 1： 计算输入两个参数的和（read） ， getSum 1.13 shell 编程综合案例需求分析 每天凌晨 2:10 备份 数据库 atguiguDB 到 /data/backup/db 备份开始和备份结束能够给出相应的提示信息 备份后的文件要求以备份时间为文件名， 并打包成 .tar.gz 的形式， 比如： 2020-07-22_230201.tar.gz 在备份的同时， 检查是否有 10 天前备份的数据库文件， 如果有就将其删除。 编写一个 shell 脚本 思路分析： 代码实现：","categories":[{"name":"Linux","slug":"Linux","permalink":"http://blog.oy6090.top/categories/Linux/"}],"tags":[{"name":"CentOS 7","slug":"CentOS-7","permalink":"http://blog.oy6090.top/tags/CentOS-7/"}]},{"title":"Linux 搭建 JavaEE 环境","slug":"Linux 搭建 JavaEE 环境","date":"2020-07-15T16:00:00.000Z","updated":"2020-10-25T02:20:58.840Z","comments":true,"path":"posts/2922948377.html","link":"","permalink":"http://blog.oy6090.top/posts/2922948377.html","excerpt":"","text":"LInux 搭建 JavaEE 环境一、安装 JDK(1.8)先将软件通过 xftp5 上传到 /opt 下 解压缩到 /opt 配置环境变量的配置文件 vim /etc/profile 123JAVA_HOME&#x3D;&#x2F;opt&#x2F;opt&#x2F;jdk1.8.0_261PATH&#x3D;&#x2F;opt&#x2F;jdk1.8.0_261&#x2F;bin:$PATHexport JAVA_HOME PATH 需要注销用户，环境变量才能生效 如果是在 3 运行级别， logout 如果是在 5 的运行级别 在任何目录下就可以使用 java 和 javac 测试是否安装成功 编写一个简单的 Hello.java 输出”hello,world!” 12345public class Hello&#123; public static void main(String[] args)&#123; System.out.println(&quot;hello&quot;); &#125;&#125; 使用 javac 编译 , 在使用 java 执行 二、Tomcat 服务器搭建 解压缩到/opt 2**.启动 tomcat ./startup.sh** ​ 先进入到 tomcat 的 bin 目录 ​ ​ ​ 在 liunx 浏览器中，输入 http://localhost:808 启动成功即可。 开放端口 8080 ,这样外网才能访问到 tomcat （CentOS7） ① 检验防火墙是否启动 ​ 输入命令 “ ==firewall-cmd –state== “ 如果出现如图所示的这种情况说明正在运行，如果没有正在运行需要执行命令” ==systemctl start firewalld== “开启防火墙服务 ​ ② 配置防火墙，开放 8080 端口 12firewall-cmd --zone&#x3D;public --add-port&#x3D;80&#x2F;tcp --permanentfirewall-cmd --reload 4.开放端口 8080 ,这样外网才能访问到 tomcat （CentOS7 以下） vim /etc/sysconfig/iptables 重启防火墙 ​ 三、Tomcat 启动失败解决方案（启动成功跳过） 启动 tomcat 进入 tomcat 所在的目录的 bin 的文件夹下执行” ./ startup.sh“ 命令 启动 tomcat ，如果出现下面这种情况说明 tomcat 启动 成功。 验证 tomcat 是否启动成功 输入” ps -ef|grep tomcat “ 命令验证 tomcat 是否启动成功，如果出现下面这种情况说明启动成功。 若启动成功，在 linux 中输入 curl http://192.168.112.130:8080（自己 linux 的 ip）看是否正常访问。 如下则表示正常访问： 检验防火墙是否启动 输入命令 “ ==firewall-cmd –state== “ 如果出现如图所示的这种情况说明正在运行，如果没有正在运行需要执行命令” ==systemctl start firewalld== “开启防火墙服务 检查 8080 端口是否被防火墙开启 输入命令” ==firewall-cmd –permanent –zone=public –list-ports== “ 如果终端输出 “8080/tcp” 则说明 8080 端口被开启 如果没有该输出则需要执行命令” ==firewall-cmd –zone=public –add-port=8080/tcp –permanent==”开启 8080 端口, 出现” ==success==” 则表示添加成功。 重新启动防火墙 输入命令” firewall-cmd –reload” 重新启动防火墙，出现” success“ 字样则表示重新启动成功。 验证开启的 8080 端口是否生效 输入命令” firewall-cmd –zone=public –query-port=8080/tcp“ 验证 8080 端口是否生效，如果出现 ” yes “字样则代表生效。 此时，重新启动 tomcat 就可以使用外部浏览器访问 centos 中的 tomcat 啦。 补充： ​ 如果以上还没有解决，或者 tomcat 提示需要配置环境。请去去查看你的JDK的配置信息，配置文件在安装 JDK 中以提及。没有发现问题，可以重启 Linux,重新登入。 四 、Eclipse 的安装 解压缩到/opt 启动 eclipse 进入到 eclipse 解压后的文件夹， 然后执行 ./eclipse 五、mysql 的安装和配置【说明】：因为 mysql 安装时间较长，所以我已经把安装步骤放到我博客的文件中了。有需要的话。点击链接下载即可。或者你可以百度用 yum 安装。 提取码：9ifr 查看文档","categories":[{"name":"Linux语言","slug":"Linux语言","permalink":"http://blog.oy6090.top/categories/Linux%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"CentOS 7","slug":"CentOS-7","permalink":"http://blog.oy6090.top/tags/CentOS-7/"}]},{"title":"Linux 笔记【适用新手】","slug":"Linux笔记","date":"2020-07-15T16:00:00.000Z","updated":"2020-10-25T02:20:39.606Z","comments":true,"path":"posts/2761314235.html","link":"","permalink":"http://blog.oy6090.top/posts/2761314235.html","excerpt":"","text":"博客中所需要的工具我已经打包好，放在博客文章最后。 里面包含了: PDF 版知识点 Xshell Xftp 第一章 开机、重启和用户登录注销Linux 目录结构： 1.1 关机&amp;重启命令 shutdown shutdown -h now : 表示立即关机 shutdown -h 1 : 表示 1 分钟后关机 shutdown -r now : 立即重启 halt 就是直接使用，效果等价于关机 reboot 就是重启系统 syn 把内存的数据同步到磁盘 1.2 用户基本登入和注销1.2.1 基本介绍​ 1）登入时尽量少用 root 登录，因为它是系统管理员，最大权限，避免操作失误。可利用普通用户登录，登入后再用**”su -用户名”** 命令来切换成系统管理员身份. ​ 2) 在提示符输入 logout 即可以注销用户 第二章 用户管理2.1 添加用户2.1.1 基本语法​ useradd [选项] 用户名 2.1.2 实际案例​ 添加一个用户 xm ​ ​ 特别说明 ​ cd 表示 change directory 2.1.3 细节说明​ 1）当创建用户成功后，会自动的创建和用户名同名的家的目录 ​ 2） 也可以通过 useradd - d 指定目录 新的用户名，给新创建的用户指定家目录 2.2 给用户指定或修改密码2.2.1 基本语法​ passwd 用户名 2.2.2 应用案例​ 1） 给 xm 指定密码 ​ 2.3 删除用户2.3.1 基本语法​ userdel 用户名 2.3.2 应用案例​ 1）删除用户 xm, 但是要保留加目录 ​ ​ 2）删除用户 xq 以及用户主目录 ​ 2.4 查询用户信息2.4.1 基本语法​ id 用户名 2.4.2 应用实例​ 案例 1：请查询 root 信息 ​ 2.4.3 细节说明​ 1）当用户不存在时，返回“无此用户” 2.5 切换用户2.5.1 介绍​ 在操作 Linux 中，如果当前用户的权限不够，可以通过 su - 指令，切换到高权限用户，比如 root。 2.5.2 基本语法​ su - 切换用户名 2.5.3 应用实例​ 1) 创建一个用户 zf, 指定密码，然后切换到 zf ​ 2.5.4 细节说明​ 1）从权限高的用户切换到权限低的用户，不需要输入密码，反之需要 ​ 2）当需要返回到原来的用户时，使用exit命名 2.6 用户组2.6.1 介绍​ 类似于角色， 系统可以对有共性的多个用户进行统一的管理。 2.6.2 增加组groupadd 组名 2.6.3 案例演示​ 2.6.4 删除组​ 指令（基本语法） groupdel 组名 2.6.5 案例演示​ 2.7 增加用户时直接加上组2.7.1 指令（基本语法）​ useradd -g 用户组 用户名 2.7.2 案例演示​ 增加一个用户 zwj, 直接将他指定到 wudang ​ 2.8 修改用户的组2.8.1 指令（基本语法）​ usermod -g 用户组 用户名 2.8.2 案例演示​ 创建一个 shaolin 组， 让将 zwj 用户修改到 shaolin 2.9 /etc/passwd 文件​ 用户(user) 的配置文件，记录用户的各种信息 ​ 每行的含义：用户名：口令：用户标识符：组标识号：注释性描述：主目录：登录 Shell 操作代码 ​ 2.10 /etc/shadow 文件​ 口令的配置文件 ​ 每行的含义： 登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动 时间:失效时间:标志 2.11 /etc/group 文件​ 组(group)的配置文件 ，记录 Linux 包含的组的信息 ​ 每行含义：组名:口令:组标识号:组内用户列表 ​ 第三章 实用指令3.1 指定运行的级别3.1.1 运行级别说明： 0 ： 关机 1 ： 单用户【找回丢失密码】 2： 多用户状态没有网络服务 3： 多用户状态有网络服务 4： 系统未使用保留给用户 5： 图形界面 6： 系统重启 常用运行级别是 3 和 5 ， 要修改默认的运行级别可改文件 /etc/inittab 的 id:5:initdefault:这一行中的数字 3.1.2 运行级别的示意图：​ 3.2 切换到指定运行级别的指令3.2.1 基本语法​ init [0123456] ​ 补充： ​ 关于 root 密码忘记，改怎么用运行级别的指令来操作，每个版本不同，所以自行百度。 3.3 帮助指令3.3.1 介绍​ 当我们对某个指令不熟悉时， 我们可以使用 Linux 提供的帮助指令来了解这个指令的使用方法。 3.3.2 man 获取帮助信息 基本语法 man [命令或配置文件] （功能描述: 获取帮助信息） 实用案例 ​ 案例：查看 ls 命令的帮助信息 ​ 3.3.3 help 指令 基本语法 ​ help 命令 （功能描述： 获取 shell 内置命令的帮助信息） 应用案例 ​ 案例： 查看 cd 命令的帮助信息 ​ 3.4 文件目录类3.4.1 pwd 指令 基本用法 ​ pwd (功能描述： 显示当前工作目录的绝对路径) 应用实例 ​ 案例：显示当前工作目录的绝对路径 3.4.2 ls 指令 基本语法 ​ ls [选项] [目录或是文件] 应用案例 ​ -a : 显示当前目录所在的文件和目录，包括隐藏的。 ​ -l : 以列表的方式显示信息 应用实例 ​ 案例： 查看当前目录的所在的内容信息 ​ 3.4.3 cd 指令 基本语法 ​ cd [参数] （功能切换到指定目录） 常用参数 ​ ==绝对路径== 和 ==相对路径== ​ ​ cd ~ 或者 cd : 回到自己的家目录 ​ cd.. 回到当前目录的上一级目录 应用实例 ​ 案例 1： 使用绝对路径切换到 root 目录 ​ 案例 2： 回到家目录 3.4.4 mkdir 指令​ mkdir 指令用于创建目录（make directory） 基本用法 ​ mkdir [选项] 要创建的目录 常用选项 ​ -p : 创建多级目录 应用实例 ​ 案例 1:创建一个目录 /home/dog ​ ​ 案例 2:创建多级目录 /home/animal/tiger 3.4.5 rmdir 指令 介绍 ​ rmdir 指令删除空目录 基本语法 ​ rmdir [选项] 要删除的空目录 应用实例 ​ 案例 1:删除一个目录 /home/dog ​ 使用细节 ​ rmdir 删除的是空目录， 如果目录下有内容时无法删除的。​ 提示： 如果需要删除非空目录， 需要使用 rm -rf 要删除的目录 3.4.6 touch 指令​ touch 指令创建空文件 基本用法 ​ touch 文件名称 应用实例 ​ 案例 1: 创建一个空文件 hello.txt ​ 3.4.7 cp 指令​ cp 指令拷贝文件到指定的目录 基本用法 ​ cp [选项] source dest 常用选项 ​ -r : 递归复制整个文件夹 应用实例 ​ 案例 1: 将 /home/aaa.txt 拷贝到 /home/bbb 目录下[拷贝单个文件] 案例 2: 递归复制整个文件夹， 举例 ：将/home/test 整个目录拷贝到 /home/zwj 目录 使用细节 ​ 强制覆盖不提示的方法： \\cp ​ 3.4.8 rm 指令​ rm 指令移除【删除】 文件或目录 基本用法 ​ rm [选项] 要删除的文件或目录 常用选项 ​ -r : 递归删除整个文件夹 ​ -f : 强制删除不提示 应用实例 ​ 案例 1: 将 /home/aaa.txt 删除 ​ 案例 2: 递归删除整个文件夹 /home/bbb 使用细节 ​ 强制删除不提示的方法： 带上 -f 参数即可 ​ 3.4.9 cat 指令​ cat 查看文件内容， 是以只读的方式打开。 基本语法 cat [选项] 要查看的文件 常用选项 -n : 显示行号 应用实例 ​ 案例 1: /etc/profile 文件内容， 并显示行号 ​ 使用细节 ​ cat 只能修改文件， 而不能修改文件，为了浏览方便，一般会带上 管道命令 | more ​ cat 文件名 | more [分页浏览] 3.4.10 mv 指令​ mv 移动文件与目录或重命名 基本用法 ​ mv oldNameFile newNameFile (功能描述： 重命名)​ mv /temp/movefile /targetFolder (功能描述： 移动文件) 应用实例 ​ 案例 1: 将 /home/aaa.txt 文件 重新命名为 pig.txt ​ 案例 2:将 /home/pig.txt 文件 移动到 /root 目录下 3.4.11 more 指令​ more 指令是一个基于 VI 编辑器的文本过滤器， ==它以全屏幕的方式按页显示文本文件的内容==。more 指令中内置了若干快捷键， 详见操作说明 基本语法 ​ more 要查看的文件 应用实例 ​ 案例: 采用 more 查看文件 /etc/profile​ 快捷键 3.4.12 less 指令​ less 指令用来==分屏查看文件内容==， 它的功能与 more 指令类似， 但是比 more 指令更加强大， 支持各种显示终端。 less 指令在显示文件内容时， 并不是一次将整个文件加载之后才显示， 而是根据显示需要加载内容， 对于显示大型文件具有较高的效率。 基本语法 ​ less 要查看的文件 应用实例 案例: 采用 less 查看一个大文件文件 /opt/金庸-射雕英雄传 txt 精校版.txt 快捷键 3.4.13 &gt; 指令 和 &gt;&gt; 指令 介绍 ==&gt; 指令 和 &gt;&gt; 指令== &gt; 输出重定向 : 会将原来的文件的内容覆盖 &gt;&gt; 追加： 不会覆盖原来文件的内容， 而是追加到文件的尾部。 基本语法 1) ls -l &gt;文件 （功能描述： 列表的内容写入文件 a.txt 中（==覆盖写==） ） 说明： ls -l &gt; a.txt , 将 ls -l 的显示的内容覆盖写入到 a.txt 文件， 如果该文件不存在， 就创建该文件。 ​ 2) ls -al &gt;&gt;文件 （功能描述： 列表的内容追加到文件 a.txt 的末尾） ​ 3) cat 文件 1 &gt; 文件 2 （功能描述： 将文件 1 的内容覆盖到文件 2） 应用实例 ​ 案例 1: 将 /home 目录下的文件列表 写入到 /home/info.txt 中 ​ 案例 2: 将当前日历信息 追加到 /home/mycal 文件中 [提示 cal ] ​ 3.4.14 echo 指令​ echo 输出内容到控制台。 基本语法 echo [选项] [输出内容] 应用实例 案例: 使用 echo 指令输出环境变量,输出当前的环境路径。 3.4.15 head 指令​ head 用于显示文件的开头部分内容， 默认情况下 head 指令显示文件的前 10 行内容 基本语法 head 文件 (功能描述： 查看文件头 10 行内容)head -n 5 文件 (功能描述： 查看文件头 5 行内容， 5 可以是任意行数) 应用实例 案例: 查看/etc/profile 的前面 5 行代码 3.4.16 tail 指令​ tail 用于输出文件中尾部的内容， 默认情况下 tail 指令显示文件的后 10 行内容。 基本语法 tail 文件 （功能描述： 查看文件后 10 行内容） tail -n 5 文件 （功能描述： 查看文件后 5 行内容， 5 可以是任意行数） tail -f 文件 （功能描述： 实时追踪该文档的所有更新， 工作经常使用） 应用实例 案例 1: 查看/etc/profile 最后 5 行的代码 案例 2: 实时监控 mydate.txt , 看看到文件有变化时， 是否看到， 实时的追加日期 3.4.17 ln 指令软链接也叫符号链接，类似于 window 里的快捷方式，主要存放了链接其他文件的路径。 基本用法 In -s [原文件或目录]软连接] （功能描述：给原文件创建一个软链接） 应用实例 案例 1: 在/home 目录下创建一个软连接 linkToRoot， 连接到 /root 目录 案例 2: 删除软连接 linkToRoot 细节说明 当我们使用 pwd 指令查看目录时，仍然看到的是软链接所在的目录 3.4.18 history 指令​ 查看已经执行的历史命令，也可以执行历史的指令 基本用法 history (功能描述：查看已经执行的历史命令) 应用实例 案例 1: 显示所有的历史命令 案例 2: 显示最近使用过的 10 个指令。 案例 3： 执行历史编号为 5 的指令 3.5 时间日期类3.5.1 date 指令-显示当前日期 基本用法 1）date (功能描述： 显示当前时间) 2）date+%Y （功能描述：显示当前年份） 3）date +%m (功能描述： 显示当前月份) 4）date + %d (功能描述：显示当前是哪一天) 5）date”+Y-%m-%d%H:%M:%S” (功能描述： 显示年月份时分秒) 应用实例 案例 1: 显示当前时间信息 案例 2: 显示当前时间年月日 案例 3: 显示当前时间年月日时分秒 ​ 3.5.2 date 指令- 设置日期 基本语法 date -s 字符串时间 应用实例 案例 1: 设置系统当前时间 ， 比如设置成 2020-10-10 11:22:22 3.5.3 cal 指令​ 查看日历的指令 基本指令 cal [选项] （功能描述） 应用实例 案例 1: 显示当前日历 ​ 案例 2: 显示 2020 年日历 ​ 3.6 搜索查找类3.6.1 find 指令​ find 指令将从指定目录向下递归地遍历其各个子目录， 将满足条件的文件或者目录显示在终端。 基本用法 find [搜索范围] [选项] 选项说明 应用实例 案例 1: 按文件名： 根据名称查找/home 目录下的 hello.txt 文件 案例 2： 按拥有者： 查找/opt 目录下， 用户名称为 nobody 的文件 ​ 案例 3： 查找整个 linux 系统下大于 20m 的文件（+n 大于 -n 小于 n 等于） ​ ​ 查询 / 目录下， 所有 .txt 的文件 3.6.2 Locate 指令​ locaate 指令可以快速定位文件路径。 locate 指令利用事先建立的系统中所有文件名称及路径的 ocate 数据库实现快速定位给定的文件。 Locate 指令无需遍历整个文件系统， 查询速度较快。 为了保证查询结果的准确度， 管理员必须定期更新 locate 时刻。 基本语法 locate 搜索文件 特别说明 由于 locate 指令基于数据库进行查询， ==所以第一次运行前， 必须使用 updatedb 指令创建 locate 数据库。== 应用案例 案例 1: 请使用 locate 指令快速定位 hello.txt 文件所在目录 3.6.3 grep 指令 和 管道符号​ grep 过滤查找 ， 管道符， “|”， 表示将前一个命令的处理结果输出传递给后面的命令处理。 基本用法 grep [选项] 查找内容 常用选项 应用实例 案例 1: 请在 hello.txt 文件中， 查找 “yes” 所在行， 并且显示行号 3.7 压缩和解压类3.7.1 gzip/gunzip 指令​ gzip 用于压缩文件，gunzip 用于解压 基本用法 gzip 文件 （功能描述） gunzip 文件 （功能描述：解压文件命令） 应用实例 案例 1: gzip 压缩， 将 /home 下的 hello.txt 文件进行压缩 案例 2: gunzip 压缩， 将 /home 下的 hello.txt.gz 文件进行解压缩 细节说明 当我们使用 gzip 对文件进行压缩后，捕获保留原来的文件 3.7.2 zip/unzip 指令​ zip 用于压缩文件，unzip 用于解压的，这个在项目打包发布中很有用的 基本用法 zip [选项]XXX.zip 将要压缩地内容（功能描述：压缩文件和目录的命令） unzip [选项] XXX.zip （功能描述：解压缩文件） 常用选项 -r 递归压缩，即压缩目录 unzip 的常用选项 -d&lt;目录&gt;： 指定解压后文件的存放目录 应用实例 案例 1: 将 /home 下的 所有文件进行压缩成 mypackage.zip 案例 2: 将 mypackge.zip 解压到 /opt/tmp 目录下 3.7.3 tar 指令​ tar 指令 是打包指令 ，最后打包的文件是**.tar.gz** 的文件 基本语法 tar [选项] XXX.tar.gz 打包的内容 （功能描述：打包目录,压缩后的文件格式.tar.gz） 选项说明 应用实例 案例 1: 压缩多个文件， 将 /home/a1.txt 和 /home/a2.txt 压缩成 a.tar.gz 案例 2: 将/home 的文件夹 压缩成 myhome.tar.gz 案例 3: 将 a.tar.gz 解压到当前目录 案例 4: 将 myhome.tar.gz 解压到 /opt/ 目录下 ==指定解压到的那个目录， 事先要存在才能成功， 否则会报错。== 第四章 组管理和权限管理4.1 Linux 组基本介绍​ 在 linux 中的每个用户必须属于一个组， 不能独立于组外。 在 linux 中每个文件有所有者、 所在组、 其它组的概念。​ 1) 所有者​ 2) 所在组​ 3) 其它组​ 4) 改变用户所在的组 4.2 文件/目录 所有者4.2.1 查看文件的所有者 指令： ls -ahl 应用实例：创建一个组 polic，在创建一个用户 tom，将 tom 放在 polic 组，然后使用 tom 来创建一个文件 ok.txt,看看情况如何 4.2.3 修改文件所有者 指令 chown 用户名 文件名 应用实例 要求： 使用 root 创建一个文件 apple.txt，然后将其所有者修改成 tom 4.3 组的创建4.3.1 基本指令​ groupadd 组名 4.3.2 应用实例​ 创建一个组，monster ​ 创建一个用户 fox , 并放入到 monster 组中 ​ 4.4 文件/目录 所在组​ 当某个用户创建了一个文件后， 默认这个文件的所在组就是该用户所在的组。 4.4.1 查看文件/目录所在组 基本指令 ls -alh 4.4.2 修改文件所在的组 基本指令 chgrp 组名 文件名 应用实例 使用 root 用户创建文件 orange.txt ,看看当前这个文件属于哪个组， 然后将这个文件所在组， 修改到 police 组。 4.5 其它组​ 除文件的所有者和所在组的用户外， 系统的其它用户都是文件的其它组. 4.6 改变用户所在组​ 在添加用户时， 可以指定将该用户添加到哪个组中， 同样的用 root 的管理权限可以改变某个用户所在的组。 4.6.1 改变用户所在组 ​ usermod - g 组名 用户名 ​ usermod -d 目录名 用户名 改变该用户登陆的初始目录 4.6.2 应用实例​ 4.7 权限的基本介绍​ ls -l 中显示的内容如下： ​ -rwxrw-r– 1 root root 1213 Feb 2 09:39 abc ​ ==0-9 位说明== 第 0 位确定文件类型(d, -, c, b) 第 1-3 位确定所有者（该文件的所有者）拥有该文件的权限。 —User 第 4-6 位确定所属组（同用户组的） 拥有该文件的权限， —Group 第 7-9 位确定其他用户拥有该文件的权限 —Other 4.8 rwx 权限的详解4.8.1 rwx 作用到文件 [ r ]代表可读(read): 可以读取,查看 [ w ]代表可写(write): 可以修改,但是不代表可以删除该文件,删除一个文件的前提条件是对该文件所在的目录有写权限， 才能删除该文件 [ x ]代表可执行(execute):可以被执行 4.8.2 rwx 作用到目录 [ r ]代表可读(read): 可以读取， ls 查看目录内容 [ w ]代表可写(write): 可以修改,目录内创建+删除+重命名目录 [ x ]代表可执行(execute):可以进入该目录 4.9 文件及目录权限的实际案例​ ls -l 中显示的内容如下： ==(记住)== ​ -rwxrw-r– 1 root root 1213 Feb 2 09:39 abc 10 个字符确定不同用户能对文件干什么 ​ 第一个字符代表文件类型： 文件 (-),目录(d),链接(l)​ 其余字符每 3 个一组(rwx) 读(r) 写(w) 执行(x)​ 第一组 rwx : 文件拥有者的权限是读、 写和执行​ 第二组 rw- : 与文件拥有者同一组的用户的权限是读、 写但不能执行​ 第三组 r– : 不与文件拥有者同组的其他用户的权限是读不能写和执行 可用数字表示为: r=4,w=2,x=1 因此 rwx=4+2+1=7 1 文件： 硬连接数或 目录： 子目录数 root 用户 root 组 1213 文件大小(字节)， 如果是文件夹， 显示 4096 字节 Feb 2 09:39 最后修改日期 abc 文件名 4.10. 修改权限-chmod4.10.1 基本说明​ 通过 chmod 指令，可以修改文件或者目录的权限 4.10.2 第一种方式： + 、-、= 变更权限​ u ： 所有者 g: 所有组 o:其他人 a:所有人（u、g、o 的总和） chmod u= rwx , g = rx , o=x 文件目录名 chmod o+w 文件目录名 chmod a-x 文件目录名 案例演示 给 abc 文件 的==所有者读写执行的权限==， 给==所在组读执行权限==， 给其它组读执行权限。 给 abc 文件的所有者除去执行的权限， 增加组写的权限 4.10.3 第二种方式： 通过数字变更权限​ 规则： ​ r=4 w=2 x=1 rwx=4+2+1=7 ​ chmod u=rwx,g=rx,o=x 文件目录名 ​ 相当于 chmod 751 文件目录名 案例演示 要求： 将 /home/abc.txt 文件的权限修改成 rwxr-xr-x, 使用给数字的方式实现： rwx = 4+2+1 = 7 r-x = 4+1=5 r-x = 4+1 =5 4.11 修改文件所有者-chown4.11.1 基本介绍​ chown newowner file 改变文件的所有者 ​ chown newowner:newgroup file 改变用户的所有者和所有组 ​ -R 如果是目录 则使其下所有的子文件或目录递归生效 4.11.2 案例演示​ 1. 请将 /home/abc .txt 文件的所有者修改成 tom ​ 2. 请将 /home/kkk 目录下所有的文件和目录的所有者都修改成 tom ![image-20200714123616286](https://gitee.com/oy_chart_bed/no1_drawing_bed/raw/master/20200714123617.png) 4.12 修改文件所在组-chgrp4.12.1 基本介绍​ chgrp newgroup file 改变文件的所有组 4.12.2 案例演示​ 1.请将 /home/abc .txt 文件的所在组修改成 bandit (土匪) ​ ​ 2**.请将 /home/kkk 目录下所有的文件和目录的所在组都修改成 bandit(土匪)** ​ 4.13 实战练习题目： 最佳实践-警察和土匪游戏 ​ police ， bandit ​ jack, jerry: 警察​ xh, xq: 土匪 (1) 创建组 (2) 创建用户 同时给 4 个用户设置密码：（示例） ​ (3) jack 创建一个文件， 自己可以读写， 本组人可以读， 其它组没人任何权限 (4) jack 修改该文件， 让其它组人可以读, 本组人可以读写 (5) xh 投靠 警察， 看看是否可以读写. 先用 root 修改 xh 的组 ： 使用 jack 给他的家目录 /home/jack 的所在组一个 rx 的权限 xh 需要重新注销在到 jack 目录就可以操作 jack 的文件 第五章 crond 任务调度5.1 原理示意图 crontab 进行 定时任务的设置 5.2 基本语法​ crontab [选项] 5.2.1 常用选项 5.3 快速入门5.3.1 任务的要求​ 设置任务的调度文件： /ect/crontab ​ 设置个人任务调度。执行 crontab -e 命令 ​ 接着输入任务到调度文件 ​ 如： _/1 _ * * * ls – l /etc/ &gt; /tmp/to.txt​ 意思说每小时的每分钟执行 ls – l /etc/ &gt; /tmp/to.txt 命令 5.3.2 步骤如下 cron -e _/ 1 _ * * * ls -l /etc &gt;&gt; /tmp/to.txt 保存退出就会启动程序。 在每一分钟都会自动保存的调用 ls -l /etc &gt;&gt; /tmp/to.txt 5.3.3 参数细节说明 5个占位符的说明 特殊符号说明 特定时间执行任务案例 5.4 任务调度的几个使用案例5.4.1 案例 1：每隔 1 分钟，就将当前的日期信息，追加到/tmp/mydate 文件中 先编写一个文件 /home/mytask1.shdate &gt;&gt; /tmp/mydate 给 mytask1.sh 一个可以执行权限chmod 744 /home/mytask1.sh crontab -e _/1 _ * * * /home/mytask1.sh 成功 5.4.2 案例 2：每隔 1 分钟， 将当前日期和日历都追加到 /home/mycal 文件中 1.先编写一个文件 /home/mytask2.shdate &gt;&gt; /tmp/mycalcal &gt;&gt; /tmp/mycal 给 mytask1.sh 一个可以执行权限chmod 744 /home/mytask2.sh crontab -e _/1 _ * * * /home/mytask2.sh 成功 5.4.3 案例 3:每天凌晨 2:00 将 mysql 数据库 testdb ， 备份到文件中 mydb.bak。 先编写一个文件 /home/mytask3.sh/usr/local/mysql/bin/mysqldump -u root -proot testdb &gt; /tmp/mydb.bak 给 mytask3.sh 一个可以执行权限chmod 744 /home/mytask3.sh crontab -e 0 2 * * * /home/mytask3.sh 成功 5.5 crond 相关指令 crontab -r : 终止任务调度。 crontab -l : 列出当前有哪些任务调度 service crond restart : [重启任务调度] 第六章 Linux 磁盘分区、挂载6.1 分区基础知识6.1.1 分区的方式mbr 分区 最多支持四个主分区 系统只能安装在主分区 扩展分区要占一个主分区 MBR 最大只支持 2TB， 但拥有最好的兼容性 gtp 分区 支持无限多个主分区（但操作系统可能限制， 比如 windows 下最多 128 个分区） 最大支持 18EB 的大容量（1EB=1024 PB， 1PB=1024 TB ） windows7 64 位以后支持 gtp 6.2 Linux 分区6.2.1 原理介绍 Linux 来说无论有几个分区， 分给哪一目录使用， 它归根结底就只有一个根目录， 一个独立且唯一的文件结构 , Linux 中每个分区都是用来组成整个文件系统的一部分。 Linux 采用了一种叫“载入” 的处理方法， 它的整个文件系统中包含了一整套的文件和目录，且将一个分区和一个目录联系起来。 这时要载入的一个分区将使它的存储空间在一个目录下获得。 示意图： 6.2.2 硬盘说明 Linux 硬盘分 IDE 硬盘和 SCSI 硬盘， 目前基本上是 SCSI 硬盘 对于 IDE 硬盘， 驱动器标识符为“hdx”,其中“hd”表明分区所在设备的类型， 这里是指 IDE 硬盘了。 “x”为盘号（a 为基本盘， b 为基本从属盘， c 为辅助主盘， d 为辅助从属盘） ,“”代表分区，前四个分区用数字 1 到 4 表示， 它们是主分区或扩展分区， 从 5 开始就是逻辑分区。 例， hda3 表示为第一个 IDE 硬盘上的第三个主分区或扩展分区,hdb2 表示为第二个 IDE 硬盘上的第二个主分区或扩展分区。 对于 SCSI 硬盘则标识为“sdx~”， SCSI 硬盘是用“sd”来表示分区所在设备的类型的， 其余则和 IDE 硬盘的表示方法一样。 6.2.3 使用 lsblk 指令查看当前系统的分区情况 6.3 挂载的经典案例需求是给我们的 Linux 系统增加一个新的硬盘， 并且挂载到/home/newdisk 6.3.1 如何增加一块硬盘 虚拟机添加硬盘 分区 fdisk /dev/sdb 格式化 mkfs -t ext4 /dev/sdb1 挂载 先创建一个 /home/newdisk , 挂载 mount /dev/sdb1 /home/newdisk 设置可以自动挂载(永久挂载， 当你重启系统， 仍然可以挂载到 /home/newdisk) 。 vim /etc/fstab/dev/sdb1 /home/newdisk ext4 defaults 0 0 6.4 具体的操作步骤整理6.4.1 虚拟机增加硬盘步骤 1​ 在【虚拟机】 菜单中， 选择【设置】 ， 然后设备列表里添加硬盘， 然后一路【下一步】 ， 中间只选择磁盘大小的地方需要修改， 至到完成。 然后重启系统（才能识别） ！ 6.4.2 虚拟机增加硬盘步骤 2​ 分区命令 fdisk /dev/sdb​ 开始对/sdb 分区​ •m 显示命令列表​ •p 显示磁盘分区 同 fdisk – l​ •n 新增分区​ •d 删除分区​ •w 写入并退出 **==说明：==**开始分区后输入 n， 新增分区， 然后选择 p ， 分区类型为主分区。 两次回车默认剩余全部空间。 最后输入 w 写入分区并退出， 若不保存退出输入 q。 6.4.3 虚拟机增加硬盘步骤 3​ 格式化磁盘 ​ 分区命令:mkfs -t ext4 /dev/sdb1​ 其中 ext4 是分区类型 6.4.4 虚拟机增加硬盘步骤 4​ 挂载: 将一个分区与一个目录联系起来，​ •mount 设备名称 挂载目录​ •例如： mount /dev/sdb1 /newdisk​ •==umount 设备名称 或者 挂载目录== 6.4.5 虚拟机增加硬盘步骤 5​ 永久挂载: 通过修改/etc/fstab 实现挂载​ 添加完成后 执行 mount – a 即刻生效 6.5 磁盘情况查询6.5.1 查询系统整体磁盘使用情况 基本语法 df -h 应用实例 查询系统整体磁盘使用情况 6.5.2 查询指定目录的磁盘占用情况 基本语法 du -h / 目录 查询指定目录的磁盘占用情况， 默认为当前目录 指令 描述 -s 指定目录占用大小汇总 -h 带计量单位 -a 含文件 –max-depth=1 子目录深度 -c 列出明细的同时， 增加汇总值 6.6 磁盘情况-工作实用指令 统计/home 文件夹下文件的个数 统计/home 文件夹下目录的个数 统计/home 文件夹下文件的个数， 包括子文件夹里的 统计文件夹下目录的个数， 包括子文件夹里的 以树状显示目录结构 （CenOS 7） 第七章 网络配置7.1 Linux 网络配置原理图(含虚拟机)目前我们的网络配置采用的是 NAT。 7.2 查看网络 IP 和网关7.2.1 查看虚拟网络编辑器 7.2.2 修改 ip 地址(修改虚拟网络的 ip) 7.2.3 查看网关 7.2.4 查看 windows 环境的中 VMnet8 网络配置 (ipconfig 指令) 使用 ipconfig 查看 界面查看 7.3 ping 测试主机之间网络连通7.3.1 基本语法​ ping 目的主机 （功能描述： 测试当前服务器是否可以连接目的主机） 7.3.2 应用实例​ 测试当前服务器是否可以连接百度 ​ 7.4 linux 网络环境配置7.4.1 指定固定的 ip说明 ​ 直 接 修 改 配 置 文 件 来 指 定 IP, 并 可 以 连 接 到 外 网 ( 程 序 员 推 荐 ) ， 编 辑 1vi /etc/sysconfig/network-scripts/ifcfg-eth0 要求： 将 ip 地址配置的静态的， ip 地址为 192.168.184.130 (IP 地址参看自己的) 1ifconfig //在Linux终端即可查看 修改后， 一定要 ==重启服务== 1service network restart 1reboot 重启系统 第八章 进程管理8.1 显示系统执行的进程8.1.1 说明​ 查看进行使用的指令是 ps ,一般来说使用的参数是 ps -aux ​ 8.1.2 ps 指令详解 指令： ps – aux|grep xxx ， 比如我看看有没有 sshd 服务 指令说明 指令 描述 System V 展示风格 USER 用户名称 PID 进程号 %CPU 进程占用 CPU 的百分比 %MEM 进程占用物理内存的百分比 VSZ 进程占用的虚拟内存大小（单位： KB） RSS 进程占用的物理内存大小（单位： KB） TT 终端名称,缩写 STAT 进程状态， 其中 S-睡眠， s-表示该进程是会话的先导进程， N-表示进程拥有比普通优先级更低的优先级， R-正在运行， D-短期等待， Z-僵死进程， T-被跟踪或者被停止等等 STARTED 进程的启动时间 TIME CPU 时间， 即进程使用 CPU 的总时间 COMMAND 启动进程所用的命令和参数， 如果过长会被截断显示 8.1.3 应用实例 要求： 以全格式显示当前所有的进程， 查看进程的父进程。 12ps -ef 是以全格式显示当前所有的进程-e 显示所有进程。 -f 全格式 ps -ef| grep xxx 是 BSD 风格 方法 描述 UID 用户 ID PID 进程 ID PPID 父进程 ID C CPU 用于计算执行优先级的因子。 数值越大， 表明进程是 CPU 密集型运算， 执行优先级会降低； 数值越小， 表明进程是 I/O 密集型运算， 执行优先级会提高 STIME 进程启动的时间 TTY 完整的终端名称 TIME CPU 时间 CMD 启动进程所用的命令和参数 要求：查看 sshd 进程的父进程号是多少， 应该怎样查询 8.2 终止进程 kill 和 killall8.2.1 介绍:​ 若是某个进程执行一半需要停止时， 或是已消了很大的系统资源时， 此时可以考虑停止该进程。使用 kill 命令来完成此项任务。 8.2.1 基本语法​ kill [选项] 进程号（功能描述： 通过进程号杀死进程） ​ killall 进程名称 （功能描述： 通过进程名称杀死进程， 也支持通配符， 这在系统因负载过大而变得很慢时很有用） 8.2.2 常用选项​ -9 :表示强迫进程立即停止 8.2.3 最佳实践​ 案例 1： 踢掉某个非法登录用户 ​ 案例 2: 终止远程登录服务 sshd, 在适当时候再次重启 sshd 服务 ​ ​ 案例 3: 终止多个 gedit 编辑器 【killall , 通过进程名称来终止进程】 ​ 案例 4： 强制杀掉一个终端 8.3 查看进程树 pstree8.3.1 基本语法​ pstree [选项] ,可以更加直观的来看进程信息 8.3.2 常用选项​ -p :显示进程的 PID ​ -u :显示进程的所属用户 8.3.3 应用实例​ 案例 1： 请你树状的形式显示进程的 pid ​ ​ 案例 2： 请你树状的形式进程的用户 id ​ 8.4 服务(Service)管理8.4.1 介绍​ 服务(service) 本质就是进程， 但是是运行在后台的， 通常都会监听某个端口， 等待其它程序的请求， 比如(mysql , sshd 防火墙等)， 因此我们又称为守护进程， 是 Linux 中非常重要的知识点。 【原理图】 8.4.2 service 管理指令​ service 服务名 [start | stop | restart | reload | status] ​ 在 CentOS7.0 后 不再使用 service ,而是 systemctl 8.4.3 使用案例==CentOS 7== 示例： 1234567891011121314151617181920212223242526# 查看firewall服务状态systemctl status firewalld# 开启service firewalld start# 重启service firewalld restart# 关闭service firewalld stop# 查看防火墙规则firewall-cmd --list-all# 查询端口是否开放firewall-cmd --query-port=8080/tcp# 开放80端口firewall-cmd --permanent --add-port=80/tcp# 移除端口firewall-cmd --permanent --remove-port=8080/tcp#重启防火墙(修改配置后要重启防火墙)firewall-cmd --reload# 参数解释1、firwall-cmd：是Linux提供的操作firewall的一个工具；2、--permanent：表示设置为持久；3、--add-port：标识添加的端口； 查看当前防火墙的状况， 关闭防火墙和重启防火墙。 ==CenOS 6:== 8.4.4 细节讨论 关闭或者启用防火墙后， 立即生效。 [telnet 测试 某个端口即可] 这种方式只是临时生效， 当重启系统后， 还是回归以前对服务的设置。 8.4.5 查看服务名​ 方式 1： 使用 setup -&gt; 系统服务 就可以看到。 ​ 方式 2: /etc/init.d/服务名称 ​ 8.4.6 服务的运行级别(runlevel)​ 查看或者修改默认级别： vi /etc/inittab​ Linux 系统有 7 种运行级别(runlevel)： 常用的是级别 3 和 5 运行级别 0： 系统停机状态， 系统默认运行级别不能设为 0， 否则不能正常启动 运行级别 1： 单用户工作状态， root 权限， 用于系统维护， 禁止远程登陆 运行级别 2： 多用户状态(没有 NFS)， 不支持网络 运行级别 3： 完全的多用户状态(有 NFS)， 登陆后进入控制台命令行模式 运行级别 4： 系统未使用， 保留 运行级别 5： X11 控制台， 登陆后进入图形 GUI 模式 运行级别 6： 系统正常关闭并重启， 默认运行级别不能设为 6， 否则不能正常启动 8.4.7 开机的流程说明 8.4.8 chkconfig 指令 介绍 通过 chkconfig 命令可以给每个服务的各个运行级别设置自启动/关闭 基本语法 (==CenOS 6==) 查看服务 chkconfig –list|grep xxx chkconfig 服务名 –list chkconfig –level 5 服务名 on/off 请将 sshd 服务在运行级别为 5 的情况下， 不要自启动。 8.4.9 应用实例 (CenOS 6)​ 案例 1： 请显示当前系统所有服务的各个运行级别的运行状态 1chkconfig --list ​ 案例 2 ： 请查看 sshd 服务的运行状态 1service sshd status ​ 案例 3： 将 sshd 服务在运行级别 5 下设置为不自动启动， 看看有什么效果？ 1chkconfig --level 5 sshd off ​ 案例 4： 当运行级别为 5 时， 关闭防火墙。 1chkconfig --level 5 iptables off 案例 5： 在所有运行级别下， 关闭防火墙 1chkconfig iptables off ​ 案例 6： 在所有运行级别下， 开启防火墙 1chkconfig iptables on 8.4.10 使用细节chkconfig 重新设置服务后自启动或关闭， 需要重启机器 reboot 才能生效. 8.5 动态监控进程8.5.1 介绍​ top 与 ps 命令很相似。 它们都用来显示正在执行的进程。 Top 与 ps 最大的不同之处， 在于 top 在执行一段时间可以更新正在运行的的进程。 8.5.2 基本语法​ top [选项] 8.5.3 选项说明 8.5.4 应用实例​ 案例 1.监视特定用户 top： 输入此命令， 按回车键， 查看执行的进程。 u： 然后输入==“u” 回车， 再输入用户名， 即可== ​ 案例 2： 终止指定的进程 ​ top： 输入此命令， 按回车键， 查看执行的进程。​ k： 然后输入“k” 回车， 再输入要结束的进程 ID 号 案例 3:指定系统状态更新的时间(每隔 10 秒自动更新， 默认是 3 秒) 1top -d 10 8.5.5 查看系统网络情况 netstat(重要) 基本语法 netstat [选项]netstat -anp 选项说明 -an 按一定顺序排列输出-p 显示哪个进程在调用 应用案例 (==CenOS 6==) 查看系统所有的网络服务 请查看服务名为 sshd 的服务的信息。 第九章 RPM 和 YUM9.1 rpm 包的管理9.1.1 rpm 包的简单查询指令​ 查询已安装的 rpm 列表 rpm – qa|grep xx ​ 请查询看一下， 当前的 Linux 有没有安装 firefox . 9.1.2 rpm 包名基本格式​ 一个 rpm 包名： firefox-45.0.1-1.el6.centos.x86_64.rpm​ 名称:firefox​ 版本号： 45.0.1-1​ 适用操作系统: el6.centos.x86_64​ 表示 centos6.x 的 64 位系统​ 如果是 i686、 i386 表示 32 位系统， noarch 表示通用。 。 9.1.3 rpm 包的其它查询指令​ rpm -qa :查询所安装的所有 rpm 软件包 ​ rpm -qa | more [分页显示] ​ rpm -qa | grep X [rpm -qa | grep firefox ] ​ ​ rpm -q 软件包名 :查询软件包是否安装 ​ ​ rpm -qi 软件包名 ： 查询软件包信息 ​ ​ rpm -ql 软件包名 :查询软件包中的文件 ​ ​ rpm -qf 文件全路径名 查询文件所属的软件包 ​ rpm -qf /etc/passwd​ rpm -qf /root/install.log 9.1.4 卸载 rpm 包 基本语法 ​ rpm -e RPM 包的名称 应用案例 删除 firefox 软件包 细节问题 如果其它软件包依赖于您要卸载的软件包， 卸载时则会产生错误信息。 如： $ rpm -e foo removing these packages would break dependencies:foo is needed by bar-1.0-1 如果我们就是要删除 foo 这个 rpm 包， 可以增加参数 –nodeps ,就可以强制删除， 但是一般不推荐这样做， 因为依赖于该软件包的程序可能无法运行 如： $ rpm -e ==–nodeps== foo带上 ==–nodeps== 就是强制删除。 9.1.5 安装 rpm 包 基本语法 rpm -ivh RPM 包全路径名称 参数说明 i=install 安装v=verbose 提示h=hash 进度条 应用实例 演示安装 firefox 浏览器 步骤先找到 firefox 的安装 rpm 包,你需要挂载上我们安装 centos 的 iso 文件， 然后到/media/下去找 rpm 找。 cp firefox-45.0.1-1.el6.centos.x86_64.rpm /opt/ 9.2 yum9.2.1 介绍​ Yum 是一个 Shell 前端软件包管理器。 基于 RPM 包管理， 能够从指定的服务器自动下载 RPM 包并且安装， 可以自动处理依赖性关系， 并且一次安装所有依赖的软件包。 使用 yum 的前提是可以联网。 9.2.2 yum 的基本指令 查询 yum 服务器是否有需要安装的软件 yum list|grep xx 软件列表 软件列表 安装指定的 yum 包 yum install xxx 下载安装 9.2.3 yum 应用实例​ 案例： 请使用 yum 的方式来安装 firefox ​ 1.先查看一下 firefox rpm 在 yum 服务器有没有 1rpm -e firefox ​ 安装 1yum install firefox ​ 会安装最新版本的软件 ​ 【完成】 提取码：0xub 查看文档","categories":[{"name":"Linux语言","slug":"Linux语言","permalink":"http://blog.oy6090.top/categories/Linux%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"CentOS 7","slug":"CentOS-7","permalink":"http://blog.oy6090.top/tags/CentOS-7/"}]},{"title":"jQuery","slug":"jQuery","date":"2020-07-14T16:00:00.000Z","updated":"2020-12-28T00:31:08.806Z","comments":true,"path":"posts/1005838445.html","link":"","permalink":"http://blog.oy6090.top/posts/1005838445.html","excerpt":"","text":"一、jQuery 使用：1.本地引入1&lt;script src=&quot;js/jquery-1.10.1.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; 2.CDN 远程引入1&lt;script src=&quot;http://code.jquery.com/jquery-migrate-1.2.1.min.js&quot;&gt;&lt;/script&gt; 3.使用 jQuery方式一： 12345678910&lt;head&gt; &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt; &lt;title&gt;jQuery&lt;&#x2F;title&gt; &lt;script src&#x3D;&quot;..&#x2F;JS&#x2F;jquery-3.5.1.js&quot;&gt;&lt;&#x2F;script&gt; &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt; $(function () &#123; &#125;); &lt;&#x2F;script&gt;&lt;&#x2F;head&gt; 方式二： 123456&lt;body&gt; &lt;script src&#x3D;&quot;..&#x2F;JS&#x2F;jquery-3.5.1.js&quot;&gt;&lt;&#x2F;script&gt; &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt; &lt;&#x2F;script&gt;&lt;&#x2F;body&gt; 二、jQuery 对象和 dom 对象区分1.jQuery 对象与 dom 对象① DOM 对象： 通过 getElementById()查询出来的标签对象时 Dom 对象 通过 getElementName()查询出来的标签对象时 Dom 对象 通过 getElementByTagName()查询出来的标签对象是 Dom 对象 通过 createElemnet()方法创建的对象,是 Dom 对象 DOM 对象 Alert 出来的效果是:[object HTML 标签名 Element] ② jQuery 对象： 通过 jQuery 提供的 API 创建的对象，是 jQuery 对象 通过 jquery 包装的 Dom 对象,也是 jQuery 对象 通过 jquery 提供的 API 查询到的对象,是 jQuery 对象 2.jQuery 对象的本质 JQuery 对象时 dom 对象的数组 + JQuery 提供的一系列功能函数。 3.jQuery 对象和 Dom 对象使用的区别 JQuery 对象不能使用 DOM 对象的属性和方法 DOM 对象也不能使用 JQuery 对象的属性和方法 4.DOM 对象 和 jQuery 对象互转 dom 对象转为 JQuery 对象 先有 Dom 对象 $(DOM 对象) 就可以转换为 jQuery 对象 jQuery 对象转为 dom 对象 先有 jQuery 对象 jQuery 对象(下标)取出相对应的 DOM 对象 三、jQuery 的 2 把利器1.jQuery 函数; $/jQuery jQuery 向外暴露的就是 jQuery 函数，可以直接使用 当成一般函数使用：$(param) param 是 function: 相当于 windown.onload = function(文档加载完成的监听) param 是选择器字符串：查找所有的匹配 Dom 元素，返回包含所有的 DOM 元素的 jQuery 对象 param 是 DOM 元素：将 DOM 元素对象包装成 jQuery 对象返回$(this) param 是标签字符串： 创建标签 DOM 元素对象并包装为 jQuery 对象返回 当成对象使用：$.xxx each(obj/arr, function(key, value){}) trim(str) 2.jQuery 对象 包含所有匹配的 n 个 DOM 元素的伪数组对象 执行$()返回的就是 jQuery 对象 基本行为： length/size(): 得到 dom 元素的个数 [index] : 得到指定下标对应的 dom 元素 each(function(index, domEle){}): 遍历所有的 dom 元素 index(): 得到当前 dom 元素在所在兄弟中的下标 四、jQuery 选择器 有特定语法规则（CSS 选择器）的字符串 用来查找某个/些 DOM 元素：$(selector) 1.基本选择器 方法 描述 #id 根据给定的 ID 匹配一个元素。 tagName/* 根据匹配标签元素/所有元素。 .class 根据给定的类匹配元素。 selector1,selector2,selector3 将每一个选择器匹配到的元素合并后一起返回。 selector1selector2selector3 将每一个选择器匹配到的元素交集部分一起返回。 2.层次选择器 找子孙后代，兄弟元素 方法 描述 selector1&gt;selector2 子元素 selector1 selector2 后代元素 3.过滤选择器 方法 描述 :first 获取第一个元素 :last 获取最后个元素 :eq(index) 匹配一个给定索引值的元素 :lt 匹配所有小于给定索引值的元素 :gt 匹配所有大于给定索引值的元素 :odd 匹配所有索引值为奇数的元素，从 0 开始计数 :even 匹配所有索引值为偶数的元素，从 0 开始计数 :not(selector) 去除所有与给定选择器匹配的元素 :hidden 匹配所有不可见元素，或者 type 为 hidden 的元素 :visible 匹配所有的可见元素 [attrName] 匹配包含给定属性的元素。 [attrName=value] 匹配给定的属性是某个特定值的元素 代码示例 [attrName]： 1234&lt;div&gt; &lt;p&gt;Hello!&lt;/p&gt;&lt;/div&gt;&lt;div id=&quot;test2&quot;&gt;&lt;/div&gt; jQuery 代码： 1$(&quot;div[id]&quot;) 运行结果： 1&lt;div id&#x3D;&quot;test2&quot;&gt;&lt;&#x2F;div&gt; 代码示例 [attrName=value]： 123&lt;input type=&quot;checkbox&quot; name=&quot;newsletter&quot; value=&quot;Hot Fuzz&quot; /&gt;&lt;input type=&quot;checkbox&quot; name=&quot;newsletter&quot; value=&quot;Cold Fusion&quot; /&gt;&lt;input type=&quot;checkbox&quot; name=&quot;accept&quot; value=&quot;Evil Plans&quot; /&gt; jQuery 代码： 1$(&quot;input[name&#x3D;&#39;newsletter&#39;]&quot;).attr(&quot;checked&quot;, true); 运行结果： 12&lt;input type&#x3D;&quot;checkbox&quot; name&#x3D;&quot;newsletter&quot; value&#x3D;&quot;Hot Fuzz&quot; checked&#x3D;&quot;true&quot; &#x2F;&gt;&lt;input type&#x3D;&quot;checkbox&quot; name&#x3D;&quot;newsletter&quot; value&#x3D;&quot;Cold Fusion&quot; checked&#x3D;&quot;true&quot; &#x2F;&gt; 4.表单选择器 方法 描述 :input 匹配所有 input, textarea, select 和 button 元素 :text 匹配所有的单行文本框 :checkbox 匹配所有复选框 :radio 匹配所有单选按钮 :checked 匹配所有选中的被选中元素(复选框、单选框等，不包括 select 中的 option) 代码示例 【:input】： 123456789101112131415161718192021&lt;form&gt; &lt;input type=&quot;button&quot; value=&quot;Input Button&quot; /&gt; &lt;input type=&quot;checkbox&quot; /&gt; &lt;input type=&quot;file&quot; /&gt; &lt;input type=&quot;hidden&quot; /&gt; &lt;input type=&quot;image&quot; /&gt; &lt;input type=&quot;password&quot; /&gt; &lt;input type=&quot;radio&quot; /&gt; &lt;input type=&quot;reset&quot; /&gt; &lt;input type=&quot;submit&quot; /&gt; &lt;input type=&quot;text&quot; /&gt; &lt;select&gt; &lt;option&gt;Option&lt;/option&gt; &lt;/select&gt; &lt;textarea&gt;&lt;/textarea&gt; &lt;button&gt;Button&lt;/button&gt;&lt;/form&gt; jQuery 代码： 1$(&quot;:input&quot;) 运行结果： 123456789101112131415161718&lt;input type=&quot;button&quot; value=&quot;Input Button&quot; /&gt;&lt;input type=&quot;checkbox&quot; /&gt;&lt;input type=&quot;file&quot; /&gt;&lt;input type=&quot;hidden&quot; /&gt;&lt;input type=&quot;image&quot; /&gt;&lt;input type=&quot;password&quot; /&gt;&lt;input type=&quot;radio&quot; /&gt;&lt;input type=&quot;reset&quot; /&gt;&lt;input type=&quot;submit&quot; /&gt;&lt;input type=&quot;text&quot; /&gt;&lt;select&gt; &lt;option&gt;Option&lt;/option&gt;&lt;/select&gt;&lt;textarea&gt;&lt;/textarea&gt;&lt;button&gt;Button&lt;/button&gt; 代码示例 【:checked】： 12345&lt;form&gt; &lt;input type=&quot;checkbox&quot; name=&quot;newsletter&quot; checked=&quot;checked&quot; value=&quot;Daily&quot; /&gt; &lt;input type=&quot;checkbox&quot; name=&quot;newsletter&quot; value=&quot;Weekly&quot; /&gt; &lt;input type=&quot;checkbox&quot; name=&quot;newsletter&quot; checked=&quot;checked&quot; value=&quot;Monthly&quot; /&gt;&lt;/form&gt; jQuery 代码： 1$(&quot;input:checked&quot;) 运行结果： 12&lt;input type=&quot;checkbox&quot; name=&quot;newsletter&quot; checked=&quot;checked&quot; value=&quot;Daily&quot; /&gt;&lt;input type=&quot;checkbox&quot; name=&quot;newsletter&quot; checked=&quot;checked&quot; value=&quot;Monthly&quot; /&gt; 五、属性/文本 操作标签的属性, 标签体文本 方法 描述 attr(name) / attr(name, value) 读写非布尔值的标签属性 prop(name) / prop(name, value) 读写布尔值的标签属性 removeAttr(name)/removeProp(name) 删除属性 addClass(classValue) 添加 class removeClass(classValue) 移除指定 class val() / val(value) 读写标签的 value html() / html(htmlString) 读写标签体文本 六、CSS 模块1. style 样式 方法 描述 css(styleName) 根据样式名得到对应的值 css(styleName, value) 设置一个样式 css(多个样式对) 设置多个样式 代码示例： 取得第一个段落的 color 样式属性的值。 1$(&quot;p&quot;).css(&quot;color&quot;); 将所有段落的字体颜色设为红色并且背景为蓝色。 1$(&quot;p&quot;).css(&#123; color: &quot;#ff0011&quot;, background: &quot;blue&quot; &#125;); 3. 将所有段落字体设为红色 1$(&quot;p&quot;).css(&quot;color&quot;,&quot;red&quot;); 2.位置坐标 方法 描述 offset() 读/写当前坐标（原点是页面左上角） position() 读写当前元素的坐标的（原点是父元素左上角） scrollTop()/scrollLeft() 读/写元素/页面的滚动坐标 代码示例： offset() 12&lt;p&gt;Hello&lt;/p&gt;&lt;p&gt;2nd Paragraph&lt;/p&gt; 12// jQuery代码 var p = $(&quot;p:last&quot;); var offset = p.offset(); p.html( &quot;left: &quot; +offset.left + &quot;, top: &quot; + offset.top ); 运行结果 12&lt;p&gt;Hello&lt;/p&gt;&lt;p&gt;left: 0, top: 35&lt;/p&gt; position() 12&lt;p&gt;Hello&lt;/p&gt;&lt;p&gt;2nd Paragraph&lt;/p&gt; 12// jQuery代码 var p = $(&quot;p:first&quot;); var position = p.position();$(&quot;p:last&quot;).html( &quot;left: &quot; + position.left + &quot;, top: &quot; + position.top ); 运行结果： 12&lt;p&gt;Hello&lt;/p&gt;&lt;p&gt;left: 15, top: 15&lt;/p&gt; scrollTop() 12&lt;p&gt;Hello&lt;/p&gt;&lt;p&gt;2nd Paragraph&lt;/p&gt; 12// jQuery代码 var p = $(&quot;p:first&quot;); $(&quot;p:last&quot;).text( &quot;scrollTop:&quot; +p.scrollTop() ); 运行结果： 12&lt;p&gt;Hello&lt;/p&gt;&lt;p&gt;scrollTop: 0&lt;/p&gt; scrollLeft() 12&lt;p&gt;Hello&lt;/p&gt;&lt;p&gt;2nd Paragraph&lt;/p&gt; 123&#x2F;&#x2F; jQuery代码var p &#x3D; $(&quot;p:first&quot;);$(&quot;p:last&quot;).text( &quot;scrollLeft:&quot; + p.scrollLeft() ); 运行结果： 12&lt;p&gt;Hello&lt;&#x2F;p&gt;&lt;p&gt;scrollLeft: 0&lt;&#x2F;p&gt; 3.尺寸 方法 描述 width()/height() width/height innerWidth()/innerHeight() width + padding outerWidth()/outerHeight() width + padding + border outerWidth(true)/outerHeight(true) width + padding + border+margin 代码示例： width() 获取第一段的高 1$(&quot;p&quot;).height(); innerWidth() 获取第一段落内部区域高度。 12&lt;p&gt;Hello&lt;/p&gt;&lt;p&gt;2nd Paragraph&lt;/p&gt; 123// jQueryvar p = $(&quot;p:first&quot;);$(&quot;p:last&quot;).text(&quot;innerHeight:&quot; + p.innerHeight()); 结果示例： 12&lt;p&gt;Hello&lt;/p&gt;&lt;p&gt;innerHeight: 16&lt;/p&gt; outerWidth() 12&lt;p&gt;Hello&lt;/p&gt;&lt;p&gt;2nd Paragraph&lt;/p&gt; 12345678// jQueryvar p = $(&quot;p:first&quot;);$(&quot;p:last&quot;).text( &quot;outerHeight:&quot; + p.outerHeight() + &quot; , outerHeight(true):&quot; + p.outerHeight(true)); 运行结果： 12&lt;p&gt;Hello&lt;/p&gt;&lt;p&gt;outerHeight: 35 , outerHeight(true):55&lt;/p&gt; 七、筛选模块1.过滤 在 jQuery 对象内部的元素中找出部分匹配的元素, 并封装成新的 jQuery 对象返回 方法 描述 first() 获取第一个元素 last() 获取最后个元素 eq(index) 获取第 N 个元素 filter(selector) 筛选出与指定表达式匹配的元素集合。 not(selector) 删除与指定表达式匹配的元素 has(selector) 保留包含特定后代的元素，去掉那些不含有指定后代的元素。 代码示例： filter(selector) 123&lt;p&gt;Hello&lt;/p&gt;&lt;p&gt;Hello Again&lt;/p&gt;&lt;p class=&quot;selected&quot;&gt;And Again&lt;/p&gt; 12// jQuery$(&quot;p&quot;).filter(&quot;.selected&quot;); 12// 运行结果&lt;p class=&quot;selected&quot;&gt;And Again&lt;/p&gt; not(selector) 12&lt;p&gt;Hello&lt;/p&gt;&lt;p id=&quot;selected&quot;&gt;Hello Again&lt;/p&gt; 12// jQuery$(&quot;p&quot;).not($(&quot;#selected&quot;)[0]); 12// 运行结果&lt;p&gt;Hello&lt;/p&gt; 3. **has(selector)** 123456789101112&lt;ul&gt; &lt;li&gt;list item 1&lt;/li&gt; &lt;li&gt; list item 2 &lt;ul&gt; &lt;li&gt;list item 2-a&lt;/li&gt; &lt;li&gt;list item 2-b&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt;list item 3&lt;/li&gt; &lt;li&gt;list item 4&lt;/li&gt;&lt;/ul&gt; 12// jQuery$(&quot;li&quot;).has(&quot;ul&quot;).css(&quot;background-color&quot;, &quot;red&quot;); 2.查找 查找 jQuery 对象内部的元素的子孙/兄弟/父母元素, 并封装成新的 jQuery 对象返回 方法 描述 children(selector) 取得一个包含匹配的元素集合中每一个元素的所有子元素的元素集合。（子元素） find(selector) 搜索所有与指定表达式匹配的元素。这个函数是找出正在处理的元素的后代元素的方法。（后代元素） preAll(selector) 查找当前元素之前所有的同辈元素（前的所有兄弟） siblings(selector) 取得一个包含匹配的元素集合中每一个元素的所有唯一同辈元素的元素集合。（所有兄弟） parent() 取得一个包含着所有匹配元素的唯一父元素的元素集合。（父元素） 代码示例： preAll(selector) 1234&lt;div&gt;&lt;&#x2F;div&gt;&lt;div&gt;&lt;&#x2F;div&gt;&lt;div&gt;&lt;&#x2F;div&gt;&lt;div&gt;&lt;&#x2F;div&gt; 12// jQuery$(&quot;div:last&quot;).prevAll().addClass(&quot;before&quot;); 1234// 运行结果&lt;div class=&quot;before&quot;&gt;&lt;/div&gt;&lt;div class=&quot;before&quot;&gt;&lt;/div&gt;&lt;div class=&quot;before&quot;&gt;&lt;/div&gt; 八、文档处理(CUD)模块1.增加 方法 描述 append() / appendTo() 插入后部 preppend() / preppendTo() 插入前部 before() 插到前面 after() 插到后面 2.删除 方法 描述 remove() 从 DOM 中删除所有匹配的元素。(将自己及内部的孩子都删除) empty() 删除匹配的元素集合中所有的子节点。(掏空(自己还在)) 代码示例： remove() 123&lt;p&gt;Hello&lt;/p&gt;how are&lt;p&gt;you?&lt;/p&gt; 12// jQuery$(&quot;p&quot;).remove(); 1// 运行结果 how are 3.更新 方法 描述 replaceWith() 将所有匹配的元素替换成指定的 HTML 或 DOM 元素。 代码示例： 123&lt;p&gt;Hello&lt;/p&gt;&lt;p&gt;cruel&lt;/p&gt;&lt;p&gt;World&lt;/p&gt; 12// jQuery$(&quot;p&quot;).replaceWith(&quot;&lt;b&gt;Paragraph. &lt;/b&gt;&quot;); 1234// 运行结果&lt;b&gt;Paragraph. &lt;/b&gt;&lt;b&gt;Paragraph. &lt;/b&gt;&lt;b&gt;Paragraph. &lt;/b&gt; 九、事件模块1.绑定事件 eventName(function(){}) on(‘eventName’, function(){}) 常用: click,mouseenter /mouseleave , mouseover /mouseout,focus/blur hover(function(){}, function(){}) 2.解绑事件 off(‘eventName’) 3.事件委托理解: 将子元素的事件委托给父辈元素处理 事件监听绑定在父元素上, 但事件发生在子元素上 事件会冒泡到父元素 但最终调用的事件回调函数的是子元素: event.target 好处: 新增的元素没有事件监听 减少监听的数量(n==&gt;1) jQuery 的事件委托 API 设置事件委托: $(parentSelector).delegate(childrenSelector, eventName, callback) 移除事件委托: $(parentSelector).undelegate(eventName) 代码示例： 1234567891011&lt;ul&gt; &lt;li&gt;11111&lt;/li&gt; &lt;li&gt;1111111&lt;/li&gt; &lt;li&gt;111111111&lt;/li&gt; &lt;li&gt;11111111111&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;22222&lt;/li&gt;&lt;br /&gt;&lt;button id=&quot;btn&quot;&gt;添加新的li&lt;/button&gt;&lt;br /&gt; 1234567// jQuery$(&quot;ul&gt;li&quot;).click(function () &#123; this.style.background = &quot;red&quot;;&#125;);$(&quot;#btn&quot;).click(function () &#123; $(&quot;ul&quot;).append(&quot;&lt;li&gt;新增的li....&lt;/li&gt;&quot;);&#125;); 12345678// 运行结果&lt;ul&gt; &lt;li&gt;11111&lt;/li&gt; &lt;li&gt;1111111&lt;/li&gt; &lt;li&gt;111111111&lt;/li&gt; &lt;li&gt;11111111111&lt;/li&gt; &lt;li&gt;新增的li....&lt;/li&gt;&lt;/ul&gt; 4.事件坐标 方法 描述 event.offsetX 原点是当前元素左上角 event.clientX 原点是窗口左上角 event.pageX 原点是页面左上角 代码示例： 12345678&lt;div class=&quot;out&quot;&gt; 外部DIV &lt;div class=&quot;inner&quot;&gt;内部div&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;divBtn&quot;&gt; &lt;button id=&quot;btn1&quot;&gt;测试事件坐标&lt;/button&gt;&lt;/div&gt; 123456$(&quot;#btn1&quot;).click(function (event) &#123; // event 事件 console.log(event.offsetX, event.offsetY); // 原点为事件元素的左上角 console.log(event.clientX, event.clientY); // 原点为窗口的左上角 console.log(event.pageX, event.pageY); // 原点为页面的左上角&#125;); 5.事件相关 停止事件冒泡: event.stopPropagation() 阻止事件的默认行为: event.preventDefault() 代码示例： 1234567891011&lt;ul&gt; &lt;li&gt;1111&lt;/li&gt; &lt;li&gt;2222&lt;/li&gt; &lt;li&gt;3333&lt;/li&gt; &lt;li&gt;4444&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;22222&lt;/li&gt;&lt;br /&gt;&lt;button id=&quot;btn1&quot;&gt;添加新的li&lt;/button&gt;&lt;button id=&quot;btn2&quot;&gt;删除ul上的事件委托的监听器&lt;/button&gt; 123456789101112// jQuery// 设置事件委托$(&quot;ul&quot;).delegate(&quot;li&quot;, &quot;click&quot;, function () &#123; this.style.background = &quot;red&quot;;&#125;);$(&quot;#btn1&quot;).click(function () &#123; $(&quot;ul&quot;).append(&quot;&lt;li&gt;新增的li....&lt;/li&gt;&quot;);&#125;);// 移除事件委托$(&quot;#btn2&quot;).click(function () &#123; $(&quot;ul&quot;).undelegate(&quot;click&quot;);&#125;); 十、JQuery 动画1.基本动画 方法 描述 show() 将隐藏的元素显示 hide() 将可见的元素隐藏 toggle() 可见就隐藏，不可见就显示 以上的动画都可以添加参数： ① 第一个参数就是显示 执行的时间，以毫秒为单位 ② 第二个参数就是动画的回调函数（动画完成以后调用的函数） 代码示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;style type=&quot;text/css&quot;&gt; * &#123; margin: 0px; &#125; .div1 &#123; position: absolute; width: 200px; height: 200px; top: 50px; left: 10px; background: red; display: none; &#125;&lt;/style&gt;&lt;body&gt; &lt;button id=&quot;btn1&quot;&gt;瞬间显示&lt;/button&gt; &lt;button id=&quot;btn2&quot;&gt;慢慢显示&lt;/button&gt; &lt;button id=&quot;btn3&quot;&gt;慢慢隐藏&lt;/button&gt; &lt;button id=&quot;btn4&quot;&gt;显示隐藏切换&lt;/button&gt; &lt;div class=&quot;div1&quot;&gt;&lt;/div&gt; &lt;script src=&quot;../JS/jquery-3.5.1.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; var $div1 = $(&quot;.div1&quot;); // 1. 点击btn1, 立即显示 $(&quot;#btn1&quot;).click(function () &#123; $div1.show(); &#125;); // 2. 点击btn2，慢慢显示 $(&quot;#btn2&quot;).click(function () &#123; $div1.show(1000); &#125;); // 3. 点击btn3, 慢慢隐藏 $(&quot;#btn3&quot;).click(function () &#123; $div1.hide(1000); &#125;); // 4.点击btn4, 切换显示/隐藏 $(&quot;#btn4&quot;).click(function () &#123; $div1.toggle(1000); &#125;); &lt;/script&gt;&lt;/body&gt; 2.淡入淡出动画 动画 描述 fadeln() 淡入 fadeOut() 淡出 fade To() 在指导时长内慢慢将透明度修改指定的值。0 透明 1 完成可见 0.5 透明 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;style type=&quot;text/css&quot;&gt; * &#123; margin: 0px; &#125; .div1 &#123; position: absolute; width: 200px; height: 200px; top: 50px; left: 10px; background: red; &#125;&lt;/style&gt;&lt;body&gt; &lt;button id=&quot;btn1&quot;&gt;慢慢淡出&lt;/button&gt; &lt;button id=&quot;btn2&quot;&gt;慢慢淡入&lt;/button&gt; &lt;button id=&quot;btn3&quot;&gt;淡出/淡入切换&lt;/button&gt; &lt;div class=&quot;div1&quot;&gt;&lt;/div&gt; &lt;script src=&quot;../JS/jquery-3.5.1.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; /* 需求： 1. 点击btn1, 慢慢淡出 * 无参 * 有参 * 字符串参数 * 数字参数 2. 点击btn3, 慢慢淡入 3. 点击btn3, 淡出/淡入切换，动画结束时提示“动画结束了” */ var $div1 = $(&quot;.div1&quot;); $(&quot;#btn1&quot;).click(function () &#123; $div1.fadeOut(1000, function () &#123; alert(&quot;动画完成了！！！！&quot;); &#125;); &#125;); $(&quot;#btn2&quot;).click(function () &#123; $div1.fadeIn(); &#125;); $(&quot;btn3&quot;).click(function () &#123; $div1.fadeToggle(); &#125;); &lt;/script&gt;&lt;/body&gt;","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://blog.oy6090.top/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"http://blog.oy6090.top/tags/jQuery/"}]},{"title":"JavsScript高级（一）","slug":"01_基础总结深入","date":"2020-07-11T16:00:00.000Z","updated":"2021-01-22T03:46:49.086Z","comments":true,"path":"posts/38492.html","link":"","permalink":"http://blog.oy6090.top/posts/38492.html","excerpt":"","text":"请结合 javacript 基础结合参考 数据类型的分类和判断 基本(值)类型 Number —– 任意数值 ——– typeof String —– 任意字符串 —— typeof Boolean —- true/false —– typeof undefined — undefined —– typeof/=== null ——– null ———- === 对象(引用)类型 Object —– typeof/instanceof Array —— instanceof Function —- typeof 数据,变量, 内存的理解 什么是数据? 在内存中可读的, 可传递的保存了特定信息的’东东’ 一切皆数据, 函数也是数据 在内存中的所有操作的目标: 数据 什么是变量? 在程序运行过程中它的值是允许改变的量 一个变量对应一块小内存, 它的值保存在此内存中 什么是内存? 内存条通电后产生的存储空间(临时的) 一块内存包含 2 个方面的数据 内部存储的数据 地址值数据 内存空间的分类 栈空间: 全局变量和局部变量 堆空间: 对象 内存,数据, 变量三者之间的关系 内存是容器, 用来存储不同数据 变量是内存的标识, 通过变量我们可以操作(读/写)内存中的数据 对象的理解和使用 什么是对象? 多个数据(属性)的集合 用来保存多个数据(属性)的容器 属性组成: 属性名 : 字符串(标识) 属性值 : 任意类型 属性的分类: 一般 : 属性值不是 function 描述对象的状态 方法 : 属性值为 function 的属性 描述对象的行为 特别的对象 数组: 属性名是 0,1,2,3 之类的索引 函数: 可以执行的 如何操作内部属性(方法) .属性名 [‘属性名’]: 属性名有特殊字符/属性名是一个变量 函数的理解和使用 什么是函数? 用来实现特定功能的, n 条语句的封装体 只有函数类型的数据是可以执行的, 其它的都不可以 为什么要用函数? 提高复用性 便于阅读交流 函数也是对象 instanceof Object===true 函数有属性: prototype 函数有方法: call()/apply() 可以添加新的属性/方法 函数的 3 种不同角色 一般函数 : 直接调用 构造函数 : 通过 new 调用 对象 : 通过.调用内部的属性/方法 函数中的 this 显式指定谁: obj.xxx() 通过 call/apply 指定谁调用: xxx.call(obj) 不指定谁调用: xxx() : window 回调函数: 看背后是通过谁来调用的: window/其它 匿名函数自调用:123(function(w, obj)&#123; &#x2F;&#x2F;实现代码&#125;)(window, obj) 专业术语为: IIFE (Immediately Invoked Function Expression) 立即调用函数表达式 回调函数的理解 什么函数才是回调函数? 你定义的 你没有调用 但它最终执行了(在一定条件下或某个时刻) 常用的回调函数 dom 事件回调函数 定时器回调函数 ajax 请求回调函数(后面讲解) 生命周期回调函数(后面讲解)","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://blog.oy6090.top/categories/JavaScript/"}],"tags":[{"name":"JavaScript高级","slug":"JavaScript高级","permalink":"http://blog.oy6090.top/tags/JavaScript%E9%AB%98%E7%BA%A7/"}]},{"title":"JDBC模板","slug":"JDBC模板","date":"2020-07-11T16:00:00.000Z","updated":"2020-10-25T02:17:35.689Z","comments":true,"path":"posts/2968822672.html","link":"","permalink":"http://blog.oy6090.top/posts/2968822672.html","excerpt":"","text":"最近刚学完 JDBC，通博客来总结一下。这里采用的是 Druid 连接池，以及调用了第三方的 jar 包。 调用的 jar 包： JDBC 项目结构 整体结构 代码如下 配置数据库加载文件（放在 src 目录下） 【Druid.properties】 123456789101112driver=com.mysql.jdbc.Driverurl=jdbc:mysql://localhost:3306/userinfo?useUnicode=true&amp;characterEncoding=utf8username=rootpassword=(填写自己的数据库密码)#初始化连接initialSize=10#最大连接数量maxActive=30#最小空闲连接minIdle=5#超时等待时间以毫秒为单位maxWait=5000 【JDBCutil.java】配置数据库连接池 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.OY.online.jdbc2.utilTest;import com.alibaba.druid.pool.DruidDataSourceFactory;import org.apache.commons.dbutils.DbUtils;import javax.sql.DataSource;import java.io.InputStream;import java.sql.Connection;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Statement;import java.util.Properties;/** * 连接Druid数据连接池*@Author OY*@Date 2020/5/19*@Time 11:03*@Since version-1.8*/public class JDBCutil &#123; private static DataSource source; static&#123; try &#123; Properties prop = new Properties(); InputStream is = ClassLoader.getSystemClassLoader().getResourceAsStream(&quot;Druid.properties&quot;); prop.load(is); source = DruidDataSourceFactory.createDataSource(prop); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public static Connection getConection() throws SQLException &#123; Connection conn = source.getConnection(); return conn; &#125; //关闭数据库连接 public static void closeConection(Connection conn, Statement ps, ResultSet rs)&#123; DbUtils.closeQuietly(conn); DbUtils.closeQuietly(ps); DbUtils.closeQuietly(rs); &#125;&#125; 在 Bean 目录下创建【Customers.java】 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package com.OY.online.jdbc.bean;import java.sql.Date;/***@Author OY*@Date 2020/5/19*@Time 10:11*@Since version-1.8*/public class Customer &#123; private int id; private String name; private String email; private Date birth; public Customer() &#123; &#125; public Customer(int id, String name, String email, Date birth) &#123; this.id = id; this.name = name; this.email = email; this.birth = birth; &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getEmail() &#123; return email; &#125; public void setEmail(String email) &#123; this.email = email; &#125; public Date getBirth() &#123; return birth; &#125; public void setBirth(Date birth) &#123; this.birth = birth; &#125; @Override public String toString() &#123; return &quot;Customer&#123;&quot; + &quot;id=&quot; + id + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, email=&#x27;&quot; + email + &#x27;\\&#x27;&#x27; + &quot;, birth=&quot; + birth + &#x27;&#125;&#x27;; &#125;&#125; 【BaseDAO.java】 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677package com.OY.online.jdbc.DAO;import org.apache.commons.dbutils.QueryRunner;import org.apache.commons.dbutils.handlers.BeanHandler;import org.apache.commons.dbutils.handlers.BeanListHandler;import org.apache.commons.dbutils.handlers.ScalarHandler;import java.lang.reflect.ParameterizedType;import java.lang.reflect.Type;import java.sql.Connection;import java.sql.SQLException;import java.util.List;/***@Author OY*@Date 2020/5/19*@Time 10:14*@Since version-1.8*/public abstract class BaseDAO&lt;T&gt; &#123; private QueryRunner runner = new QueryRunner(); private Class&lt;T&gt; clazz = null; &#123; Type genericSuperclass = this.getClass().getGenericSuperclass(); ParameterizedType param = (ParameterizedType) genericSuperclass; Type[] typeArguments = param.getActualTypeArguments(); clazz =(Class&lt;T&gt;) typeArguments[0]; &#125; /** *通用的增删改 */ public int Update(Connection conn, String sql , Object...args)&#123; int update = 0; try &#123; update = runner.update(conn, sql, args); &#125; catch (SQLException throwables) &#123; throwables.printStackTrace(); &#125; return update; &#125; /** * 获取一条数据 */ public T getConnection(Connection conn, String sql , Object...args)&#123; T query = null; try &#123; query = runner.query(conn, sql, new BeanHandler&lt;T&gt;(clazz),args); &#125; catch (SQLException throwables) &#123; throwables.printStackTrace(); &#125; return query; &#125; /** * 获取多条数据 */ public List&lt;T&gt; getConnectionList(Connection conn, String sql , Object...args)&#123; List&lt;T&gt; list = null; try &#123; list = runner.query(conn, sql, new BeanListHandler&lt;T&gt;(clazz), args); &#125; catch (SQLException throwables) &#123; throwables.printStackTrace(); &#125; return list; &#125; /** * 获取数据库特殊值：例如count(*)、Max() */ public Object getValue(Connection conn, String sql, Object...args)&#123; Object value = null; try &#123; value = runner.query(conn, sql, new ScalarHandler(), args); &#125; catch (SQLException throwables) &#123; throwables.printStackTrace(); &#125; return value; &#125;&#125; *【CustomerDAO.java】 12345678910111213141516171819202122232425262728293031323334353637383940package com.OY.online.jdbc.DAO;import com.OY.online.jdbc.bean.Customer;import java.sql.Connection;import java.util.List;/***@Author OY*@Date 2020/5/19*@Time 10:31*@Since version-1.8*/public interface CustomerDAO &#123; /** * 将cust对象添加到数据库中 */ void insert(Connection conn, Customer cust); /** * 针对指定的id，删除表中的一条记录 */ void deleteByID(Connection conn, int id); /** * 针对内存中的cust对象，去修改数据表中指定的记录 */ void update(Connection conn, Customer cust); /** * 针对指定的id查询得到对应的Customer对象 */ Customer getConnectionById(Connection conn, int id); /** * 查询表中的所有记录构成的集合 */ List&lt;Customer&gt; getAll(Connection conn); /** * 返回数据表中的数据的条目数 */ Long getCount(Connection conn);&#125; 【CustomerDAOImpI.java】 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.OY.online.jdbc.DAO;import com.OY.online.jdbc.bean.Customer;import java.sql.Connection;import java.util.List;public class CustomerDAOImpI extends BaseDAO&lt;Customer&gt; implements CustomerDAO &#123; @Override public void insert(Connection conn, Customer cust) &#123; String sql = &quot;insert into customers(name, email,birth)values(?,?,?)&quot;; Update(conn,sql,cust.getName(),cust.getEmail(),cust.getBirth()); &#125; @Override public void deleteByID(Connection conn, int id) &#123; String sql = &quot;delete from customers where id =?&quot;; Update(conn, sql ,id); &#125; @Override public void update(Connection conn, Customer cust) &#123; String sql = &quot;update customers set name =?, email = ?, birth =? where id =?&quot;; Update(conn,sql,cust.getName(),cust.getEmail(),cust.getBirth(),cust.getId()); &#125; @Override public Customer getConnectionById(Connection conn, int id) &#123; String sql = &quot;select id, name, email, birth from customers where id = ?&quot;;// String sql = &quot;select id,name,email,birth from customers where id = ?&quot;; Customer cust = getConnection(conn, sql, id); return cust; &#125; @Override public List&lt;Customer&gt; getAll(Connection conn) &#123; String sql =&quot;select id, name, email, birth from customers &quot;; List&lt;Customer&gt; list = getConnectionList(conn, sql); return list; &#125; @Override public Long getCount(Connection conn) &#123; String sql = &quot;select count(*) from customers&quot;; Object value = getValue(conn, sql); return (Long) value; &#125;&#125; 测试【CustomerDAOImpITest.java】 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104package com.OY.online.jdbc.util;import com.OY.online.jdbc.DAO.CustomerDAOImpI;import com.OY.online.jdbc.bean.Customer;import com.OY.online.jdbc2.utilTest.JDBCutil;import org.junit.Test;import java.sql.Connection;import java.sql.Date;import java.sql.SQLException;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.List;import static org.junit.Assert.*;public class CustomerDAOImpITest &#123; private CustomerDAOImpI custs = new CustomerDAOImpI(); @Test public void insert() &#123; Connection conn = null; try &#123; conn = JDBCutil.getConection(); SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); java.util.Date date = sdf.parse(&quot;2001-7-8&quot;); Customer cust = new Customer(1, &quot;莫林&quot;, &quot;molin@126.com&quot;, new Date(date.getTime())); custs.insert(conn, cust); System.out.println(&quot;添加成功&quot;); &#125; catch (Exception throwables) &#123; throwables.printStackTrace(); &#125; finally &#123; JDBCutil.closeConection(conn,null,null); &#125; &#125; @Test public void deleteByID() &#123; Connection conn = null; try &#123; conn = JDBCutil.getConection(); custs.deleteByID(conn,26); System.out.println(&quot;删除成功&quot;); &#125; catch (SQLException throwables) &#123; throwables.printStackTrace(); &#125; finally &#123; JDBCutil.closeConection(conn, null,null); &#125; &#125; @Test public void update() &#123; Connection conn = null; try &#123; conn = JDBCutil.getConection(); &#125; catch (SQLException throwables) &#123; throwables.printStackTrace(); &#125; finally &#123; JDBCutil.closeConection(conn, null,null); &#125; &#125; @Test public void getConnectionById() &#123; Connection conn = null; try &#123; conn = JDBCutil.getConection(); Customer cust = custs.getConnectionById(conn, 27); System.out.println(cust); &#125; catch (SQLException throwables) &#123; throwables.printStackTrace(); &#125; finally &#123; JDBCutil.closeConection(conn, null,null); &#125; &#125; @Test public void getAll() &#123; Connection conn = null; try &#123; conn = JDBCutil.getConection(); List&lt;Customer&gt; list = custs.getAll(conn); list.forEach(System.out::println); &#125; catch (SQLException throwables) &#123; throwables.printStackTrace(); &#125; finally &#123; JDBCutil.closeConection(conn, null,null); &#125; &#125; @Test public void getCount() &#123; Connection conn = null; try &#123; conn = JDBCutil.getConection(); Long count = custs.getCount(conn); System.out.println(&quot;数据库条目数为&quot;+count); &#125; catch (SQLException throwables) &#123; throwables.printStackTrace(); &#125; finally &#123; JDBCutil.closeConection(conn, null,null); &#125; &#125;&#125;","categories":[{"name":"JDBC","slug":"JDBC","permalink":"http://blog.oy6090.top/categories/JDBC/"}],"tags":[{"name":"JDBC数据连接池","slug":"JDBC数据连接池","permalink":"http://blog.oy6090.top/tags/JDBC%E6%95%B0%E6%8D%AE%E8%BF%9E%E6%8E%A5%E6%B1%A0/"}]},{"title":"Java多线程基础（一）","slug":"Java多线程基础（一）","date":"2020-07-11T16:00:00.000Z","updated":"2021-01-22T03:50:25.089Z","comments":true,"path":"posts/69.html","link":"","permalink":"http://blog.oy6090.top/posts/69.html","excerpt":"","text":"这是结合自己所学总结，自己也正在学习道路上，本篇结合 Guide 哥的博客结合，自己所学的还处于基础的阶段，没了解这么深，通过它人的来补足自己的知识点的缺漏，如果你要了解更深，文章下有转载地址。通过博客来记录自己的一滴滴成长，也许过程很艰辛，但我选择坚持，不给以后的自己留下遗憾。 一 进程和多线程简介1.1 进程和线程进程概念：程序的一次执行的过程，或是正在运行的一个程序说明：进程作为资源分配单位，系统再运行时会为每个进程分配不同的内存区域线程概念;进程可进一步把细化为线程，是一个程序内部的一条执行路径。说明：线程作为调度和执行的单位，每个线程拥有独立的运行栈和程序计数器（PC），线程切换的开销小 1.2 何为进程？进程是程序的一次执行过程，是系统运行的基本单位，因此进程是动态的。系统运行的一个程序即是一个进程从创建，运行到消亡的过程。 1.3 何为多线程？线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多线程共享同一块内存空间和一组系统资源，所以系统在产生一个线程，或是各个线程之间作切换工作时，负担要比进程小得多，也正是因为如此，线程也称为轻量级进程。 1.4 何为多线程多线程就是多个线程同时运行的或交替的运行。单核 CPU 的话是顺序执行，也就是交替执行。多核 CPU 的话，因为吗，每个 CPU 有自己的运算器，所以在多个 CPU 中可以同时运行。 1.5 为什么多线程是必要的个人感觉可以用一句话概括：开发高并发系统的基础，利用好多线程机制可以大大提高系统整体的并发能力及性能。 1.6 为什么提倡多线程而不是多线程线程就是轻量级的进程，是程序执行的最小单位。使用多线程而不是用多线程去进行并发程序的设计，是因为线程之间的切花和调度的成本远小于进程。 二 几个重要的概念2.1 单核 CPU 与多核 CPU 的理解单核 CPU;其实就是一种假的多线程，因为在一个时间单元类，也只能执行一个线程的任务。就好比如：虽然有很多的车道，但是收费站只有一个工作人员在收费，只有收费才能过去，那么 CPU 就好比如收费人员。如果某个人不想交钱，那么收费人员就可以把他“挂起”（晾着他，等他相同了。准备好钱，再去收费）但是因为 CP 时间单位特别短，因此感觉不出来。多核 CPU：才能更好地发挥出多线程的效率。 一个 Java 应用程序 java.exe，其实至少三个线程：main（）主线程，gc()垃圾回收线程，异常处理线程。当然如果发生异常，会影响主线程。 2.2 并行与并发的理解并行：多个 CPU 同时执行多个任务。比如多个人做不同的事情。并发：一个 CPU（采用时间片）同时执行多个任务。比如：秒杀、多个人做同一件事 三 创建多线程的方式 为了更好的理解，我把 JDK 5 及以前归纳在这里了。 3.1 继承 Thread 类的方式 创建一个继承类 Thread 类的子类 重写 Thread 类中的 run() –&gt; 将此线程的操作声明在 run()中 创建 Thread 类的子类对象 通过此类对象调用 start() ； &lt;1&gt; 启动当前线程 &lt;2&gt; 调用当前线程的 run() 代码示例： 12345678910111213141516171819202122232425class MyThread3 extends Thread &#123; @Override public void run() &#123; for (int i = 0; i &lt; 100; i++) &#123; if (i % 2 == 0) &#123; System.out.println(Thread.currentThread().getName() + &quot;:&quot; + i); &#125; &#125; &#125;&#125;public class RevierTest &#123; public static void main(String[] args) &#123; MyThread3 m1 = new MyThread3(); //设置线程名 m1.setName(&quot;线程一&quot;); MyThread3 m2 = new MyThread3(); //设置线程名 m2.setName(&quot;线程二&quot;); //启动线程m1、m2 m1.start(); m2.start(); &#125;&#125; 运行结果:说明两个问题： 问题一：我们在启动一个线程，必须调用 start()，不能调用 run()的方式启动线程问题二: 如果在启动一个线程，必须创建一个 Thread 子类的对象，调用此对象 start() 3.2 实现 Runnable 接口的方式 创建一个实现 Runnable 接口的类 实现类去实现 Runable 中的抽象方法：run（） 创建实现类的对象 将此对象作为参数传递 Thread 类的构造器中，创建 Thread 类的对象 通过 Thread 类的对象调用 start() 代码示例: 12345678910111213141516171819class myThread implements Runnable&#123; @Override public void run() &#123; for(int i = 0 ; i &lt; 100; i++)&#123; if(i % 2 == 0)&#123; System.out.println(Thread.currentThread().getName()+&quot;:&quot;+i); &#125; &#125; &#125;&#125;public class RevierTest &#123; public static void main(String[] args) &#123; myThread m1 = new myThread(); Thread t1= new Thread(m1); t1.setName(&quot;线程一&quot;); t1.start(); &#125; 运行结果：两种方式（Thread、Runable）的对比： 开发中：优先选择：实现 Runable 接口的方式原因：① 实现的方式没单继承性的局限② 实现的方式更适合来处理多个线程共享数据的情况联系： public class Thread implements Runable相同点：① 两种方式都需要重写 run()，将线程要执行的逻辑声明在 run（）中② 目前这两种方式，要想启动线程，都是调用的 Thread 类中的 start() 3.3 实现 Callable 接口。 —JDK5.0 新增代码示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Number implements Callable &#123; int sum = 0; //1.实现callable方法，将此方法需要执行的操作声明在call() @Override public Object call() throws Exception &#123; for (int i = 0; i &lt; 100; i++) &#123; if (i % 2 == 0) &#123; System.out.println(Thread.currentThread().getName() + &quot;:&quot; + i); sum += i; &#125; &#125; return sum; &#125;&#125;public class CallableTest &#123; public static void main(String[] args) &#123; //2.创建Callable接口实现类对象 Number number = new Number(); //3.将此Callable接口实现类的对象作为传递到FutureTak构造器中，创建FutureTask对象 FutureTask f1 = new FutureTask(number); //4.将FutrueTask的对象作为参数传递到Thread类的构造器，创建Thread的对象 Thread T1 = new Thread(f1); Thread T2 = new Thread(f1); //设置线程名、调用start()方法 T1.setName(&quot;线程一&quot;); T1.start(); T2.setName(&quot;线程二&quot;); T2.start(); Object sum = null; try &#123; //获取Callable中的call方法的返回值 //get（）返回值即为Futruetask构造器参数Callable实现类重写call()的返回值 sum = f1.get(); System.out.println(sum); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 运行结果说明： 如何理解实现 Callable 接口的方式创建多线程比实现 Runnable 接口创建多线程方式强大？① call() 可以有返回值② call() 可以抛出异常，被外面的操作捕获，获取异常的信息③ callable 是支持泛型的 3.4 使用线程池 — JDK5.0代码示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344class NuberThread implements Runnable&#123; @Override public void run() &#123; for(int i =0; i &lt;= 100; i++)&#123; if(i % 2==0)&#123; System.out.println(Thread.currentThread().getName()+&quot;:&quot;+i); &#125; &#125; &#125;&#125;class NuberThread1 implements Runnable&#123; @Override public void run() &#123; for(int i =0; i &lt;= 100; i++)&#123; if(i % 2!=0)&#123; System.out.println(Thread.currentThread().getName()+&quot;:&quot;+i); &#125; &#125; &#125;&#125;public class ThreadPoolTest &#123; public static void main(String[] args) &#123; //提供指定的线程数量的线程池 ExecutorService service = Executors.newFixedThreadPool(10); ThreadPoolExecutor severicel = (ThreadPoolExecutor) service; //设置线程池的属性// System.out.println(service.getClass());// service1.setCorePoolSize(15);// service1.setKeepAliveTime(); //执行指定的线程的操作。需要提供实现Runnable接口或Callable接口实现类的对象 //适用Callable接口 service.execute(new NuberThread()); service.execute(new NuberThread1()); //适用Callable接口 //service.submit(Callable callable); //关闭连接池 service.shutdown(); &#125;&#125; 运行结果：说明： ① 提高响应速度（减少创建新线程的时间）② 降低资源消耗（重复利用线程中的线程，不需要每次都创建）③ 便于线程管理corePoolSize:线程池的大小 maximumPoolSize:最大线程数 keepAliveTime:线程没任务时最多保持多长时间后会终止 四 一些常用方法4.1 start()启动当前线程；调用当前线程的 run() 4.2 run()通常需要重写 Thread 类中的此方法，将创建的线程要执行的操作声明在此方法中 4.3 currentThread()静态方法，返回执行当前代码的线程 4.4 getName()获取当前线程的名字 4.5 setName()设置当前线程的名字 4.6 yield()释放当前 cpu 的执行权 4.7 join()在线程 a 中调用线程 b 的 join(),此时线程 a 就进入阻塞状态，直到线程 b 完全执行完以后，线程 a 才结束阻塞状态。 4.8 stop()已过时。当执行此方法时，强制结束当前线程。 4.9 sleep(long millitime)让当前线程“睡眠”指定的 millitime 毫秒。在指定的 millitime 毫秒时间内，当前线程是阻塞状态。 4.10 isAlive()判断当前线程是否存活 4.11 线程的优先级 MAX_PRIORITY：10 MIN _PRIORITY：1 NORM_PRIORITY：5 –&gt;默认优先级 4.12 获取和设置当前线程的优先级 getPriority():获取线程的优先级 setPriority(int p):设置线程的优先级 说明：高优先级的线程要抢占低优先级线程 cpu 的执行权。但是只是从概率上讲，高优先级的线程高概率的情况下被执行。并不意味着只当高优先级的线程执行完以后，低优先级的线程才执行。 4.13 补充：线程的分类一种是守护线程，一种是用户线程。 五 Thread 的生命周期5.1 图示 5.2 说明 生命周期关注两个概念：状态、相应的方法 关注 ：状态 a –&gt; 状态 b：哪些方法执行了（回调方法）某个方法主动调用:状态 a —&gt; 状态 b 阻塞：临时状态，不可作为最终状态 死亡：最终的状态 线程的同步机制和线程通信放到多线程（二）。 转载地址","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.oy6090.top/categories/Java/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://blog.oy6090.top/tags/Java%E5%9F%BA%E7%A1%80/"}]},{"title":"javaScript 基础语法","slug":"javaScript 基础语法","date":"2020-07-11T16:00:00.000Z","updated":"2020-12-28T00:31:29.661Z","comments":true,"path":"posts/1574967654.html","link":"","permalink":"http://blog.oy6090.top/posts/1574967654.html","excerpt":"","text":"前言： 基础知识语法，代码不多。我已经把代码打包放到文章下面了。 数据类型1.1 JS 中一共分成六种数据类型 String 字符串 Number 数值 Boolean 布尔值 Undefined 未定义 Object 对象 1.2 String 字符串 Js 中字符串需要使用引号引起来或单引号都行​ 在字符串使用\\作为转义字符 12345 \\&#39; &#x3D;&#x3D;&gt; &#39;\\&quot; &#x3D;&#x3D;&gt; &quot;\\n &#x3D;&#x3D;&gt; 换行\\t &#x3D;&#x3D;&gt; 制表\\\\ &#x3D;&#x3D;&gt; \\ 使用 typeof 运算符检查字符串时，会返回“string” 1.3 Number 数值 js 中所有的整数和浮点数都是 Number 类型 特殊的数字 infinity 正无穷 -infinity 负无穷 NaN 非法数字(NOT A Number) 其他进制的数字表示： Ob 开头表示二进制，但是不是多有的浏览器都支持 O 开头表示八进制 Ox 开头表示十六进制 使用 typeof 检查一个 Number 类型的数据时，会返回 number（包括 NaN 和 Infinity） 1.4 Boolean 布尔值 布尔值主要用来逻辑判断，布尔值只有两个 true 逻辑运算 false 逻辑的假 使用 typeo 检查一个布尔值时，会返回”boolean” 1.5 Null 空值 空值专门来表示为空的对象，Null 类型的值只有一个 null 使用 typeof 检查一个 Null 类型的值时会返回”Object” 1.6 Undefined 未定义 如果声明一个变量但是没有为变量赋值变量的值就是 undefined 该类型的值是有一个 underfined 使用 typeof 检查一个 Undefined 类型的值时，会返回”undefined” 1.7 类型的转换 类型转换就是只将其他的数据类型，转换为 String Number 或 Boolean 转换为 String 方式一(强制类型转换)： 调用被转换数据的**toString()**方法 注意： 这个方法付不适用 null 和 undefined 由于这个类型中没有方法，所以调用 toString()时会报错 方式二(强制类型转换)： 调用**String()**函数 原理：对于 Number Boolean String 都会调用他们的 toString()方法来将其转换为字符串，对于 null 值，直接转换为字符串“null”.对于 underfined 直接转换为字符串”undefined” 方式三(隐式的类型转换)： 为任意的数据类型 + “” 原理：和 String()函数一样 转换为 Number 方式一(强制类型转换): 调用Number() 函数 转换的情况： 1.字符串 –&gt; 数字 如果字符串是一个合法的数字，则直接转换为对应的数字 如果字符串时一个非法的数字，则直接转为 NaN 如果是一个空串或纯空格的字符串，则转换为 0 2.布尔值 –&gt; 数字 true 转换为 1 false 转换为 0 3.空值 –&gt; 数值 null 转换为 0 4.未定义 –&gt; 数字 undefined 转换为 NaN 方式二(强制类型的转换): 调用 parseInt() 或 parseFloat() 这两个函数专门将一个字符串转换为数字的 parseInt() 可以将一个字符串中的有效的整数提取出来，并转换为 Number 如果需要可以在 parseInt()中指出一个第二个参数。来指定 Number parseFloat() 可以将一个字符串的有效的小数提取出来，并转换为 Number 方式三(隐式的类型转换)： 使用一元的+来进行隐式的类型转换 原理：和 Number()函数一样 转换为布尔值 方式一(强制类型的转换)： 使用 BOOlean()函数 转换的情况： 字符串 –&gt; 布尔 除了空串其余是 true 数值 –&gt; 布尔 除了 0 和 NaN 其余是全是 true null、undefined –&gt; 布尔 都是 false 对象 –&gt; 布尔 都是 true 方式二(隐式类型转换): 为任意的数据类型做两次非运算，即可将转换为布尔值 123var a &#x3D; &quot;hello&quot;;a &#x3D; !!a;console.log(a); &#x2F;&#x2F; true 数据运算 2.1 运算符 运算符也称为操作符 通过运算符可以对一个或多个值进行运算或操作 typeof 运算符 用来检查一个变量的数据类型 语法：typeof 变量 它会返回一个用于描述类型的字符串作为结果 算数运算符 ‘+’ 对两个值进行加法运算并返回结果 ‘-‘ 对两个值进行减法运算并返回结果 ‘*‘ 对两个值进行乘法运算并返回结果 / 对两个值进行除法运算并返回结果 % 对两个值进行取余运算并返回结果 除了加法以外，对非 Number 类型的值进行运算时，都会先转换为 Number 然后在做运算。而做加法运算时，如果是两个字符串进行相加，则会做拼串操作，将两个字符连接为一个字符串。任何值和字符串做加法，都会先转换为字符串，然后再拼串。 一元运算符 一元运算符只需要一个操作数 一元的 “+” ，就是正号，不会对值产生任何影响，但是可以将一个非数字转换为数字 例子： 12var a &#x3D; true;a &#x3D; +a; 一元的 - 就是负号，可以对一个数字进行符号位取反 例子： 12var a &#x3D; 10;a &#x3D; -a; 自增 自增可以使变量在原值的基础上自增 1 自增使用 ++ 自增可以使用 前++（++a）后++(a++) 无论是++a 还是 a++都会立即使原变量自增 1 不同的是++a 和 a++的值是不同的， ++a 的值是变量的新值（自增后的值） a++的值是变量的原值（自增前的值） 自减 自减可以使变量在原值的基础上自减 1 自减使用 – 自减可以使用 前–（–a）后–(a–) 无论是–a 还是 a–都会立即使原变量自减 1 不同的是–a 和 a–的值是不同的， –a 的值是变量的新值（自减后的值） a–的值是变量的原值（自减前的值） 2.2 逻辑运算符 ！ 非运算可以对一个布尔值进行取反，true 变 false false 变 true 当对非布尔值使用！时，会先将其装换为布尔值然后在取反 当我们利用！来将其他的数据转换为布尔值 &amp;&amp; 可以对符号两侧的值进行与运算 只要两端值都可以 true 时，才会返回 true。 只要有一个 false 就会返回 false。 与是一个短路与，如果第一个值是 false，则不再检查第二个值 对于非布尔值，它会转换为布尔值然后在运算，并检查原值 规则： 1.如果第一个值为 false,则返回第一个值 2.如果第一个值为 true, 则返回第二个值 || 可以对符号两侧的值进行或运算 只有两端都是 false,才会返回 false。只要有一个 true,就会返回 true. 只要两端都是 false 时，才会返回 false。只要有一个 true,就会返回 true. 或是一个短路的或，如果第一个值是 true，则=不再检查第二值 对于非布尔值,它会将其转换为布尔值然后做运算，并返回原值 规则： 1.如果第一个值为 true,则返回第一个值 2.如果第一个值 false,则返回第二个值 2.3 赋值运算符 = 可以将符号右侧的值赋值给左侧变量 += a += 5 相当于 a = a+5 var str = “hello”; str += “world”; -= a -= 5 相当于 a = a-5 *= a * = 5 相当于 a = a*5 /= - a /= 5 相当于 a = a/5 %= - a %= 5 相当于 a = a%5 2.4 关系运算符 关系运算符用来比较两个值之间的大小关系 &gt; &gt;= &lt; &lt;= 关系运算符的规则和数学中一致，用来比较两个值之间的关系 如果关系成立则返回 true，关系不成立则返回 false。 如果比价的两个值是非数值，会将其装换为 Number 然后在比较。 如果比较的两个值都是字符串，此时会比较字符串的 Unicode 编码，而不会转换为 Number. 2.5 相等运算符 == 相等，判断左右两个值是否相等，如果相等返回 true,如果不等于返回 false 相等会自动对两个值进行类型转换，如果对不同的类型进行比较，会将其转换为相同的类型为相同的类型然后在比较。转换后相等它也会返回 true != 不等，判断左右两个值是否不等，如果不等则返回 true，如果相等则返回 false 不等也会做自动的类型转换 === 全等，判断左右两个值是否全等，它和相等类似，只不过它不会进行自动的类型转换 如果两个值的类型不同，则直接返回 false !== 不全等，和不等类似，但是它不会进行自动的类型转换，如果两个值的类型不同，他会直接返回 true 特殊的值： null 和 undefined 由于 undefined 衍生出 null ，所以 null == undefined 会返回 true NaN 不与任何值相等，包括它自身 NaN == NaN // false 判断一个值是否是 NaN，使用 isNaN() 函数 2.6 三元运算符 ?: 语法：条件表达式?语句 1:语句 2; 执行流程： 先对条件表达式求值判断， 如果判断结果为 true，则执行语句 1，并返回执行结果 如果判断结果为 false，则执行语句 2，并返回执行结果 优先级： 和数学中一样，JS 中的运算符也是具有优先级的， 比如 先乘除 后加减 先与 后或 具体的优先级可以参考优先级的表格，在表格中越靠上的优先级越高， 优先级越高的越优先计算，优先级相同的，从左往右计算。 优先级不需要记忆，如果越到拿不准的，使用()来改变优先级。 基本语法 程序都是自上向下的顺序执行的，通过流程控制语句可以改变程序执行的顺序，或者反复的执行某一段的程序。 分类： 1.条件判断语句 2.条件分支语句 3.循环语句 3.1 条件判断语句 条件判断语句也称为 if 语句 语法一： 123if(条件表达式)&#123; 语句...&#125; 执行流程： if语句执行时，会先对条件表达式进行求值判断， 如果值为 true，则执行 if 后的语句 如果值为 false，则不执行 语法二： 12345if(条件表达式)&#123; 语句...&#125;else&#123; 语句...&#125; 执行流程： if…else语句执行时，会对条件表达式进行求值判断， 如果值为 true，则执行 if 后的语句 如果值为 false，则执行 else 后的语句 语法三： 1234567891011if(条件表达式)&#123; 语句...&#125;else if(条件表达式)&#123; 语句...&#125;else if(条件表达式)&#123; 语句...&#125;else if(条件表达式)&#123; 语句...&#125;else&#123; 语句...&#125; 执行流程 if…else if…else 语句执行时，会自上至下依次对条件表达式进行求值判断， 如果判断结果为 true，则执行当前 if 后的语句，执行完成后语句结束。 如果判断结果为 false，则继续向下判断，直到找到为 true 的为止。 如果所有的条件表达式都是 false，则执行 else 后的语句 3.2 条件分支语句 switch 语句 语法: 1234567891011121314switch(条件表达式)&#123; case 表达式: 语句... break; case 表达式: 语句... break; case 表达式: 语句... break; default: 语句... break;&#125; 执行流程： **switch…case…**语句在执行时，会依次将 case 后的表达式的值和 switch 后的表达式的值进行全等比较， 如果比较结果为 false，则继续向下比较。如果比较结果为 true，则从当前 case 处开始向下执行代码。 如果所有的 case 判断结果都为 false，则从 default 处开始执行代码。 3.3 循环语句 通过循环语句可以反复执行某些语句多次 while 循环 语法: 123while(条件表达式)&#123; 语句...&#125; 执行流程： while 语句在执行时，会先对条件表达式进行求值判断， 如果判断结果为 false，则终止循环 如果判断结果为 true，则执行循环体 循环体执行完毕，继续对条件表达式进行求值判断，依此类推 do…while 循环 语法: 123do&#123; 语句...&#125;while(条件表达式) 执行流程 123do...while在执行时，会先执行do后的循环体，然后在对条件表达式进行判断， 如果判断判断结果为false，则终止循环。 如果判断结果为true，则继续执行循环体，依此类推 两者区别 while：先判断后执行 do…while: 先执行后判断 ，可以确保循环体至少执行一次。 for 循环 语法： 123for(①初始化表达式 ; ②条件表达式 ; ④更新表达式)&#123; ③语句...&#125; 执行流程： 首先执行 ① 初始化表达式，初始化一个变量， 然后对 ② 条件表达式进行求值判断，如果为 false 则终止循环 如果判断结果为 true，则执行 ③ 循环体 循环体执行完毕，执行 ④ 更新表达式，对变量进行更新。 更新表达式执行完毕重复 ② 死循环 1234567while(true)&#123;&#125;for(;;)&#123;&#125; 可以使用 vscode 和 notepad++ 打开 链接：https://pan.baidu.com/s/1yfS00YJtShuZVncxzWUrvw提取码：7q9u","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://blog.oy6090.top/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"javaScript基础","slug":"javaScript基础","permalink":"http://blog.oy6090.top/tags/javaScript%E5%9F%BA%E7%A1%80/"}]},{"title":"代理模式","slug":"代理模式","date":"2020-07-11T16:00:00.000Z","updated":"2021-01-22T03:46:57.030Z","comments":true,"path":"posts/2068909584.html","link":"","permalink":"http://blog.oy6090.top/posts/2068909584.html","excerpt":"","text":"代码示例： 123456789101112131415161718192021222324interface NetWork&#123; public void browse();&#125;//被代理类class Server implements NetWork&#123; public void browse()&#123; System.out.println(&quot;真实的服务器访问网络&quot;); &#125;&#125;//代理类class ProxyServer implements NetWork&#123; private NetWork work; public ProxyServer(NetWork work)&#123; this.work = work; &#125; public void chek()&#123; System.out.println(&quot;联网之前的检查工作&quot;); &#125; public void browse()&#123; chec(); work.browse(); &#125;&#125; 1234567public class ProxyTest &#123; public static void main(String[] args) &#123; Server server = new Server(); ProxyServer pro = new ProxyServer(server); pro.browse(); &#125;&#125; 运行结果","categories":[{"name":"Java设计模式","slug":"Java设计模式","permalink":"http://blog.oy6090.top/categories/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"Java设计模式","slug":"Java设计模式","permalink":"http://blog.oy6090.top/tags/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"斐波拉契数列","slug":"斐波拉契数列","date":"2020-07-11T16:00:00.000Z","updated":"2021-01-22T03:47:04.323Z","comments":true,"path":"posts/2560.html","link":"","permalink":"http://blog.oy6090.top/posts/2560.html","excerpt":"","text":"斐波拉契数列 fn = f(n-1) + f(n-2) 其中 n 是正整数，且 n 大于等于 2代码示例： 1234567891011121314151617181920public class TestFibonacci &#123; public static void main(String[] args) &#123; int result = fibonacci(8); System.out.println(result); &#125; public static int fibonacci(int index)&#123; if(index &gt;= 0)&#123; if(index == 0)&#123; return 0; &#125;else if(index ==1)&#123; return 1; &#125;else&#123; return fibonacci(index -1) +fibonacci(index -2); &#125; &#125;else&#123; System.out.println(&quot;请你重新输入&quot;); return -1; &#125; &#125;&#125;","categories":[{"name":"Java算法","slug":"Java算法","permalink":"http://blog.oy6090.top/categories/Java%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Java算法","slug":"Java算法","permalink":"http://blog.oy6090.top/tags/Java%E7%AE%97%E6%B3%95/"}]},{"title":"java枚举类","slug":"枚举类","date":"2020-07-11T16:00:00.000Z","updated":"2021-01-22T03:47:45.100Z","comments":true,"path":"posts/38213.html","link":"","permalink":"http://blog.oy6090.top/posts/38213.html","excerpt":"","text":"一、 枚举类的说明 枚举类的理解：类的对象只有有限个，确定的。当需要定义一组常量时，强烈建议使用枚举类如果枚举类只一个对象，则可以作为单例模式的实现方式。 二、如何定义枚举类① 自定义枚举类123456789101112131415161718192021222324252627282930313233class Season&#123; // 1.声明Season对象的属性：private final修饰 private final String seasonName; private final String seasonDesc; // 私有化的构造器，并给对象赋值 private Season(String seasonName, String seasonDesc)&#123; this.seasonName = seasonName; this.seasonDesc = seasonDesc; &#125; // 3.提供当前枚举类的多个对象：public static final的 public static final Season SPRING = new Season(&quot;春天&quot;,&quot;春暖花开&quot;); public static final Season SUMMER = new Season(&quot;夏天&quot;,&quot;夏日炎炎&quot;); public static final Season AUTUMN = new Season(&quot;秋天&quot;,&quot;秋高气爽&quot;); public static final Season WINTER = new Season(&quot;冬天&quot;,&quot;冰天雪地&quot;); public String getSeasonName() &#123; return seasonName; &#125; public String getSeasonDesc() &#123; return seasonDesc; &#125; @Override public String toString() &#123; return &quot;Season&#123;&quot; + &quot;seasonName=&#x27;&quot; + seasonName + &#x27;\\&#x27;&#x27; + &quot;, seasonDesc=&#x27;&quot; + seasonDesc + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; 123456public class SeasonTest &#123; public static void main(String[] args) &#123; Season autumn = Season.AUTUMN; System.out.println(autumn); // Season&#123;seasonName=&#x27;秋天&#x27;, seasonDesc=&#x27;秋高气爽&#x27;&#125; &#125;&#125; ② JDK5.0 新增使用 enum 定义枚举类。1234567891011121314151617181920212223242526272829303132333435// 使用enum关键枚举类enum Season1&#123; // 1.提供当前枚举类的对象，多个对象之间用“,”隔开，末尾对象&quot;;&quot;结束 SPRING(&quot;春天&quot;,&quot;春暖花开&quot;), SUMMER(&quot;夏天&quot;,&quot;夏日炎炎&quot;), AUTUMN(&quot;秋天&quot;,&quot;秋高气爽&quot;), WINTER(&quot;冬天&quot;,&quot;冰天雪地&quot;); // 2.声明Season对象的属性：private final修饰 private final String SeasonName; private final String SeasonDesc; // 3.私有化构造器，并给对象赋值 private Season1(String SeasonName, String SeasonDesc)&#123; this.SeasonName = SeasonName; this.SeasonDesc = SeasonDesc; &#125; // 4.获取枚举类对象的属性 public String getSeasonName() &#123; return SeasonName; &#125; public String getSeasonDesc() &#123; return SeasonDesc; &#125; @Override public String toString() &#123; return &quot;Season1&#123;&quot; + &quot;SeasonName=&#x27;&quot; + SeasonName + &#x27;\\&#x27;&#x27; + &quot;, SeasonDesc=&#x27;&quot; + SeasonDesc + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; 1234567public class SeasonTest2 &#123; public static void main(String[] args) &#123; Season1 season = Season1.AUTUMN; System.out.println(season); // Season1&#123;SeasonName=&#x27;秋天&#x27;, SeasonDesc=&#x27;秋高气爽&#x27;&#125; &#125;&#125; ③ emum 定义枚举类之后，枚举类常用方法：（继承于 java.lang.Enum 类） value() 返回所有的枚举类对象的构成的数组 valueOf(String objName):返回枚举类中对象名是 objName 的对象。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455interface Info&#123; void show();&#125;// 使用enum关键字枚举类enum Season2 implements Info&#123; //1.提供当前枚举类的对象，多个对象之间用&quot;,&quot;隔开，末尾对象&quot;;&quot;结束 SPRING(&quot;春天&quot;,&quot;春暖花开&quot;)&#123; @Override public void show() &#123; System.out.println(&quot;春天在那里&quot;); &#125; &#125;, SUMMER(&quot;夏天&quot;,&quot;夏日炎炎&quot;)&#123; @Override public void show() &#123; System.out.println(&quot;宁夏&quot;); &#125; &#125;, AUTUMN(&quot;秋天&quot;,&quot;秋高气爽&quot;)&#123; @Override public void show() &#123; System.out.println(&quot;秋天不回来&quot;); &#125; &#125;, WINTER(&quot;冬天&quot;,&quot;冰天雪地&quot;)&#123; @Override public void show() &#123; System.out.println(&quot;大约在冬季&quot;); &#125;; &#125;; private final String SeasonName; private final String SeasonDesc; private Season2(String SeasonName , String SeasonDesc)&#123; this.SeasonName = SeasonName; this.SeasonDesc = SeasonDesc; &#125; public String getSeasonName() &#123; return SeasonName; &#125; public String getSeasonDesc() &#123; return SeasonDesc; &#125; @Override public String toString() &#123; return &quot;Season2&#123;&quot; + &quot;SeasonName=&#x27;&quot; + SeasonName + &#x27;\\&#x27;&#x27; + &quot;, SeasonDesc=&#x27;&quot; + SeasonDesc + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; 12345678910111213141516171819202122232425262728public class SeasonTest3 &#123; public static void main(String[] args) &#123; Season2 season = Season2.AUTUMN; System.out.println(season.toString()); //Season2&#123;SeasonName=&#x27;秋天&#x27;, SeasonDesc=&#x27;秋高气爽&#x27;&#125; season.show(); // 秋天不回来 // value 返回所有的枚举类对象的构成的数组 Season2[] values = season.values();// for (Season2 value : values) &#123;// System.out.println(value);// value.show();// &#125; for(int i = 0 ; i &lt;values.length; i++)&#123; System.out.println(values[i]); values[i].show(); &#125; System.out.println(&quot;*************************************************&quot;); Thread.State[] values1 = Thread.State.values(); for(int i = 0 ; i &lt; values1.length; i++)&#123; System.out.println(values1[i]); &#125; System.out.println(&quot;***************************************&quot;); // valueOf(String objName):返回枚举类中对象名是objName的对象。 Season2 spring = Season2.valueOf(&quot;SPRING&quot;); System.out.println(spring); // Season2&#123;SeasonName=&#x27;春天&#x27;, SeasonDesc=&#x27;春暖花开&#x27;&#125; &#125; 运行结果： value（）","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://blog.oy6090.top/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://blog.oy6090.top/tags/Java%E5%9F%BA%E7%A1%80/"}]},{"title":"模板方法的设计模式","slug":"模板方法的设计模式","date":"2020-07-11T16:00:00.000Z","updated":"2021-01-22T03:47:56.596Z","comments":true,"path":"posts/8518.html","link":"","permalink":"http://blog.oy6090.top/posts/8518.html","excerpt":"","text":"代码示例： 1234567891011121314151617181920212223242526abstract class Template&#123; //计算某段代码执行所需要花费的时间 public void spendTime()&#123; long start = System.currentTimeMillis(); this.code();//不确定的部分、易变的部分 long end = Syetem.currentTimeMills(); System.out.println(&quot;花费的时间为：&quot;+(end-start)) &#125; public abstract void code();&#125;class SubTemplate extends Template&#123; public void code()&#123; for(int i= 0; i &lt; Math.sqrt(i); i++)&#123; boolean isFlag = true; for(int j =2; j &lt;= Math.sqrt(i); j++)&#123; if(i % j == 0)&#123; isFlag = false; break; &#125; &#125; if(isFlag)&#123; System.out.println(i); &#125; &#125; &#125;&#125;","categories":[{"name":"Java设计模式","slug":"Java设计模式","permalink":"http://blog.oy6090.top/categories/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"Java设计模式","slug":"Java设计模式","permalink":"http://blog.oy6090.top/tags/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"高效使用Github寻找开源项目","slug":"高效使用Github寻找开源项目","date":"2020-07-11T16:00:00.000Z","updated":"2020-07-11T16:00:00.000Z","comments":true,"path":"posts/1550900565.html","link":"","permalink":"http://blog.oy6090.top/posts/1550900565.html","excerpt":"","text":"Git 和 GitHub 什么关系？ Git（读音为/gɪt/）是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。 GitHub 是一个面向开源及私有软件项目的托管平台，因为只支持 git 作为唯一的版本库格式进行托管，故名 GitHub。 git 用来管理你的代码，可以对你的项目进行版本控制，github 将你用 git 管理的项目放在网上， 本地的一个个项目对应 github 上面的一个个仓库。仓库可以公开（开源），私密。程序员之间可以互相学习别人的项目，互相交流，github 是全球最大的同性交友网站。 怎么在 GitHub 上靠谱的找一些开源项目 &gt; 1234567891011121314# 按照项目名/仓库名搜索（大小写不敏感）in:name xxx# 按照README搜索（大小写不敏感）in:readme xxx# 按照description搜索（大小写不敏感）in:description xxx# stars数大于xxxstars:&gt;xxx# forks数大于xxxforks:&gt;xxx# 编程语言为xxxlanguage:xxx# 最新更新时间晚于YYYY-MM-DDpushed:&gt;YYYY-MM-DD 示例","categories":[{"name":"GitHub","slug":"GitHub","permalink":"http://blog.oy6090.top/categories/GitHub/"}],"tags":[{"name":"GitHub","slug":"GitHub","permalink":"http://blog.oy6090.top/tags/GitHub/"}]},{"title":"CentOS 7 基本命令","slug":"CentOS 7 基本命令","date":"2020-07-11T16:00:00.000Z","updated":"2021-01-22T03:48:25.329Z","comments":true,"path":"posts/6297.html","link":"","permalink":"http://blog.oy6090.top/posts/6297.html","excerpt":"","text":"CentOS7 常用命令集合 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这两天一直在对CentOS 7.2进行初体验，各种学习命令肿么用，不过其实大多和DOS是一样的，只是命令的表达上可能有点儿不一样，毕竟这些都不是一家出来的嘛~ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;废话不多说，直接上命令和解析！ 常用命令 文件与目录操作 命令 解析 cd /home 进入 ‘/home’ 目录 cd .. 返回上一级目录 cd ../.. 返回上两级目录 cd - 返回上次所在目录 cp file1 file2 将file1复制为file2 cp -a dir1 dir2 复制一个目录 cp -a /tmp/dir1 . 复制一个目录到当前工作目录（.代表当前目录） ls 查看目录中的文件 ls -a 显示隐藏文件 ls -l 显示详细信息 ls -lrt 按时间显示文件（l表示详细列表，r表示反向排序，t表示按时间排序） pwd 显示工作路径 mkdir dir1 创建 ‘dir1’ 目录 mkdir dir1 dir2 同时创建两个目录 mkdir -p /tmp/dir1/dir2 创建一个目录树 mv dir1 dir2 移动/重命名一个目录 rm -f file1 删除 ‘file1’ rm -rf dir1 删除 ‘dir1’ 目录及其子目录内容 查看文件内容 命令 解析 cat file1 从第一个字节开始正向查看文件的内容 head -2 file1 查看一个文件的前两行 more file1 查看一个长文件的内容 tac file1 从最后一行开始反向查看一个文件的内容 tail -3 file1 查看一个文件的最后三行 vi file 打开并浏览文件 文本内容处理 命令 解析 grep str /tmp/test 在文件 ‘/tmp/test’ 中查找 “str” grep ^str /tmp/test 在文件 ‘/tmp/test’ 中查找以 “str” 开始的行 grep [0-9] /tmp/test 查找 ‘/tmp/test’ 文件中所有包含数字的行 grep str -r /tmp/* 在目录 ‘/tmp’ 及其子目录中查找 “str” diff file1 file2 找出两个文件的不同处 sdiff file1 file2 以对比的方式显示两个文件的不同 vi file 操作 解析 i 进入编辑文本模式 Esc 退出编辑文本模式 :w 保存当前修改 :q 不保存退出vi :wq 保存当前修改并退出vi 查询操作 命令 解析 find / -name file1 从 ‘/’ 开始进入根文件系统查找文件和目录 find / -user user1 查找属于用户 ‘user1’ 的文件和目录 find /home/user1 -name *.bin 在目录 ‘/ home/user1’ 中查找以 ‘.bin’ 结尾的文件 find /usr/bin -type f -atime +100 查找在过去100天内未被使用过的执行文件 find /usr/bin -type f -mtime -10 查找在10天内被创建或者修改过的文件 locate *.ps 寻找以 ‘.ps’ 结尾的文件，先运行 ‘updatedb’ 命令 find -name ‘*.[ch]’ | xargs grep -E ‘expr’ 在当前目录及其子目录所有.c和.h文件中查找 ‘expr’ find -type f -print0 | xargs -r0 grep -F ‘expr’ 在当前目录及其子目录的常规文件中查找 ‘expr’ find -maxdepth 1 -type f | xargs grep -F ‘expr’ 在当前目录中查找 ‘expr’ 压缩、解压 命令 解析 bzip2 file1 压缩 file1 bunzip2 file1.bz2 解压 file1.bz2 gzip file1 压缩 file1 gzip -9 file1 最大程度压缩 file1 gunzip file1.gz 解压 file1.gz tar -cvf archive.tar file1 把file1打包成 archive.tar（-c: 建立压缩档案；-v: 显示所有过程；-f: 使用档案名字，是必须的，是最后一个参数） tar -cvf archive.tar file1 dir1 把 file1，dir1 打包成 archive.tar tar -tf archive.tar 显示一个包中的内容 tar -xvf archive.tar 释放一个包 tar -xvf archive.tar -C /tmp 把压缩包释放到 /tmp目录下 zip file1.zip file1 创建一个zip格式的压缩包 zip -r file1.zip file1 dir1 把文件和目录压缩成一个zip格式的压缩包 unzip file1.zip 解压一个zip格式的压缩包到当前目录 unzip test.zip -d /tmp/ 解压一个zip格式的压缩包到 /tmp 目录 yum安装器 命令 解析 yum -y install [package] 下载并安装一个rpm包 yum localinstall [package.rpm] 安装一个rpm包，使用你自己的软件仓库解决所有依赖关系 yum -y update 更新当前系统中安装的所有rpm包 yum update [package] 更新一个rpm包 yum remove [package] 删除一个rpm包 yum list 列出当前系统中安装的所有包 yum search [package] 在rpm仓库中搜寻软件包 yum clean [package] 清除缓存目录（/var/cache/yum）下的软件包 yum clean headers 删除所有头文件 yum clean all 删除所有缓存的包和头文件 网络相关 命令 解析 ifconfig eth0 显示一个以太网卡的配置 ifconfig eth0 192.168.1.1 netmask 255.255.255.0 配置网卡的IP地址 ifdown eth0 禁用 ‘eth0’ 网络设备 ifup eth0 启用 ‘eth0’ 网络设备 iwconfig eth1 显示一个无线网卡的配置 iwlist scan 显示无线网络 ip addr show 显示网卡的IP地址 系统相关 命令 解析 su - 切换到root权限（与su有区别） shutdown -h now 关机 shutdown -r now 重启 top 罗列使用CPU资源最多的linux任务 （输入q退出） pstree 以树状图显示程序 man ping 查看参考手册（例如ping 命令） passwd 修改密码 df -h 显示磁盘的使用情况 cal -3 显示前一个月，当前月以及下一个月的月历 cal 10 1988 显示指定月，年的月历 date –date ‘1970-01-01 UTC 1427888888 seconds’ 把一相对于1970-01-01 00:00的秒数转换成时间 XSheel 5相关操作 窗体快捷键 命令 解析 Ctrl + u 删除光标之前到行首的字符 Ctrl + k 删除光标之前到行尾的字符 Ctrl + c 取消当前行输入的命令，相当于Ctrl + Break Ctrl + a 光标移动到行首（ahead of line），相当于通常的Home键 Ctrl + e 光标移动到行尾（end of line） Ctrl + f 光标向前（forward）移动一个字符位置 Ctrl + b 光标往回（backward）移动一个字符位置 Ctrl + l 清屏，相当于执行clear命令 Ctrl + r 显示:号提示，根据用户输入查找相关历史命令（reverse-i-search） Ctrl + w 删除从光标位置前到当前所处单词（word）的开头 Ctrl + t 交换光标位置前的两个字符 Ctrl + y 粘贴最后一次被删除的单词 Ctrl + Alt + d 显示桌面 Alt + b 光标往回（backward）移动到前一个单词 Alt + d 删除从光标位置到当前所处单词的末尾 Alt + F2 运行 Alt + F4 关闭当前窗口 Alt + F9 最小化当前窗口 Alt + F10 最大化当前窗口 Alt + Tab 切换窗口 Alt + 左键 移动窗口（或在最下面的任务栏滚动鼠标滑轮） 操作小技巧 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;鼠标中间键：粘贴突出显示的文本。(使用鼠标左键来选择文本。把光标指向想粘贴文本的地方。点击鼠标中间键来粘贴。) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Tab：命令行自动补全。使用 shell 提示时可使用这一方式。键入命令或文件名的前几个字符，然后按 [Tab] 键，它会自动补全命令或显示匹配键入字符的所有命令。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在滚动条的空白处点击鼠标中键：屏幕即滚动到那个地方。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在桌面或文件管理器中直接按 / 就可以输入位置，打开文件管理器。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 vi 或 Firefox 中直接按 / 即可进入快速搜索状态。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;网站链接和图片可直接拖放到桌面或者目录，可以马上下载。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;直接将文件管理器中的文件拖到终端中就可以在终端中得到完整的路径名。 结束语 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其实要学好Linux的操作并不是很困难的事情，在平常的使用过程中，碰到问题，学会去网上寻找答案不失为一个非常好的手段！谢谢大家！ 转载：(http://blog.csdn.net/o0darknessyy0o/article/details/52072054#t1)","categories":[{"name":"CentOS","slug":"CentOS","permalink":"http://blog.oy6090.top/categories/CentOS/"}],"tags":[{"name":"CentOS 7","slug":"CentOS-7","permalink":"http://blog.oy6090.top/tags/CentOS-7/"}]},{"title":"JDBC模板（二）","slug":"JDBC模板（二）","date":"2020-07-11T16:00:00.000Z","updated":"2020-10-25T02:16:33.945Z","comments":true,"path":"posts/1393401608.html","link":"","permalink":"http://blog.oy6090.top/posts/1393401608.html","excerpt":"","text":"这篇没有采用数据库连接池，如需要数据库连接池，可以参考我上一篇 JDBC 模板 JDBC 项目结构：整体结构代码示例： 配置数据库加载文件 同时在项目工程下创建 bin 目录来存在第三方 jar 包 导入第三方 jar 包【连接数据库】 1234user=rootpassword=【这里填写自己的数据库连接密码】url=jdbc:mysql://localhost:3306/test?rewriteBatchedStatements=truedriveClass=com.mysql.jdbc.Driver 【JDBCUtils】操作数据库的工具类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889package com.oy.online.JDBC1.util;import java.io.InputStream;import java.sql.*;import java.util.Properties;/***@Description 操作数据库的工具类*@Author OY*@Date 2020/5/30*@Time 17:08*/public class JDBCUtils &#123; /** *@Description 获取数据库连接 *@Param *@Return *@Author OY *@Date 2020/5/30 *@Time 17:09 */ public static Connection getConnection() throws Exception &#123; //1.读取配置文件中的4个基本信息 InputStream is = ClassLoader.getSystemClassLoader().getResourceAsStream(&quot;jdbc.properties&quot;); Properties pros = new Properties(); pros.load(is); String user = pros.getProperty(&quot;user&quot;); String password = pros.getProperty(&quot;password&quot;); String url = pros.getProperty(&quot;url&quot;); String driveClass = pros.getProperty(&quot;driveClass&quot;); //加载驱动 Class.forName(driveClass); // 3.获取连接 Connection conn = DriverManager.getConnection(url, user, password); return conn; &#125; /** *@Description 关闭资源操作 *@Param [conn, ps] *@Return void *@Author OY *@Date 2020/5/30 *@Time 17:21 */ public static void closeResource(Connection conn, Statement ps)&#123; try &#123; if(ps != null)&#123; ps.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; try &#123; if(conn != null)&#123; conn.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; public static void closeResource(Connection conn,Statement ps,ResultSet rs)&#123; try &#123; if(ps != null)&#123; ps.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; try &#123; if(conn != null)&#123; conn.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; try &#123; if(rs != null)&#123; rs.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 【Customers】 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package com.oy.online.JDBC1.bean;import java.sql.Date;/***@Description*@Author OY*@Date 2020/5/30*@Time 17:23*/public class Customer &#123; private int id; private String name; private String email; private Date birth; public Customer() &#123; &#125; public Customer(int id, String name, String email, Date birth) &#123; this.id = id; this.name = name; this.email = email; this.birth = birth; &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getEamil() &#123; return email; &#125; public void setEamil(String eamil) &#123; this.email = eamil; &#125; public Date getBirth() &#123; return birth; &#125; public void setBirth(Date birth) &#123; this.birth = birth; &#125; @Override public String toString() &#123; return &quot;Customer&#123;&quot; + &quot;id=&quot; + id + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, eamil=&#x27;&quot; + email + &#x27;\\&#x27;&#x27; + &quot;, birth=&quot; + birth + &#x27;&#125;&#x27;; &#125;&#125; 【BaseDAO】 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160ackage com.oy.online.JDBC1.DAO;import com.oy.online.JDBC1.util.JDBCUtils;import java.lang.reflect.Field;import java.sql.*;import java.util.ArrayList;import java.util.List;/** * @Description 封装针对于数据表的通用的操作 * @Author OY * @Date 2020/5/30 * @Time 17:26 */public abstract class BaseDAO &#123; /** * @Description 通用的增删改 * @Param [conn, sql, args] * @Return int * @Author OY * @Date 2020/5/30 * @Time 17:31 */ public int update(Connection conn, String sql, Object... args) &#123; PreparedStatement ps = null; try &#123; // 1.预编译sql语句，返回preparedStatement的实例 ps = conn.prepareStatement(sql); // 2.填充占位符 for (int i = 0; i &lt; args.length; i++) &#123; ps.setObject(i + 1, args[i]); &#125; //3.执行 return ps.executeUpdate(); &#125; catch (SQLException throwables) &#123; throwables.printStackTrace(); &#125; finally &#123; JDBCUtils.closeResource(null, ps); &#125; return 0; &#125; /** * @Description 查询数据表中的一条记录 * @Param [conn, clazz, sql, args] * @Return T * @Author OY * @Date 2020/5/30 * @Time 17:44 */ public &lt;T&gt; T getInstance(Connection conn, Class&lt;T&gt; clazz, String sql, Object... args) &#123; PreparedStatement ps = null; ResultSet rs = null; try &#123; ps = conn.prepareStatement(sql); //2.填充占位符 for (int i = 0; i &lt; args.length; i++) &#123; ps.setObject(i + 1, args[i]); &#125; // 3.执行 rs = ps.executeQuery(); // 获取结果集的元数据 ResultSetMetaData rsmd = rs.getMetaData(); // 获取结果集中的列数 int columnCount = rsmd.getColumnCount(); if (rs.next()) &#123; T t = clazz.newInstance(); for (int i = 0; i &lt; columnCount; i++) &#123; // 获取列值 Object colunmnValue = rs.getObject(i + 1); // 获取每个列的列名 String columnLabel = rsmd.getColumnLabel(i + 1); Field field = clazz.getDeclaredField(columnLabel); field.setAccessible(true); field.set(t,colunmnValue); &#125; return t; &#125; &#125; catch (Exception throwables) &#123; throwables.printStackTrace(); &#125; finally &#123; JDBCUtils.closeResource(null, ps, rs); &#125; return null; &#125; /** * @Description 查询数据表中的多条数据 * @Param [conn, clazz, sql, args] * @Return java.util.List&lt;T&gt; * @Author OY * @Date 2020/5/30 * @Time 17:46 */ public &lt;T&gt; List&lt;T&gt; getForList(Connection conn, Class&lt;T&gt; clazz, String sql, Object...args) &#123; PreparedStatement ps = null; ResultSet rs = null; try &#123; ps = conn.prepareStatement(sql); for (int i = 0; i &lt; args.length; i++) &#123; ps.setObject(i + 1, args[i]); &#125; rs = ps.executeQuery(); ResultSetMetaData rsmd = rs.getMetaData(); int columnCount = rsmd.getColumnCount(); // 创建集合对象 ArrayList&lt;T&gt; list = new ArrayList&lt;&gt;(); while (rs.next()) &#123; T t = clazz.newInstance(); for (int i = 0; i &lt; columnCount; i++) &#123; Object columValue = rs.getObject(i + 1); String columnLabel = rsmd.getColumnLabel(i + 1); Field field = clazz.getDeclaredField(columnLabel); field.setAccessible(true); field.set(t, columValue); &#125; list.add(t); &#125; return list; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; JDBCUtils.closeResource(null, ps, rs); &#125; return null; &#125; /** *@Description 用于查询特殊值 *@Param [conn, sql, args] *@Return E *@Author OY *@Date 2020/5/30 *@Time 18:02 */ public &lt;E&gt; E getValue(Connection conn, String sql, Object... args) &#123; PreparedStatement ps = null; ResultSet rs = null; try &#123; ps = conn.prepareStatement(sql); for (int i = 0; i &lt; args.length; i++) &#123; ps.setObject(i + 1, args[i]); &#125; rs = ps.executeQuery(); if (rs.next()) &#123; return (E) rs.getObject(1); &#125; &#125; catch (Exception throwables) &#123; throwables.printStackTrace(); &#125; finally &#123; JDBCUtils.closeResource(null, ps, rs); &#125; return null; &#125;&#125; 【CustomerDAO.java】 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384package com.oy.online.JDBC1.DAO;import com.oy.online.JDBC1.bean.Customer;import java.sql.Connection;import java.sql.Date;import java.util.List;/***@Description*@Author OY*@Date 2020/5/30*@Time 18:03*/public interface CustomerDAO &#123; /** *@Description 将cust对象添加到数据库中 *@Param [conn, cust] *@Return void *@Author OY *@Date 2020/5/30 *@Time 18:05 */ void insert(Connection conn, Customer cust); /** *@Description 针对指定的id，删除表中的一条记录 *@Param [conn, id] *@Return void *@Author OY *@Date 2020/5/30 *@Time 18:05 */ void deletById(Connection conn, int id); /** *@Description 针对内存中的cust对象，去修改数据表中指定的记录 *@Param [conn, cust] *@Return void *@Author OY *@Date 2020/5/30 *@Time 18:07 */ void update(Connection conn, Customer cust); /** *@Description 指定的id查询得到指定的customer对象 *@Param [conn, id] *@Return com.oy.online.JDBC1.bean.Customer *@Author OY *@Date 2020/5/30 *@Time 18:11 */ Customer getCustomerById(Connection conn, int id); /** *@Description 查询表中的所有数据构成的集合 *@Param [conn] *@Return java.util.List&lt;com.oy.online.JDBC1.bean.Customer&gt; *@Author OY *@Date 2020/5/30 *@Time 18:12 */ List&lt;Customer&gt; getAll(Connection conn); /** *@Description 返回数据表中的数据的条目数 *@Param [conn] *@Return java.lang.Long *@Author OY *@Date 2020/5/30 *@Time 18:14 */ Long getCount(Connection conn); /** *@Description 返回数据表中最大的生日 *@Param [conn] *@Return java.sql.Date *@Author OY *@Date 2020/5/30 *@Time 18:15 */ Date getMaxBirth(Connection conn);&#125; 【CustomerDAOImpI.java】 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.oy.online.JDBC1.DAO;import com.oy.online.JDBC1.bean.Customer;import java.sql.Connection;import java.sql.Date;import java.util.List;public class CustomerDAOImpI extends BaseDAO implements CustomerDAO &#123; @Override public void insert(Connection conn, Customer cust) &#123; String sql = &quot;insert into customers(name,email,birth)values(?,?,?)&quot;; update(conn,sql,cust.getName(),cust.getEamil(),cust.getBirth()); &#125; @Override public void deletById(Connection conn, int id) &#123; String sql = &quot;delete from customers where id = ?&quot;; update(conn,sql, id); &#125; @Override public void update(Connection conn, Customer cust) &#123; String sql = &quot;update customers set name = ? , email = ?, birth = ? where id = ?&quot;; update(conn, sql, cust.getName(),cust.getEamil(),cust.getBirth(),cust.getId()); &#125; @Override public Customer getCustomerById(Connection conn, int id) &#123; String sql = &quot;select id,name,email,birth from customers where id = ?&quot;; Customer customer = getInstance(conn,Customer.class, sql,id); return customer; &#125; @Override public List&lt;Customer&gt; getAll(Connection conn) &#123; String sql = &quot;select id ,name, email, birth from customers &quot;; List&lt;Customer&gt; list = getForList(conn, Customer.class, sql); return list; &#125; @Override public Long getCount(Connection conn) &#123; String sql = &quot;select count(*) from customers&quot;; return getValue(conn, sql); &#125; @Override public Date getMaxBirth(Connection conn) &#123; String sql = &quot;select max(birth) from customers&quot;; return getValue(conn, sql); &#125;&#125; 测试【text】 测试数据库连接 12345678910111213141516171819202122232425package com.oy.online.JDBC1.text;import com.oy.online.JDBC1.util.JDBCUtils;import org.junit.Test;import java.sql.Connection;/***@Description 测试数据库是否连接成功*@Author OY*@Date 2020/5/31*@Time 14:46*/public class JDBCUtilTest &#123; @Test public void test() throws Exception &#123; for(int i = 0; i &lt; 100; i++)&#123; Connection conn = JDBCUtils.getConnection(); System.out.println(conn); JDBCUtils.closeResource(conn,null,null); &#125; &#125;&#125; 测试数据库增删改查连接 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120package com.oy.online.JDBC1.text;import com.oy.online.JDBC1.DAO.CustomerDAOImpI;import com.oy.online.JDBC1.bean.Customer;import com.oy.online.JDBC1.util.JDBCUtils;import org.junit.Test;import java.sql.Connection;import java.text.SimpleDateFormat;import java.util.Date;import java.util.List;public class CustomerDAOTest &#123; private CustomerDAOImpI custs = new CustomerDAOImpI(); @Test public void insert() &#123; Connection conn = null; try &#123; conn = JDBCUtils.getConnection(); SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); Date date = sdf.parse(&quot;2001-8-9&quot;); Customer cust = new Customer(1, &quot;小明&quot;, &quot;xiaoming@123.com&quot;, new java.sql.Date(date.getTime())); custs.insert(conn,cust); System.out.println(&quot;添加成功&quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; &#125; JDBCUtils.closeResource(conn,null,null); &#125; @Test public void deletById() &#123; Connection conn = null; try &#123; conn = JDBCUtils.getConnection(); custs.deletById(conn,30); System.out.println(&quot;删除成功&quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; JDBCUtils.closeResource(conn, null,null); &#125; &#125; @Test public void update() &#123; Connection conn = null; try &#123; conn = JDBCUtils.getConnection(); SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); Date date = sdf.parse(&quot;2000-9-12&quot;); Customer cust = new Customer(31, &quot;小白&quot;, &quot;xiaobai@126.com&quot;,new java.sql.Date(date.getTime())); custs.update(conn, cust); System.out.println(&quot;修改成功&quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; JDBCUtils.closeResource(conn,null,null); &#125; &#125; @Test public void getCustomerById() &#123; Connection conn = null; try &#123; conn = JDBCUtils.getConnection(); Customer cust = custs.getCustomerById(conn, 31); System.out.println(cust); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; JDBCUtils.closeResource(conn, null,null); &#125; &#125; @Test public void getAll() &#123; Connection conn = null; try &#123; conn = JDBCUtils.getConnection(); List&lt;Customer&gt; list = custs.getAll(conn); list.forEach(System.out::println); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; JDBCUtils.closeResource(conn,null,null); &#125; &#125; @Test public void getCount() &#123; Connection conn = null; try &#123; conn = JDBCUtils.getConnection(); Long count = custs.getCount(conn); System.out.println(count); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; JDBCUtils.closeResource(conn, null, null); &#125; &#125; @Test public void getMaxBirth() &#123; Connection conn = null; try &#123; conn = JDBCUtils.getConnection(); java.sql.Date max = custs.getMaxBirth(conn); System.out.println(max); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; JDBCUtils.closeResource(conn,null,null); &#125; &#125;&#125;","categories":[{"name":"JDBC","slug":"JDBC","permalink":"http://blog.oy6090.top/categories/JDBC/"}],"tags":[{"name":"JDBC数据连接池","slug":"JDBC数据连接池","permalink":"http://blog.oy6090.top/tags/JDBC%E6%95%B0%E6%8D%AE%E8%BF%9E%E6%8E%A5%E6%B1%A0/"}]},{"title":"javascript面向对象","slug":"javascrip 面向对象","date":"2020-07-11T16:00:00.000Z","updated":"2020-12-28T00:32:16.977Z","comments":true,"path":"posts/325844318.html","link":"","permalink":"http://blog.oy6090.top/posts/325844318.html","excerpt":"","text":"前言： 笔记中的详细代码，我已经打包放在笔记的最后。 面向对象1.1 对象（Object）对象时 JS 中的引用户数类型 对象时一种复合数据类型，在对象可以保存多个不同数据类型的属性 使用 typeof 检查一个对象时，会返回 object 1.1.1 创建对象 方式一： var obj = new Object(); 方式二： var obj = {}; 代码示例 12345678910111213&#x2F;&#x2F; 方式一:var obj &#x3D; new Object();obj.name &#x3D; &quot;小明&quot;;obj.age &#x3D; 12;obj.sex &#x3D; &#39;M&#39;;console.log(obj);console.log(obj.name);&#x2F;&#x2F; 方式二var obj2 &#x3D; &#123;&#125;;obj2.name &#x3D; &quot;小红&quot;;obj2.age &#x3D; 12;console.log(obj2.name); 1.1.2 向对象中添加属性 语法： 对象.属性名 = 属性值 对象[“属性名”] = 属性值 对象的属性名没有任何的要求，不需要遵守表示符的规范，但是尽量按照表示符的要求去写。 属性值也可以任意的数据类型。 1.1.3 读取对象的属性语法： 对象.属性名 对象[“属性名”] 如果读取一个对象吧没有的属性，它不会报错，而是返回一个 undefined 1.1.4 删除对象中的属性语法： delect 对象.属性名 delect 对象[“属性名”] 代码示例 12345var obj3 &#x3D; new Object();obj3.name &#x3D; &quot;小明&quot;;console.log(obj3.name); &#x2F;&#x2F;小明delete obj3.name;console.log(obj3.name);&#x2F;&#x2F; undefined 1.1.5 使用 in 检查对象中是否含有指定的属性 语法： “属性名 in 对象” 如果在对象中含有该属性，则返回 true 如果没有则返回 false 代码示例 1console.log(&quot;name&quot; in obj); 1.1.6 使用对象字面量，在创建对象时直接向对象中添加属性 语法： 1234var obj &#x3D; &#123; 属性名.属性值， 属性名.属性值&#125; 1.1.7 基本数据类型和引用数据类型基本数据类型： String Number Booolean Null Underfined 引用数据类型: Object 基本数据类型的数据，变量是直接保存它的值。 变量与变量之间是相互独立的，修改一个变量不会影响其他的变量 引用数据类型的数据，变量是保存的对象的引用（内存地址） 如果多个变量指向的是同一个对象，此时修改一个变量的属性，会影响其他的变量。 比价两个变量时，对于基本数据了类型，比较的就是值，对于引用数据类型比较的是地址，地址相同才相同 1.2 函数 （Function） 函数也是一个对象，也具有普通对象的功能 函数中可以封装一些代码，在需要的时候可以调用函数来执行这些代码 使用 typeof 检查一个函数是会返回 function 1.2.1 创建函数函数声明 123function 函数名(形参1,形参2...形参N)&#123; 语句...&#125;; 函数表达式 123var 函数名 &#x3D; function(形参1,形参2...形参N)&#123; 语句...&#125;; 代码示例 123456789101112function fun()&#123; console.log(&quot;这是一个函数&quot;); alert(&quot;哈哈哈&quot;); document.write(&quot;------(&gt;_&lt;)-----&lt;br&gt;&quot;);&#125;fun();var fun2 &#x3D; function()&#123; console.log(&quot;这是一个函数2&quot;); alert(&quot;哈哈哈&quot;); document.write(&quot;这是一个函数&quot;);&#125;fun2(); 1.2.2 调用函数123语法：函数对象（[实参1，实参2...实参N]）; fun() 、sum()、alert()、Number()、parselnt()当我们调用函数时，函数中封装的代码会按照编写的顺序执行 1.2.3 形参和实参形参：形式参数 定义函数时，可以在()中定义一个或多个形参，形参之间使用，隔开定义形参就相当于在函数内声明了对应的变量但是并不赋值。形参会在使用时才赋值。 实参：实际参数 调用函数时，可以在()传递实参，传递的实参会赋值给对应的形参，调用函数时 JS 解析器不会检查实参的类型和个数，可以传递任意数据类型的值。 如果实参的数量大于形参，多余的实参将不会赋值 如果实参的小于形参，则没有对应实参的形参将会赋值 undefined 代码示例 1234function fun1(a, b, c)&#123; console.log(a + b +c);&#125;fun1(1,2,3); 1.2.4 返回值 数的执行的结果 使用 return 来设置函数的返回值 语法： return 值; 该值就会成为函数的返回值，可以通过一个变量类接收返回值 return 后边的代码都不会执行。一旦执行到 return 语句时，函数就会立即退出。 return 后可以跟任意的类型值，可以是基本数据类型，也可以是一个对象。 如果 return 后不跟值，或者是不写 return 则函数默认返回 undefined。 break、coutinue 和 return break 退出循环 continue 跳出当次循环 return 退出函数 参数，函数的实参也可以是任意的数据类型 1.2.5 方法可以将一个函数设置为一个对象的属性,当一个对象的属性是一个函数时，我们称这个函数该对象的方法 对象.方法名(); 函数名(); 1.3 作用域作用域简单来说就是一个变量的作用范围。 在 JS 中作用域分成两种： &lt;1&gt; 全局作用域 直接在 script 标签中编写的代码都运行在全局域中 全局作用域在打开页面时创建，在页面关闭时销魂。 全局作用域中有一个全局对象 window，window 对象是由浏览器提供，可以在页面中直接使用，它代表的是整个的浏览器的窗口。 在全局作用域中创建的变量都会作为 window 对象的属性保存，在全局作用域中创建的函数都会作为 window 对象的方法保存 在全局作用域中创建的变量和函数可以在也页面的任意位置访问，在函数作用域也可以访问到全局作用域的变量。 &lt;2&gt; 函数作用域 函数作用域是函数执行时创建的作用域，每次调用函数都会创建一个新的函数作用域。 函数作用域在函数执行时创建，在函数执行结束都会销毁。 在函数作用域中创建的变量，不能在全局中访问。 当在函数作用域中使用一个变量时，它会先找自身的作用域寻找， 如果找到了则直接使用，如果没有找到则到上一级作用域中寻找， 如果找到了则使用，找不到则继续往上找，一直找 &lt;3&gt; 变量的的声明提起 在全局作用域中，使用 var 关键字声明的变量会在所在的代码执行之前被声明，但是不会赋值，所以我们可以在变量声明前使用变量。但是不使用 var 关键字声明的变量不会被执行提前。 在函数作用域中，也具有改特性，使用 var 关键字声明的变量会在函数所在的代码执行前被声明的变量会在函数所有的代码执行前被声明，如果没有使用 var 关键字声明变量，则变量会变成全局变量 &lt;4&gt; 函数的声明提前 在全局作用域中，使用函数声明创建的函数(function fun(){}),会在所有的代码块之前被创建，也就是我们可以在函数声明去调用函数，但是使用函数表达式(var fun = function(){})创建的函数没有该特性 在函数作用域中，使用函数声明创建的函数，会在所有的函数中代码执行之前就创建好了。 代码示例 &lt;1&gt; 12345678910var a &#x3D; 12;var b &#x3D; 10;function fun()&#123; console.log(&quot;我是fun函数&quot;);&#125;function fun2( a, b)&#123; window.alert(a+b);&#125;window.fun();window.fun2(a,b); &lt;2&gt; 12345678910fun();&#x2F;&#x2F; 函数声明，会被提前创建function fun()&#123; console.log(&quot;我是一个fun函数&quot;);&#125;;fun2();&#x2F;&#x2F; 函数表达式，不会提前创建var fun2 &#x3D; function () &#123; console.log(&quot;我是fun2函数&quot;);&#125;; &lt;3&gt;、&lt;4&gt; 123456789101112131415161718var a &#x3D; 10;function fun()&#123; var a &#x3D; 12; console.log(&quot;a的值为:&quot;+a);&#125; fun(); &#x2F;&#x2F; 12function fun2()&#123; console.log(a); var a &#x3D; 12;&#125; fun2(); &#x2F;&#x2F; undefinedfunction fun3()&#123; console.log(a); a &#x3D; 16;&#125;fun3(); &#x2F;&#x2F; 10console.log(a); &#x2F;&#x2F; 16 1.4 this(上下文对象) 我们每次调用函数时，解析器都会将一个上下文对象作为隐含的参数传递进函数。 使用 this 来引用上下文对象，根据函数的形式不同，this 的值也不同 this 的不同的情况： 1.函数不同的形式调用时,this 是 window 2.以方法的形式调用时,this 就是调用方法的对象 3.以构造函数的形式调用时，this 就是新创建对象 代码示例 12345678910111213function fun()&#123; console.log(this.name);&#125;var obj &#x3D;&#123; name : &quot;小明&quot;, sayName : fun&#125;;var obj2 &#x3D; &#123; name : &quot;小红&quot;, sayName : fun&#125;;obj.sayName(); &#x2F;&#x2F;小明obj2.sayName(); &#x2F;&#x2F; 小红 1.5 构造函数 构造函数时专门用来创建对象的函数 一个构造函数我们也可以称为一个类 通过一个构造函数创建的对象，我们称该对象时这个构造函数的实例 通过同一个构造函数创建的对象，我们称为一类对象 构造函数就是一个普通的函数，只是它的调用方式不同， 如果直接调用，它就是一个普通函数 如果使用 new 来调用，则它就是一个构造函数 例子： function Person(){ } 代码示例 123456789101112function Person(name , age, gender )&#123; this.name &#x3D; name ; this.age &#x3D; age; this.gendar &#x3D; gender; this.sayName &#x3D; function()&#123; alert(this.name); &#125;;&#125;;var p1 &#x3D; new Person(&quot;小明&quot;,12,&quot;男&quot;);console.log(p1);console.log(p1.age); 1.5.1 构造函数的执行流程① 创建一个新的对象 ② 将新的对象作为函数的上下文对象 ③ 执行函数中的代码 ④ 将新建的对象返回 1.5.2 instanceof 用来检查一个对象是否一个类的实例 语法： 对象 instanceof 构造函数 如果该对象时构建函数的实例，则返回 true,否则返回 false Object 是所有对象的祖先，所以任何对象和 Object 做 instanceof 都会返回 true 代码示例 1console.log(p1 instanceof Person); &#x2F;&#x2F; true 1.5.3 枚举对象中的属性for…in 语法： for(var 属性名 in 对象){ } for…in 语句的循环体会执行多次，对象中有几个属性就会执行几次，每次将一个属性名赋值给我们定义的变量，我们可以通过它来获取对象中的属性。 代码示例 1234567891011121314151617function fun() &#123; alert(this.name);&#125;function Person(name, age, gender)&#123; this.name &#x3D; name; this.age &#x3D; age; this.gendar &#x3D; gender; this.sayName &#x3D; fun;&#125;;var p1 &#x3D; new Person(&quot;小明&quot;,12,&quot;男&quot;);p1.sayName();for(var n in p1)&#123; console.log(&quot;属性&quot;+n); console.log(&quot;属性值:&quot;+p1[n]);&#125; 1.6 原型(prototype) 创建一个函数以后，解析器都会默认在函数添加一个数 prototype prototype 属性指向的是一个对象，这个对象我们称为原型对象。 当函数作为构造函数使用，它所创建的对象中都会含有一个隐含的属性执行该原型对象。 这个隐含的属性可以通过.** proto **来访问。 当原型对象就相当于一个公共的区域，凡是通过同一个构造函数创建的对象他们通常都可以访问到相同的原型对象 我们可以将对象中公有的属性和方法统一添加到原型的对象中，这样我们只需要添加一次就可以使所有的对象都可以使用。 当我们去访问对象的一个属性或调用对象的一个方法时，它会先自身中寻找， 如果在自身中找到，则直接使用。 如果没有找到，则去原型对象中寻找，如果找到了则使用， 如果没有找到，则去原型的原型中寻找，以此类推。直到找到 Object 原型为止，Object 的原型的原型的值为 null, 如果依然没有找到就返回 undefined hasOwnProperty() 这个方法可以用来检查对象自身中含有某个属性 语法：对象.hasOwnProperty(“属性名”) 代码示例 12345678910111213141516171819202122232425function Myclass()&#123;&#125;;&#x2F;&#x2F; 向MyClass的原型中添加一个Name属性Myclass.prototype.name &#x3D; &quot;我是原型中的名字&quot;;var mc &#x3D; new Myclass();mc.age &#x3D; 18;console.log(mc.name);&#x2F;&#x2F; 使用in检查对象中是否含有某个属性时，如果对象中没有但是原型中有，也会返回trueconsole.log(&quot;name&quot; in mc); &#x2F;&#x2F; trueconsole.log(mc.hasOwnProperty(&quot;age&quot;)); &#x2F;&#x2F; true&#x2F;&#x2F;console.log(mc.__proto__.hasOwnProperty(&quot;hasOwnProperty&quot;));&#x2F;&#x2F;console.log(mc.__proto__.__proto__.hasOwnProperty(&quot;hasOwnProperty&quot;));&#x2F;&#x2F;console.log(mc.__proto__.__proto__.__proto__);&#x2F;&#x2F;console.log(mc.hello);&#x2F;&#x2F;console.log(mc.__proto__.__proto__.__proto__) 1.7 数组（Array）数组也是一个对象，是一个用来存储数据对象和 Object 类似，但是它的存储效率比普通对象要高 数组中保存的内容我们称为元素 数组使用索引(index)来操作元素 索引指由 0 开始的整数 1.7.1 数组的操作 创建数组： var arr = new Array() var arr = []; 向数组中添加元素 语法： 数组对象[索引] = 值; arr[0] = 123; arr[1] = “hello”; 创建数组时直接添加元素 语法： var arr = [元素 1， 元素 2…元素 N]; 例子： var arr = [123,”hello”，true, null] 代码示例 12345678var arr &#x3D; new Array();arr[0] &#x3D; 1;arr[1] &#x3D; 2;console.log(arr[0]);var arr &#x3D; &#123;&#125;;arr[0] &#x3D; 123;arr[1] &#x3D; &quot;hello&quot;;console.log(arr[0]); 获取和修改数组的长度 使用 lenght 属性来操作数组的长度 获取长度： 数组.length length 获取到的是数组的最大索引+1 对于连续的数组，length 获取到的就是数组中元素的个数 修改数组的长度 数组.length = 新长度 如果修改后的 length 大于原长度，则多出的部分会空出来 如果修改的 length 小于原长度，则数组中多出的元素会被删除 向数组的最后添加元素 数组[数组.length] = 值 代码示例 12345var arr2 &#x3D; [1,2,3,4];console.log(arr2.length);arr2[arr2.length] &#x3D; 5;console.log(arr2);&#x2F;&#x2F; [1, 2, 3, 4, 5]console.log(arr2.length); 1.7.2 数组的方法 push() 用来向数组的末尾添加一个或多个元素，并返回数组的新长度 语法： 数组.push(元素 1，元素 2,元素 N) pop() 用来删除数组的最后一个元素，并返回被删除的新长度 unshift() 向数组的前边添加一个或多个元素，并返回数组的新长度 shuift() 删除数组的前边添加一个元素，并返回被删除的元素 、 slice() 可以从一个数组中截取指定的元素 该方法不会影响原数组，而是将截取到的内容封装为一个新的数组并返回 参数： 1.截取开始位置的索引（包括开始位置） 2.截取结束位置的索引（不包括结束位置） 第二个可以省略不写，如果不写则一直截取到最后 参数可以传递一个负值，如果是负值，则从后往前数 splice() 可以用来删除数组中指定的元素，并使用新的元素替换 该方法会将删除的元素封装到新的数组中返回 参数： 1.删除开始位置的索引 2.删除的个数 3.三个以后，都是替换元素，这些元素将会插入到开始位置的索引的前边 1.8 函数 call() apply() 这两个方法都是函数对象的方法需要通过函数对象来调用 通过两个方法都可以直接调用函数，并且可以通过第一个实参来指定函数中 this 不同的是 call 是直接传递函数的实参 apply 需要将实参封装到一个数组中传递 代码示例 123456789101112function fun(a, b)&#123; console.log(&quot;a&#x3D;&quot; + a); console.log(&quot;b&#x3D;&quot; + b);&#125;var obj &#x3D; &#123; name : &quot;obj&quot;, sayName:function () &#123; alert(this.name); &#125;&#125;;&#x2F;&#x2F; fun(obj,2,3)fun.apply(obj,[2,3]); arguments() arguments 和 this 类似，都是函数中的隐含的参数 arguments 是一个类数组元素，它用来封装函数执行过程中的实参,所以即使不定义形参，也可以通过 arguments 来使用实参 arguments 中有一个属性 callee 表示当前执行的函数对象 代码示例 12345function fun(a,b)&#123; &#x2F;&#x2F; console.log(arguments instanceof Array); console.log(arguments.callee &#x3D;&#x3D; fun)&#125;;fun(&quot;hello&quot;,true); &#x2F;&#x2F; t this this 是函数的上下文对象，根据函数的调用方式不同会执行不同的对象 1、函数的形式调用时，this 是 window 2、以方法的形式调用的形式调用时，this 是调用方法的对象 3、以构造函数的形式调用时，this 是新建的那个对象 4、使用 call 和 apply 调用时，this 是指的那个对象 5、在全局作用域中 this 代表 window 1.9 包装类在 JS 中为我们提供三个包装类：（不推荐） String() Boolean() Number() 通过这三个包装类可以创建基本类型的对象 例子： var num = new Number(2) var str = new String(“hello”) var bool = new Boolean(true) 但是在实际应用中千万这么干。 当我们去操作一个基本数据类型的属性和方法时， 解析器会临时将其转换为对应的包装类，然后再去操作属性和方法， 解析完成以后在将这个临时对象进行销毁。 1.10 字符串的相关方法1.10.1 length 获取字符串的长度 1.10.2 charAt() 根据索引获取指定的字符 1.10.3 charCodeAt() 根据索引获取指定的字符编码 1.10.4 String.fromCharCode() 根据字符编码获取字符 1.10.5 indexOf()1.10.6 lastindexOf() 从一个字符串中检索指定内容 需要一个字符串作为参数，这个字符串就是要检索的内容，如果找到该内容，则会返回其第一次出现的索引，如果没有找到则返回-1。 可以指定第二个参数，来表示开始查找的位置 indexOf()是从前往后找 lastindexOf()是从后向前找 1.10.7 slice() 可以从一个字符串中截取指定的内容，并将截取到的内容返回，不会影响变量 参数： 第一个:截取开始的位置（包括开始） 第二个：截取结束的位置（不包括结束） 可以省略第二个参数，如果省略则一直截取到最后 可以传负数，如果是负数则从后往前数 1.10.8 substr() 和 slice()基本一致，不同的是它不能接受负值作为一个参数，如果设置一个负值，则会自动修正为 0 substring()中如果第二个参数小于第一个，自动调整位置 1.10.9 toLowerCase() 将字符串转换为小写并返回 1.10.10 toUpperCase() 将字符串转换为大写并返回 1.10.11 split() 可以根据指定内容将一个字符串拆分为一个数组 参数： 需要一个字符串作为参数，将会根据字符串去拆分数组 可以接收一个正则表达式，此时会根据正则表达式去拆分数组 1.10.12 match() 可以将字符串中和正则表达式匹配的内容提取出来 参数： 正则表达式，可以根据该正则表达式将字符串中符合要求的内容提取出来 并且封装到一个数组中返回 1.10.13 replace() 可以将字符串中指定内容替换为新的内容 参数： 第一个：被替换的内容，可以是一个正则表达式 第二个：替换的新内容 1.10.14 search() 可以根据正则表达式去字符串中查找指定的内容 参数： 正则表达式，将会根据该表达式查询内容，并且将第一个匹配到的内容的索引返回，如果没有匹配到任何内容，则返回-1。 代码示例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&#x2F;&#x2F; 创建一个字符串var str &#x3D; &quot;Hello world&quot;;&#x2F;** * length 属性 *&#x2F;console.log(str.length); &#x2F;&#x2F; 11&#x2F;** * charAt() *&#x2F;var result &#x3D; str.charAt(2);console.log(result); &#x2F;&#x2F; l&#x2F;** * charCodeAt() *&#x2F;var result &#x3D; str.charCodeAt(0);console.log(result); &#x2F;&#x2F; 72&#x2F;** * String.fromCharCode() *&#x2F;var result &#x3D; String.fromCharCode(0x2692);console.log(result); &#x2F;&#x2F; ⚒&#x2F;** * concat() *&#x2F;result &#x3D; str.concat(&quot;你好，世界&quot;);console.log(result); &#x2F;&#x2F; Hello world你好，世界&#x2F;** * indexof() *&#x2F;str &#x3D; &quot;hello , worid&quot;;result &#x3D; str.indexOf(&quot;h&quot;,1);console.log(result); &#x2F;&#x2F; -1result &#x3D; str.lastIndexOf(&quot;h&quot;,5);console.log(result); &#x2F;&#x2F; 0&#x2F;** * slice() *&#x2F;str &#x3D; &quot;hello , world&quot;;result &#x3D; str.slice(1,4);&#x2F;&#x2F; ellresult &#x3D; str.slice(1,-1);console.log(result); &#x2F;&#x2F; ello , worl&#x2F;** * substring() *&#x2F;result &#x3D; str.substring(0,1); &#x2F;&#x2F; hconsole.log(result);&#x2F;** * substr() *&#x2F;result &#x3D; str.substr(3,2); &#x2F;&#x2F; loconsole.log(result);&#x2F;** * split() *&#x2F;str &#x3D; &quot;abcdefg&quot;;result &#x3D; str.split(&quot;d&quot;);console.log(result); &#x2F;&#x2F; [&quot;abc&quot;, &quot;efg&quot;]&#x2F;** * toUpperCase() *&#x2F;str &#x3D; &quot;abcdefg&quot;;result &#x3D; str.toUpperCase();console.log(result); &#x2F;&#x2F; ABCDEFG&#x2F;** * toLowerCase() *&#x2F;str &#x3D; &quot;ABCDEFG&quot;;result &#x3D; str.toLocaleLowerCase();console.log(result); &#x2F;&#x2F; abcdefg 12345678910111213141516171819202122232425262728var str &#x3D; &quot;1a2b3c4d5e6f7&quot;;&#x2F;** * split() *&#x2F;&#x2F;&#x2F; 用任意的字母来将字符串拆分var result &#x3D; str.split(&#x2F;[A-z]&#x2F;);console.log(result);str &#x3D; &quot;hello abc hello aec afc&quot;;&#x2F;** * search() *&#x2F;result &#x3D; str.search(&#x2F;a[befj]c&#x2F;);console.log(result);&#x2F;&#x2F; 6str &#x3D; &quot;1a2a3a4a5e6f7A8B9C&quot;;&#x2F;** * match() *&#x2F;result &#x3D; str.match(&#x2F;[a-z]&#x2F;ig);console.log(result[2]); &#x2F;&#x2F; a&#x2F;** * replace() *&#x2F;result &#x3D; str.replace(&#x2F;[a-z]&#x2F;gi,&quot;&quot;);console.log(result); &#x2F;&#x2F; 123456789 1.11 Date 日期的对象，在 JS 中通过 Date 对象来表示一个时间 创建对象 创建一个当前的时间对象 var d = new Date(); 创建一个指定的时间对象 var d = new Date(“月/日/年 时:分:秒”); 方法： getDate() 当前日期对象是几日（1-31） getDay() 返回当前日期对象时周几（0-6） 0 周日 1 周一 。。。 getMonth() 返回当前日期对象的月份（0-11） 0 一月 1 二月 。。。 getFullYear() 从 Date 对象以四位数字返回年份。 getHours() 返回 Date 对象的小时 (0 ~ 23)。 getMinutes() 返回 Date 对象的分钟 (0 ~ 59)。 getSeconds() 返回 Date 对象的秒数 (0 ~ 59)。 getMilliseconds() 返回 Date 对象的毫秒(0 ~ 999)。 getTime() 返回当前日期对象的时间戳 时间戳，指的是从 1970 年月 1 日 0 时 0 分 0 秒，到现在时间的毫秒数 计算机底层保存时间都是以时间戳的形式保存的。 Date.now() 可以获取当前代码执行时的时间戳 代码示例 12345678910111213141516171819202122232425262728293031323334353637var d &#x3D; new Date(); &#x2F;&#x2F; Sun Jun 28 2020 17:51:48 GMT+0800 (中国标准时间)console.log(d);var d &#x3D; new Date(&quot;2&#x2F;18&#x2F;2011 11:10:30&quot;);&#x2F;** * getDate() *&#x2F;var date &#x3D; d.getDate();console.log(date); &#x2F;&#x2F; 18&#x2F;** * getDay() * 会返回一个0-6的值 * 0 表示周日 * 1 表示周一 *&#x2F;date &#x3D; d.getDay();console.log(date); &#x2F;&#x2F; 5&#x2F;** * getMonth() * 会返回一个0-11的值 * 0 表示1月 * 1 表示2月 * 11 表示12月 *&#x2F;var month &#x3D; d.getMonth();console.log(month); &#x2F;&#x2F; 1&#x2F;** * getFullYear() *&#x2F;var year &#x3D; d.getFullYear();console.log(year); &#x2F;&#x2F; 2011&#x2F;** * getTime * 获取当前日期对象的时间戳 *&#x2F;var time &#x3D; d.getTime();console.log(time); &#x2F;&#x2F; 1297998630000 1.12 MathMath 属于一个工具类，它不需要我们创建对象，它里边封装了属性运算相关的常量和方法 我们可以直接使用它来进行数学运算相关的操作 方法： Math.PI 常量，圆周率 Math.abs() 绝对值运算 Math.ceil() 向上取整 Math.floor() 向下取整 Math.round() 四舍五入取整 Math.random() 生成一个 0-1 之间的随机数 生成一个 x-y 之间的随机数 ==Math.round(Math.random()*(y-x)+x);== Math.pow(x,y) 求 x 的 y 次幂 Math.sqrt() 对一个数进行开方 Math.max() 求多个数中最大值 Math.min() 求多个数中的最小值 代码示例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&#x2F;** * Math.PI *&#x2F;console.log(Math.PI); &#x2F;&#x2F; 3.141592653589793&#x2F;** * abs() *&#x2F;console.log(Math.abs(-1)); &#x2F;&#x2F; 1&#x2F;** * Math.ceil() * Math.floor() * Math.round() *&#x2F;console.log(Math.ceil(1.234)); &#x2F;&#x2F; 2console.log(Math.floor(1.2334));&#x2F;&#x2F; 1console.log(Math.round(2.5)); &#x2F;&#x2F; 3&#x2F;** * Math.random() * 生成一个0-x之间的随机数 * Math.round(Math.random()*x) * 生成一个x-y之间的随机数 * Math.round(Math.random()*(y-x)+x) *&#x2F;&#x2F;&#x2F; 生成一个0-10的随机数console.log(Math.random()); &#x2F;&#x2F; 0.6920747685502069&#x2F;&#x2F; 生成一个0-20的随机数console.log(Math.random()*20); &#x2F;&#x2F; 9.90282879250878&#x2F;&#x2F; 生成一个1-20的随机数console.log((Math.random()*19)+1); &#x2F;&#x2F; 6.28945228050076&#x2F;** * max() 可以获取多个数组的最大值 * min() 可以获取多个数组中的最小值 *&#x2F;console.log(Math.max(10,45,30,100)); &#x2F;&#x2F; 100console.log(Math.min(10,45,30,100));&#x2F;&#x2F; 10&#x2F;** * pow(x,y) *&#x2F;console.log(Math.pow(2,3)); &#x2F;&#x2F; 8&#x2F;** * sqrt() *&#x2F;console.log(Math.sqrt(4)); &#x2F;&#x2F; 2 1.13 正则表达式正则用来定义一些字符串的规则，程序可以根据这些规则来判断一个字符串是否符合规定，也可以将一个字符串符合规则的内容提取出来。 1.13.1 创建正则表达式 var reg = new RegExp(“正则”,”匹配模式”) var reg = /正则表达式/ 匹配模式 语法 匹配模式: i ： 忽视大小写 g : 全局匹配模式 设置匹配模式时，可以都不设置，也可以设置 1 个，也可以全设置，设置时没有顺序要求 1.13.2 正则语法：语法： | 或 [A-Z] 大写字母 [] 或 [A-z] 任意字母 [^] 除了 [0-9] 任意数字 [a-z] 小写字母 量词： {n} 正好 n 次 + 至少 1 次 {1,} {m,n} m-n 次 ? 0 次或 1 次 {0,1} {m,} 至少 m 次 * 0 次或多次 {0,} 转义字符： \\ . 表示. \\\\ 表示\\ . 表示任意字符 \\w 相当于[A-z0-9_] \\W 相当于[ ^ A-z0-9] \\d 任意数字 \\D 除了数字 \\s 空格 \\S 除了空格 \\b 单词边界 \\B 除了单词边界 ^ 表示开始 $ 表示结束 1.13.3 方法 test() 可以用来检查一个字符是否符合正则表达式 如果符合返回 true,否则返回 false 代码示例 12345678910111213141516171819202122var reg &#x3D; new RegExp(&quot;ab&quot;,&quot;i&quot;);var str &#x3D; &quot;a&quot;;console.log(reg.test(str)); &#x2F;&#x2F; falsevar reg &#x3D; &#x2F;a&#x2F;i; &#x2F;&#x2F; trueconsole.log(reg.test(&quot;abc&quot;));reg &#x3D; &#x2F;a|b|c&#x2F;; &#x2F;&#x2F; trueconsole.log(reg.test(&quot;adfasdscvd&quot;));reg &#x3D; &#x2F;[a-z]&#x2F;;console.log(reg.test(&quot;asddf&quot;)); &#x2F;&#x2F; true&#x2F;&#x2F;检查一个字符串中是否含有 abc 或 adc 或 aecreg &#x3D; &#x2F;a[bde]c&#x2F;;console.log(reg.test(&quot;abc&quot;));&#x2F;&#x2F; truereg &#x3D; &#x2F;[^ab]&#x2F;;console.log(reg.test(&quot;bcds&quot;)); &#x2F;&#x2F; truereg &#x3D; &#x2F;[^0-9]&#x2F;;console.log(reg.test(&quot;234234234532&quot;)); &#x2F;&#x2F; false 1234567891011121314&#x2F;&#x2F; 邮箱正则表达式 * 电子邮件 * hello .nihao @ abc .com.cn * * 任意字母数字下划线 .任意字母数字下划线 @ 任意字母数字 .任意字母（2-5位） .任意字母（2-5位） * * \\w&#123;3,&#125; (\\.\\w+)* @ [A-z0-9]+ (\\.[A-z]&#123;2,5&#125;)&#123;1,2&#125; *&#x2F; var emailReg &#x3D; &#x2F;^\\w&#123;3,&#125;(\\.\\w+)*@[A-z0-9]+(\\.[A-z]&#123;2,5&#125;)&#123;1,2&#125;$&#x2F;; var email &#x3D; &quot;abc.hello@163.com&quot;; console.log(emailReg.test(email)); 可以用 vscode 和 notepad++ 打开链接：https://pan.baidu.com/s/1yfS00YJtShuZVncxzWUrvw 提取码：7q9u","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://blog.oy6090.top/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"javascript基础","slug":"javascript基础","permalink":"http://blog.oy6090.top/tags/javascript%E5%9F%BA%E7%A1%80/"}]},{"title":"java多线程基础（二）","slug":"java多线程基础（二）","date":"2020-07-11T16:00:00.000Z","updated":"2021-01-22T03:50:04.621Z","comments":true,"path":"posts/53344.html","link":"","permalink":"http://blog.oy6090.top/posts/53344.html","excerpt":"","text":"未来可期。一位正行走在编程世界中的小白，希望能遇到更多正在努力中的小伙伴。 线程同步机制一、背景 我以生活中的例子来打开这个问题，例如：我们做火车买票为例子。创建个窗口，总票数为 100 张，使用实现 Runable 接口的方式 代码示例： 1234567891011121314151617181920212223242526272829303132class Window1 implements Runnable&#123; //总票数 private int ticket = 100; @Override public void run() &#123; while(true)&#123; if(ticket &gt; 0)&#123; System.out.println(Thread.currentThread().getName()+&quot;:卖票，票号为：&quot;+ticket); ticket--; &#125;else&#123; break; &#125; &#125; &#125;&#125;public class WindowTest1 &#123; public static void main(String[] args) &#123; Window1 w1 = new Window1(); Thread t1 = new Thread(w1); Thread t2 = new Thread(w1); Thread t3 = new Thread(w1); t1.setName(&quot;窗口一&quot;); t2.setName(&quot;窗口二&quot;); t3.setName(&quot;窗口三&quot;); t1.start(); t2.start(); t3.start(); &#125;&#125; 运行结果 在卖票的过程中，通过上面的代码运行的代码，在最后出现了重票、错票，从而出现了线程的安全问题。 出现线程安全的原因，就是当某个线程操作车票的过程中，尚未操作完成时，其他线程参与进来，一起来操作车票。 出现了问题，总要有解决的办法，在 java 多线程就给我们提供了这个解决办法方法。 我先简单的描述一下解决问题的方法，当一个线程 a 在操作 ticket 的时候，其他线程不能参与进来。直到线程 a 操作完 ticket 时，其他线程才可以开始操作 ticket.这种情况即使线程 a 出现了阻塞，也不能被改变。 二、解决方法方式一：同步代码块1234语法：synchronized(同步监视器)&#123; // 需要不同的代码&#125; 说明： 操作共享数据的代码，即为需要被同步的代码 –&gt; 不能包含代码多了，也不能包含的代码少了。 共享数据，多个数据共同操作的变量，比如：ticket 就是共享数据。 同步监视器俗称 锁。任何一个类的对象，都可以充当锁。 要求：多个线程必须要用同一把锁。 ① 解决继承 Thread 类线程安全问题代码示例： 1234567891011121314151617181920212223242526272829303132333435363738394041class Window2 extends Thread&#123; //共享数据 private static int ticket = 100; @Override public void run()&#123; //添加同步代码块 // Class clazz =Window2.class,其中Window2.class只会加载一次 while(true)&#123; synchronized(Window2.class)&#123; if(ticket &gt; 0)&#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(getName()+&quot;:卖票,票号为:&quot;+ticket); ticket--; &#125;else&#123; break; &#125; &#125; &#125; &#125;&#125;public class Window2Test &#123; public static void main(String[] args) &#123; Window2 t1 = new Window2(); Window2 t2 = new Window2(); Window2 t3 = new Window2(); t1.setName(&quot;窗口一&quot;); t2.setName(&quot;窗口二&quot;); t3.setName(&quot;窗口三&quot;); t1.start(); t2.start(); t3.start(); &#125;&#125; 运行结果： ② 解决实现 Runable 接口线程安全代码示例： 123456789101112131415161718192021222324252627282930313233343536class Window1 implements Runnable&#123; //总票数 private int ticket = 100; @Override public void run() &#123; while(true)&#123; //设置同步代码块 // 此时的this：唯一的Window1的对象 synchronized(this)&#123; if(ticket &gt; 0)&#123; System.out.println(Thread.currentThread().getName()+&quot;:卖票，票号为：&quot;+ticket); ticket--; &#125;else&#123; break; &#125; &#125; &#125; &#125;&#125;public class WindowTest1 &#123; public static void main(String[] args) &#123; Window1 w1 = new Window1(); Thread t1 = new Thread(w1); Thread t2 = new Thread(w1); Thread t3 = new Thread(w1); t1.setName(&quot;窗口一&quot;); t2.setName(&quot;窗口二&quot;); t3.setName(&quot;窗口三&quot;); t1.start(); t2.start(); t3.start(); &#125;&#125; 运行结果：补充： 在实现 Runable 接口创建多线程的方式中，我们可以考虑使用this充当同步监视器。在继承 Thread 类创建多线程的方式中，慎用 this 充当同步监视器，考虑使用当前类充当同步监视器。 方式二：同步方法 如果操作共享数据的代码完整的声明在一个方法中，我们不妨碍将此方法声明同步的 ① 使用同步方法解决 Thread 类的线程安全问题代码示例： 1234567891011121314151617181920212223242526272829303132333435class Window3 extends Thread&#123; private static int ticket = 100; @Override public void run()&#123; while(true)&#123; show(); &#125; &#125; private static synchronized void show()&#123; //同步监视器：Window3.class if(ticket &gt; 0)&#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()+&quot;：卖票，票号为：&quot;+ticket); ticket--; &#125; &#125;&#125;public class WindowTest3 &#123; public static void main(String[] args) &#123; Window3 w1 = new Window3(); Window3 w2 = new Window3(); Window3 w3 = new Window3(); w1.setName(&quot;窗口一&quot;); w2.setName(&quot;窗口二&quot;); w3.setName(&quot;窗口三&quot;); w1.start(); w2.start(); w3.start(); &#125;&#125; 运行结果： ② 使用同步方法解决实现 Runable 接口线程安全1234567891011121314151617181920212223242526272829303132class Window4 implements Runnable&#123; private int ticket = 100; @Override public void run() &#123; while (true)&#123; show(); &#125; &#125; private synchronized void show()&#123; //同步监视器:this if(ticket &gt; 0)&#123; System.out.println(Thread.currentThread().getName()+&quot;:卖票，票号为：&quot;+ticket); ticket--; &#125; &#125;&#125;public class WindowTest4 &#123; public static void main(String[] args) &#123; Window4 w = new Window4(); Thread t1 = new Thread(w); Thread t2 = new Thread(w); Thread t3 = new Thread(w); t1.setName(&quot;窗口一&quot;); t2.setName(&quot;窗口二&quot;); t3.setName(&quot;窗口三&quot;); t1.start(); t2.start(); t3.start(); &#125;&#125; 关于同步方法的总结： 同步方法仍然涉及到同步监视器只是不需要我们显示的声明。 非静态的同步方法，同步监视器是：this 静态的同步方法，同步监视器是: 当前类本身 方式三：Lock 锁 – JDK5.0 新增代码示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Window5 implements Runnable&#123; // 1.实例化ReentrantLock ReentrantLock lock = new ReentrantLock(); private int ticket = 100; @Override public void run() &#123; while(true)&#123; try &#123; lock.lock(); // 2. 调用锁定方法lock() if(ticket &gt; 0)&#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()+&quot;：售票，票号为：&quot;+ticket); ticket--; &#125;else&#123; break; &#125; &#125; finally &#123; // 3.调用解锁方法:unlock() lock.unlock(); &#125; &#125; &#125;&#125;public class LockTest &#123; public static void main(String[] args) &#123; Window5 w = new Window5(); Thread t1 = new Thread(w); Thread t2 = new Thread(w); Thread t3 = new Thread(w); t1.setName(&quot;窗口1&quot;); t2.setName(&quot;窗口2&quot;); t3.setName(&quot;窗口3&quot;); t1.start(); t2.start(); t3.start(); &#125;&#125; 运行结果： 总结使用的优先顺序 1Lock --&gt; 同步代码块(已经进入方法体,分配了相对应资源) --&gt; 同步方法（在方法体之外） 利弊 同步的方式，解决了线程的安全问题。–&gt; 好处 操作同步代码时，只能一个线程参与，其他线程等待。就相当于是一个的单线程的过程，效率低。 synchronzied 与 Lock 的异同 synchronzied 机制在执行完相对应的同步代码块后，自动的释放同步监视器 Lock 需要手动的启动（lock()），同时结束时也需要手动的实现(unlock()); 死锁 死锁的理解：不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁 说明： 出现死锁后，不会出现异常，不会出现提示，只是所有的线程都处于阻塞状态，无法继续 我们使用同步时，要避免出现死锁。 代码示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263class A &#123; public synchronized void foo(B b) &#123; //同步监视器：A类的对象：a System.out.println(&quot;当前线程名: &quot; + Thread.currentThread().getName() + &quot; 进入了A实例的foo方法&quot;); // ①// try &#123;// Thread.sleep(200);// &#125; catch (InterruptedException ex) &#123;// ex.printStackTrace();// &#125; System.out.println(&quot;当前线程名: &quot; + Thread.currentThread().getName() + &quot; 企图调用B实例的last方法&quot;); // ③ b.last(); &#125; public synchronized void last() &#123;//同步监视器：A类的对象：a System.out.println(&quot;进入了A类的last方法内部&quot;); &#125;&#125;class B &#123; public synchronized void bar(A a) &#123;//同步监视器：b System.out.println(&quot;当前线程名: &quot; + Thread.currentThread().getName() + &quot; 进入了B实例的bar方法&quot;); // ②// try &#123;// Thread.sleep(200);// &#125; catch (InterruptedException ex) &#123;// ex.printStackTrace();// &#125; System.out.println(&quot;当前线程名: &quot; + Thread.currentThread().getName() + &quot; 企图调用A实例的last方法&quot;); // ④ a.last(); &#125; public synchronized void last() &#123;//同步监视器：b System.out.println(&quot;进入了B类的last方法内部&quot;); &#125;&#125;public class DeadLock implements Runnable &#123; A a = new A(); B b = new B(); public void init() &#123; Thread.currentThread().setName(&quot;主线程&quot;); // 调用a对象的foo方法 a.foo(b); System.out.println(&quot;进入了主线程之后&quot;); &#125; @Override public void run() &#123; Thread.currentThread().setName(&quot;副线程&quot;); // 调用b对象的bar方法 b.bar(a); System.out.println(&quot;进入了副线程之后&quot;); &#125; public static void main(String[] args) &#123; DeadLock dl = new DeadLock(); new Thread(dl).start(); dl.init(); &#125;&#125; 运行结果： 线程通信一、线程通信涉及到的三个方法 wait():一旦执行此方法，当前线程就会进入阻塞状态，并释放同步监视器。notify():一旦执行方法，就会唤醒被 wait 的第一个线程，如果有多个线程被 wait，就唤醒优先级最高的那个。notifyAll():一旦执行此方法，就会唤醒所有被 wait()的线程。 代码示例： 线程通信的例子：使用两个线程打印 1-100。线程 1, 线程 2 交替打印 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Number implements Runnable&#123; private int number = 1; Object obj = new Object(); @Override public void run() &#123; while(true)&#123; synchronized(obj)&#123; //唤醒线程 obj.notify(); if(number &lt;= 100)&#123; try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()+&quot;:&quot; +number); number++; try &#123; // 使得调用如下wait()方法的线程进入阻塞状态 obj.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;else&#123; break; &#125; &#125; &#125; &#125;&#125;public class CommunicationTest &#123; public static void main(String[] args) &#123; Number number = new Number(); Thread t1 = new Thread(number); Thread t2 = new Thread(number); t1.setName(&quot;线程1&quot;); t2.setName(&quot;线程2&quot;); t1.start(); t2.start(); &#125;&#125; 运行结果： 二、说明 wait()，notify().notifyAll()**：三个方法必须用在同步代码块或同步方法中。**wait()，notify()，notifyAll():三个方法的调用者必须是同步代码块同步方法的同步监视器。否则会出现IllegalMonitorStateException异常wait()，notify()，notifyAll()**：三个方法时定义在java.lang.Object**类中。 三、释放锁的操作： ① 当前线程的同步方法、同步代码执行结束。② 当前线程在同步代码块、同步方法中遇到 break、return 终止该代码块、该方法的继承执行。③ 当前线程在同步代码块、同步方法中出现未处理的 Error 或 Exception，导致异常结束。④ 当前线程在同步代码块、同步方法中执行了线程对象的 wait（）方法，当前线程暂停，并释放锁 四、不会释放锁的操作 线程执行同步代码块或同步方法时，程序调用Thread.sleep()、Thread.yield(); 方法暂停当前线程的执行 线程执行同步代码块时，其他线程调用了线程的 supend()方法将线程挂起，该线程不会释放锁（同步监视器） 五、小结sleep()与 wait（）的异同 相同点：一旦执行方法，都可以使得当前的线程进入阻塞状态。 不同点： &lt;1&gt;两个方法声明的位置不同：Thread类中声明sleep()**，Object类中声明wait()** &lt;2&gt; 调用的要求不同：sleep（）可以在任何需要的场景下调用。wait（）必须使用在同步代码块或同步方法中。 java 多线程基础到这里结束了，在写博客同时一边复习自己所学的知识点，给自己不断积累知识点。","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.oy6090.top/categories/Java/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://blog.oy6090.top/tags/Java%E5%9F%BA%E7%A1%80/"}]}],"categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://blog.oy6090.top/categories/Web%E5%89%8D%E7%AB%AF/"},{"name":"MySQL","slug":"MySQL","permalink":"http://blog.oy6090.top/categories/MySQL/"},{"name":"CentOS","slug":"CentOS","permalink":"http://blog.oy6090.top/categories/CentOS/"},{"name":"JavaEE框架","slug":"JavaEE框架","permalink":"http://blog.oy6090.top/categories/JavaEE%E6%A1%86%E6%9E%B6/"},{"name":"Redis","slug":"Redis","permalink":"http://blog.oy6090.top/categories/Redis/"},{"name":"Git工具","slug":"Git工具","permalink":"http://blog.oy6090.top/categories/Git%E5%B7%A5%E5%85%B7/"},{"name":"工具","slug":"工具","permalink":"http://blog.oy6090.top/categories/%E5%B7%A5%E5%85%B7/"},{"name":"数据库","slug":"数据库","permalink":"http://blog.oy6090.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"项目实战","slug":"项目实战","permalink":"http://blog.oy6090.top/categories/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/"},{"name":"java","slug":"java","permalink":"http://blog.oy6090.top/categories/java/"},{"name":"Java基础","slug":"Java基础","permalink":"http://blog.oy6090.top/categories/Java%E5%9F%BA%E7%A1%80/"},{"name":"Java","slug":"Java","permalink":"http://blog.oy6090.top/categories/Java/"},{"name":"Linux","slug":"Linux","permalink":"http://blog.oy6090.top/categories/Linux/"},{"name":"Linux语言","slug":"Linux语言","permalink":"http://blog.oy6090.top/categories/Linux%E8%AF%AD%E8%A8%80/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://blog.oy6090.top/categories/JavaScript/"},{"name":"JDBC","slug":"JDBC","permalink":"http://blog.oy6090.top/categories/JDBC/"},{"name":"Java设计模式","slug":"Java设计模式","permalink":"http://blog.oy6090.top/categories/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"Java算法","slug":"Java算法","permalink":"http://blog.oy6090.top/categories/Java%E7%AE%97%E6%B3%95/"},{"name":"GitHub","slug":"GitHub","permalink":"http://blog.oy6090.top/categories/GitHub/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://blog.oy6090.top/tags/Vue/"},{"name":"MySQL","slug":"MySQL","permalink":"http://blog.oy6090.top/tags/MySQL/"},{"name":"CentOS 7","slug":"CentOS-7","permalink":"http://blog.oy6090.top/tags/CentOS-7/"},{"name":"java","slug":"java","permalink":"http://blog.oy6090.top/tags/java/"},{"name":"Docker","slug":"Docker","permalink":"http://blog.oy6090.top/tags/Docker/"},{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://blog.oy6090.top/tags/SpringCloud/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://blog.oy6090.top/tags/SpringBoot/"},{"name":"layui","slug":"layui","permalink":"http://blog.oy6090.top/tags/layui/"},{"name":"Redis","slug":"Redis","permalink":"http://blog.oy6090.top/tags/Redis/"},{"name":"GitHub","slug":"GitHub","permalink":"http://blog.oy6090.top/tags/GitHub/"},{"name":"Maven","slug":"Maven","permalink":"http://blog.oy6090.top/tags/Maven/"},{"name":"Mybatis","slug":"Mybatis","permalink":"http://blog.oy6090.top/tags/Mybatis/"},{"name":"java项目","slug":"java项目","permalink":"http://blog.oy6090.top/tags/java%E9%A1%B9%E7%9B%AE/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://blog.oy6090.top/tags/SpringMVC/"},{"name":"java基础","slug":"java基础","permalink":"http://blog.oy6090.top/tags/java%E5%9F%BA%E7%A1%80/"},{"name":"Spring","slug":"Spring","permalink":"http://blog.oy6090.top/tags/Spring/"},{"name":"Java","slug":"Java","permalink":"http://blog.oy6090.top/tags/Java/"},{"name":"jQuery","slug":"jQuery","permalink":"http://blog.oy6090.top/tags/jQuery/"},{"name":"JavaScript高级","slug":"JavaScript高级","permalink":"http://blog.oy6090.top/tags/JavaScript%E9%AB%98%E7%BA%A7/"},{"name":"JDBC数据连接池","slug":"JDBC数据连接池","permalink":"http://blog.oy6090.top/tags/JDBC%E6%95%B0%E6%8D%AE%E8%BF%9E%E6%8E%A5%E6%B1%A0/"},{"name":"Java基础","slug":"Java基础","permalink":"http://blog.oy6090.top/tags/Java%E5%9F%BA%E7%A1%80/"},{"name":"javaScript基础","slug":"javaScript基础","permalink":"http://blog.oy6090.top/tags/javaScript%E5%9F%BA%E7%A1%80/"},{"name":"Java设计模式","slug":"Java设计模式","permalink":"http://blog.oy6090.top/tags/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"Java算法","slug":"Java算法","permalink":"http://blog.oy6090.top/tags/Java%E7%AE%97%E6%B3%95/"},{"name":"javascript基础","slug":"javascript基础","permalink":"http://blog.oy6090.top/tags/javascript%E5%9F%BA%E7%A1%80/"}]}